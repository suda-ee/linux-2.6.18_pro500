#! /usr/bin/env bash
# Patch: -common_arm_freescale_mx27ads_spi
# Date: Wed Aug 29 07:26:45 2007

PATCHNUM=114
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Index: linux-2.6.18/arch/arm/mach-mx2/devices.c
===================================================================
--- linux-2.6.18.orig/arch/arm/mach-mx2/devices.c
+++ linux-2.6.18/arch/arm/mach-mx2/devices.c
@@ -26,6 +26,11 @@
  * @brief device configurations for mx27.
  */
 
+static void mxc_nop_release(struct device *dev)
+{
+        /* Nothing */
+}
+
 #if defined(CONFIG_SERIAL_MXC) || defined(CONFIG_SERIAL_MXC_MODULE)
 
 /*!
@@ -262,6 +267,138 @@ static int __init mxc_init_uart(void)
 }
 #endif
 
+/* SPI controller and device data */
+#if defined(CONFIG_SPI_MXC) || defined(CONFIG_SPI_MXC_MODULE)
+
+#ifdef CONFIG_SPI_MXC_SELECT1
+/*!
+ * Resource definition for the CSPI1
+ */
+static struct resource mxcspi1_resources[] = {
+        [0] = {
+               .start = CSPI1_BASE_ADDR,
+               .end = CSPI1_BASE_ADDR + SZ_4K - 1,
+               .flags = IORESOURCE_MEM,
+               },
+        [1] = {
+               .start = MXC_INT_CSPI1,
+               .end = MXC_INT_CSPI1,
+               .flags = IORESOURCE_IRQ,
+               },
+};
+
+/*! Platform Data for MXC CSPI1 */
+static struct mxc_spi_master mxcspi1_data = {
+        .maxchipselect = 4,
+        .spi_version = 0,
+};
+
+/*! Device Definition for MXC CSPI1 */
+static struct platform_device mxcspi1_device = {
+        .name = "mxc_spi",
+        .id = 0,
+        .dev = {
+                .release = mxc_nop_release,
+                .platform_data = &mxcspi1_data,
+                },
+        .num_resources = ARRAY_SIZE(mxcspi1_resources),
+        .resource = mxcspi1_resources,
+};
+
+#endif                          /* CONFIG_SPI_MXC_SELECT1 */
+
+#ifdef CONFIG_SPI_MXC_SELECT2
+/*!
+ * Resource definition for the CSPI2
+ */
+static struct resource mxcspi2_resources[] = {
+        [0] = {
+               .start = CSPI2_BASE_ADDR,
+               .end = CSPI2_BASE_ADDR + SZ_4K - 1,
+               .flags = IORESOURCE_MEM,
+               },
+        [1] = {
+               .start = MXC_INT_CSPI2,
+               .end = MXC_INT_CSPI2,
+               .flags = IORESOURCE_IRQ,
+               },
+};
+
+/*! Platform Data for MXC CSPI2 */
+static struct mxc_spi_master mxcspi2_data = {
+        .maxchipselect = 4,
+        .spi_version = 0,
+};
+
+/*! Device Definition for MXC CSPI2 */
+static struct platform_device mxcspi2_device = {
+        .name = "mxc_spi",
+        .id = 1,
+        .dev = {
+                .release = mxc_nop_release,
+                .platform_data = &mxcspi2_data,
+                },
+        .num_resources = ARRAY_SIZE(mxcspi2_resources),
+        .resource = mxcspi2_resources,
+};
+#endif                          /* CONFIG_SPI_MXC_SELECT2 */
+
+#ifdef CONFIG_SPI_MXC_SELECT3
+/*!
+ * Resource definition for the CSPI3
+ */
+static struct resource mxcspi3_resources[] = {
+        [0] = {
+               .start = CSPI3_BASE_ADDR,
+               .end = CSPI3_BASE_ADDR + SZ_4K - 1,
+               .flags = IORESOURCE_MEM,
+               },
+        [1] = {
+               .start = INT_CSPI3,
+               .end = INT_CSPI3,
+               .flags = IORESOURCE_IRQ,
+               },
+};
+
+/*! Platform Data for MXC CSPI3 */
+static struct mxc_spi_master mxcspi3_data = {
+        .maxchipselect = 4,
+        .spi_version = 0,
+};
+
+/*! Device Definition for MXC CSPI3 */
+static struct platform_device mxcspi3_device = {
+        .name = "mxc_spi",
+        .id = 2,
+        .dev = {
+                .release = mxc_nop_release,
+                .platform_data = &mxcspi3_data,
+                },
+        .num_resources = ARRAY_SIZE(mxcspi3_resources),
+        .resource = mxcspi3_resources,
+};
+#endif                          /* CONFIG_SPI_MXC_SELECT3 */
+
+static inline void mxc_init_spi(void)
+{
+#ifdef CONFIG_SPI_MXC_SELECT1
+        if (platform_device_register(&mxcspi1_device) < 0)
+                printk(KERN_ERR "Registering the SPI Controller_1\n");
+#endif                          /* CONFIG_SPI_MXC_SELECT1 */
+#ifdef CONFIG_SPI_MXC_SELECT2
+        if (platform_device_register(&mxcspi2_device) < 0)
+                printk(KERN_ERR "Registering the SPI Controller_2\n");
+#endif                          /* CONFIG_SPI_MXC_SELECT2 */
+#ifdef CONFIG_SPI_MXC_SELECT3
+        if (platform_device_register(&mxcspi3_device) < 0)
+                printk(KERN_ERR "Registering the SPI Controller_3\n");
+#endif                          /* CONFIG_SPI_MXC_SELECT3 */
+}
+#else
+static inline void mxc_init_spi(void)
+{
+}
+#endif
 
 struct mxc_gpio_port mxc_gpio_ports[GPIO_PORT_NUM] = {
 	{
@@ -304,6 +441,7 @@ struct mxc_gpio_port mxc_gpio_ports[GPIO
 
 static int __init mxc_init_devices(void)
 {
+        mxc_init_spi();
 	mxc_init_uart();
 	return 0;
 }
Index: linux-2.6.18/drivers/spi/Kconfig
===================================================================
--- linux-2.6.18.orig/drivers/spi/Kconfig
+++ linux-2.6.18/drivers/spi/Kconfig
@@ -117,6 +117,34 @@ config SPI_OMAP24XX
 	help
 	  SPI master controller for OMAP24xx McSPI modules.
 
+config SPI_MXC
+        tristate "MXC CSPI controller as SPI Master"
+        depends on ARCH_MXC && SPI_MASTER
+        select SPI_BITBANG
+        help
+          This implements the SPI master mode using MXC CSPI.
+
+config SPI_MXC_TEST_LOOPBACK
+        bool "LOOPBACK Testing of CSPIs"
+        depends on SPI_MXC
+        default n
+
+config SPI_MXC_SELECT1
+        bool "CSPI1"
+        depends on SPI_MXC
+        default y
+
+config SPI_MXC_SELECT2
+        bool "CSPI2"
+        depends on SPI_MXC
+        default n
+
+config SPI_MXC_SELECT3
+        bool "CSPI3"
+        depends on SPI_MXC && (ARCH_MX3 || ARCH_MX27)
+        default n
+
+
 #
 # Add new SPI master controllers in alphabetical order above this line
 #
Index: linux-2.6.18/drivers/spi/Makefile
===================================================================
--- linux-2.6.18.orig/drivers/spi/Makefile
+++ linux-2.6.18/drivers/spi/Makefile
@@ -19,6 +19,7 @@ obj-$(CONFIG_SPI_S3C24XX_GPIO)		+= spi_s
 obj-$(CONFIG_SPI_S3C24XX)		+= spi_s3c24xx.o
 obj-$(CONFIG_SPI_OMAP24XX)		+= omap2_mcspi.o
 obj-$(CONFIG_SPI_OMAP_UWIRE)		+= omap_uwire.o
+obj-$(CONFIG_SPI_MXC)                   += mxc_spi.o
 # 	... add above this line ...
 
 # SPI protocol drivers (device/link on bus)
Index: linux-2.6.18/drivers/spi/mxc_spi.c
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/spi/mxc_spi.c
@@ -0,0 +1,914 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-licensisr_locke.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup SPI Configurable Serial Peripheral Interface (CSPI) Driver
+ */
+
+/*!
+ * @file mxc_spi.c
+ * @brief This file contains the implementation of the SPI master controller services
+ *
+ *
+ * @ingroup SPI
+ */
+
+#include <linux/completion.h>
+#include <linux/platform_device.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/types.h>
+#include <linux/clk.h>
+
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_bitbang.h>
+
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <asm/arch/gpio.h>
+
+#ifdef CONFIG_ARCH_MX2
+#include "mxc_spi_mx27.h"
+#endif
+
+#ifdef CONFIG_SPI_MXC_TEST_LOOPBACK
+struct spi_chip_info {
+	int lb_enable;
+};
+
+static struct spi_chip_info lb_chip_info = {
+	.lb_enable = 1,
+};
+
+static struct spi_board_info loopback_info[] = {
+#ifdef CONFIG_SPI_MXC_SELECT1
+	{
+	 .modalias = "loopback_spi",
+	 .controller_data = &lb_chip_info,
+	 .irq = 0,
+	 .max_speed_hz = 4000000,
+	 .bus_num = 1,
+	 .chip_select = 4,
+	 },
+#endif
+#ifdef CONFIG_SPI_MXC_SELECT2
+	{
+	 .modalias = "loopback_spi",
+	 .controller_data = &lb_chip_info,
+	 .irq = 0,
+	 .max_speed_hz = 4000000,
+	 .bus_num = 2,
+	 .chip_select = 4,
+	 },
+#endif
+#ifdef CONFIG_SPI_MXC_SELECT3
+	{
+	 .modalias = "loopback_spi",
+	 .controller_data = &lb_chip_info,
+	 .irq = 0,
+	 .max_speed_hz = 4000000,
+	 .bus_num = 3,
+	 .chip_select = 4,
+	 },
+#endif
+};
+#endif
+
+extern void gpio_spi_active(int cspi_mod);
+extern void gpio_spi_inactive(int cspi_mod);
+
+static struct mxc_spi_unique_def spi_ver_0_7 = {
+	.intr_bit_shift = MXC_CSPIINT_IRQSHIFT_0_7,
+	.cs_shift = MXC_CSPICTRL_CSSHIFT_0_7,
+	.bc_shift = MXC_CSPICTRL_BCSHIFT_0_7,
+	.bc_mask = MXC_CSPICTRL_BCMASK_0_7,
+	.drctrl_shift = MXC_CSPICTRL_DRCTRLSHIFT_0_7,
+	.xfer_complete = MXC_CSPISTAT_TC_0_7,
+	.bc_overflow = MXC_CSPISTAT_BO_0_7,
+};
+
+static struct mxc_spi_unique_def spi_ver_0_5 = {
+	.intr_bit_shift = MXC_CSPIINT_IRQSHIFT_0_5,
+	.cs_shift = MXC_CSPICTRL_CSSHIFT_0_5,
+	.bc_shift = MXC_CSPICTRL_BCSHIFT_0_5,
+	.bc_mask = MXC_CSPICTRL_BCMASK_0_5,
+	.drctrl_shift = MXC_CSPICTRL_DRCTRLSHIFT_0_5,
+	.xfer_complete = MXC_CSPISTAT_TC_0_5,
+	.bc_overflow = MXC_CSPISTAT_BO_0_5,
+};
+
+static struct mxc_spi_unique_def spi_ver_0_4 = {
+	.intr_bit_shift = MXC_CSPIINT_IRQSHIFT_0_4,
+	.cs_shift = MXC_CSPICTRL_CSSHIFT_0_4,
+	.bc_shift = MXC_CSPICTRL_BCSHIFT_0_4,
+	.bc_mask = MXC_CSPICTRL_BCMASK_0_4,
+	.drctrl_shift = MXC_CSPICTRL_DRCTRLSHIFT_0_4,
+	.xfer_complete = MXC_CSPISTAT_TC_0_4,
+	.bc_overflow = MXC_CSPISTAT_BO_0_4,
+};
+
+static struct mxc_spi_unique_def spi_ver_0_0 = {
+	.intr_bit_shift = MXC_CSPIINT_IRQSHIFT_0_0,
+	.cs_shift = MXC_CSPICTRL_CSSHIFT_0_0,
+	.bc_shift = MXC_CSPICTRL_BCSHIFT_0_0,
+	.bc_mask = MXC_CSPICTRL_BCMASK_0_0,
+	.drctrl_shift = MXC_CSPICTRL_DRCTRLSHIFT_0_0,
+	.xfer_complete = MXC_CSPISTAT_TC_0_0,
+	.bc_overflow = MXC_CSPISTAT_BO_0_0,
+};
+
+struct mxc_spi;
+/*!
+ * Structure to group together all the data buffers and functions
+ * used in data transfers.
+ */
+struct mxc_spi_xfer {
+	/*!
+	 * Transmit buffer.
+	 */
+	const void *tx_buf;
+	/*!
+	 * Receive buffer.
+	 */
+	void *rx_buf;
+	/*!
+	 * Data transfered count.
+	 */
+	unsigned int count;
+
+	/*!
+	 * Function to read the FIFO data to rx_buf.
+	 */
+	void (*rx_get) (struct mxc_spi *, u32 val);
+	/*!
+	 * Function to get the data to be written to FIFO.
+	 */
+	 u32(*tx_get) (struct mxc_spi *);
+};
+
+/*!
+ * This structure is a way for the low level driver to define their own
+ * \b spi_master structure. This structure includes the core \b spi_master
+ * structure that is provided by Linux SPI Framework/driver as an
+ * element and has other elements that are specifically required by this
+ * low-level driver.
+ */
+struct mxc_spi {
+	/*!
+	 * SPI Master and a simple I/O queue runner.
+	 */
+	struct spi_bitbang mxc_bitbang;
+	/*!
+	 * Completion flags used in data transfers.
+	 */
+	struct completion xfer_done;
+	/*!
+	 * Data transfer structure.
+	 */
+	struct mxc_spi_xfer transfer;
+	/*!
+	 * Resource structure, which will maintain base addresses and IRQs.
+	 */
+	struct resource *res;
+	/*!
+	 * Base address of CSPI, used in readl and writel.
+	 */
+	void *base;
+	/*!
+	 * CSPI IRQ number.
+	 */
+	int irq;
+	/*!
+	 * CSPI Clock id.
+	 */
+	struct clk *clk;
+	/*!
+	 * CSPI input clock SCLK.
+	 */
+	unsigned long spi_ipg_clk;
+	/*!
+	 * CSPI registers' bit pattern.
+	 */
+	struct mxc_spi_unique_def *spi_ver_def;
+};
+
+#define MXC_SPI_BUF_RX(type)	\
+void mxc_spi_buf_rx_##type(struct mxc_spi *master_drv_data, u32 val)\
+{\
+	type *rx = master_drv_data->transfer.rx_buf;\
+	*rx++ = (type)val;\
+	master_drv_data->transfer.rx_buf = rx;\
+}
+
+#define MXC_SPI_BUF_TX(type)    \
+u32 mxc_spi_buf_tx_##type(struct mxc_spi *master_drv_data)\
+{\
+	u32 val;\
+	const type *tx = master_drv_data->transfer.tx_buf;\
+	val = *tx++;\
+	master_drv_data->transfer.tx_buf = tx;\
+	return val;\
+}
+MXC_SPI_BUF_RX(u8)
+    MXC_SPI_BUF_TX(u8)
+    MXC_SPI_BUF_RX(u16)
+    MXC_SPI_BUF_TX(u16)
+    MXC_SPI_BUF_RX(u32)
+    MXC_SPI_BUF_TX(u32)
+
+/*!
+ * This function enables CSPI interrupt(s)
+ *
+ * @param        master_data the pointer to mxc_spi structure
+ * @param        irqs        the irq(s) to set (can be a combination)
+ *
+ * @return       This function returns 0 if successful, -1 otherwise.
+ */
+static int spi_enable_interrupt(struct mxc_spi *master_data, unsigned int irqs)
+{
+	if (irqs & ~((1 << master_data->spi_ver_def->intr_bit_shift) - 1)) {
+		return -1;
+	}
+
+	__raw_writel((irqs | __raw_readl(master_data->base + MXC_CSPIINT)),
+		     master_data->base + MXC_CSPIINT);
+
+	return 0;
+}
+
+/*!
+ * This function disables CSPI interrupt(s)
+ *
+ * @param        master_data the pointer to mxc_spi structure
+ * @param        irqs        the irq(s) to reset (can be a combination)
+ *
+ * @return       This function returns 0 if successful, -1 otherwise.
+ */
+static int spi_disable_interrupt(struct mxc_spi *master_data, unsigned int irqs)
+{
+	if (irqs & ~((1 << master_data->spi_ver_def->intr_bit_shift) - 1)) {
+		return -1;
+	}
+
+	__raw_writel((~irqs & __raw_readl(master_data->base + MXC_CSPIINT)),
+		     master_data->base + MXC_CSPIINT);
+	return 0;
+}
+
+/*!
+ * This function sets the baud rate for the SPI module.
+ *
+ * @param        master_data the pointer to mxc_spi structure
+ * @param        baud        the baud rate
+ *
+ * @return       This function returns the baud rate divisor.
+ */
+static unsigned int spi_find_baudrate(struct mxc_spi *master_data,
+				      unsigned int baud)
+{
+	unsigned int divisor;
+	unsigned int shift = 0;
+
+	/* Calculate required divisor (rounded) */
+	divisor = (master_data->spi_ipg_clk + baud / 2) / baud;
+	while (divisor >>= 1)
+		shift++;
+	MXC_CSPICTRL_ADJUST_SHIFT(shift);
+	if (shift > MXC_CSPICTRL_MAXDATRATE)
+		shift = MXC_CSPICTRL_MAXDATRATE;
+
+	return (shift << MXC_CSPICTRL_DATASHIFT);
+}
+
+/*!
+ * This function gets the received data.
+ *
+ * @param        base   the CSPI base address
+ *
+ * @return       This function returns Rx FIFO data read.
+ */
+static unsigned int spi_get_rx_data(void *base)
+{
+	return __raw_readl(base + MXC_CSPIRXDATA);
+}
+
+/*!
+ * This function loads the transmit fifo.
+ *
+ * @param        base   the CSPI base address
+ * @param        val    the data to put in the TxFIFO
+ */
+static void spi_put_tx_data(void *base, unsigned int val)
+{
+	unsigned int ctrl_reg;
+
+	__raw_writel(val, base + MXC_CSPITXDATA);
+
+	ctrl_reg = __raw_readl(base + MXC_CSPICTRL);
+
+	ctrl_reg |= MXC_CSPICTRL_XCH;
+
+	__raw_writel(ctrl_reg, base + MXC_CSPICTRL);
+
+	return;
+}
+
+/*!
+ * This function configures the hardware CSPI for the current SPI device.
+ * It sets the word size, transfer mode, data rate for this device.
+ *
+ * @param       spi     	the current SPI device
+ * @param	is_active 	indicates whether to active/deactivate the current device
+ */
+void mxc_spi_chipselect(struct spi_device *spi, int is_active)
+{
+	struct mxc_spi *master_drv_data;
+	struct mxc_spi_xfer *ptransfer;
+	struct mxc_spi_unique_def *spi_ver_def;
+	unsigned int ctrl_reg;
+	unsigned int ctrl_mask;
+	unsigned int xfer_len;
+
+	if (is_active == BITBANG_CS_INACTIVE) {
+		/*Need to deselect the slave */
+		return;
+	}
+
+	/* Get the master controller driver data from spi device's master */
+
+	master_drv_data = spi_master_get_devdata(spi->master);
+	spi_ver_def = master_drv_data->spi_ver_def;
+
+	xfer_len = spi->bits_per_word;
+
+	/* Control Register Settings for transfer to this slave */
+
+	ctrl_reg = __raw_readl(master_drv_data->base + MXC_CSPICTRL);
+
+	ctrl_mask =
+	    (MXC_CSPICTRL_LOWPOL | MXC_CSPICTRL_PHA | MXC_CSPICTRL_HIGHSSPOL |
+	     MXC_CSPICTRL_CSMASK << spi_ver_def->cs_shift |
+	     MXC_CSPICTRL_DATAMASK << MXC_CSPICTRL_DATASHIFT |
+	     spi_ver_def->bc_mask << spi_ver_def->bc_shift);
+	ctrl_reg &= ~ctrl_mask;
+
+	ctrl_reg |=
+	    ((spi->chip_select & MXC_CSPICTRL_CSMASK) << spi_ver_def->cs_shift);
+	ctrl_reg |= spi_find_baudrate(master_drv_data, spi->max_speed_hz);
+	ctrl_reg |=
+	    (((xfer_len - 1) & spi_ver_def->bc_mask) << spi_ver_def->bc_shift);
+	if (spi->mode & SPI_CPHA)
+		ctrl_reg |= MXC_CSPICTRL_PHA;
+	if (!(spi->mode & SPI_CPOL))
+		ctrl_reg |= MXC_CSPICTRL_LOWPOL;
+	if (spi->mode & SPI_CS_HIGH)
+		ctrl_reg |= MXC_CSPICTRL_HIGHSSPOL;
+
+	__raw_writel(ctrl_reg, master_drv_data->base + MXC_CSPICTRL);
+
+	/* Initialize the functions for transfer */
+	ptransfer = &master_drv_data->transfer;
+	if (xfer_len <= 8) {
+		ptransfer->rx_get = mxc_spi_buf_rx_u8;
+		ptransfer->tx_get = mxc_spi_buf_tx_u8;
+	} else if (xfer_len <= 16) {
+		ptransfer->rx_get = mxc_spi_buf_rx_u16;
+		ptransfer->tx_get = mxc_spi_buf_tx_u16;
+	} else if (xfer_len <= 32) {
+		ptransfer->rx_get = mxc_spi_buf_rx_u32;
+		ptransfer->tx_get = mxc_spi_buf_tx_u32;
+	}
+#ifdef CONFIG_SPI_MXC_TEST_LOOPBACK
+	{
+		struct spi_chip_info *lb_chip =
+		    (struct spi_chip_info *)spi->controller_data;
+		if (!lb_chip)
+			__raw_writel(0, master_drv_data->base + MXC_CSPITEST);
+		else if (lb_chip->lb_enable)
+			__raw_writel(MXC_CSPITEST_LBC,
+				     master_drv_data->base + MXC_CSPITEST);
+	}
+#endif
+	return;
+}
+
+/*!
+ * This function is called when an interrupt occurs on the SPI modules.
+ * It is the interrupt handler for the SPI modules.
+ *
+ * @param        irq        the irq number
+ * @param        dev_id     the pointer on the device
+ *
+ * @return       The function returns IRQ_HANDLED when handled.
+ */
+static irqreturn_t mxc_spi_isr(int irq, void *dev_id)
+{
+	struct mxc_spi *master_drv_data = dev_id;
+	irqreturn_t ret = IRQ_NONE;
+	unsigned int status;
+
+	/* Read the interrupt status register to determine the source */
+	status = __raw_readl(master_drv_data->base + MXC_CSPISTAT);
+
+	/* Rx is given higher priority - Handle it first */
+	if (status & MXC_CSPISTAT_RR) {
+		u32 rx_tmp = spi_get_rx_data(master_drv_data->base);
+
+		if (master_drv_data->transfer.rx_buf)
+			master_drv_data->transfer.rx_get(master_drv_data,
+							 rx_tmp);
+
+		ret = IRQ_HANDLED;
+	}
+
+	(master_drv_data->transfer.count)--;
+	/* Handle the Tx now */
+	if (master_drv_data->transfer.count) {
+		if (master_drv_data->transfer.tx_buf) {
+			u32 tx_tmp =
+			    master_drv_data->transfer.tx_get(master_drv_data);
+
+			spi_put_tx_data(master_drv_data->base, tx_tmp);
+		}
+	} else {
+		complete(&master_drv_data->xfer_done);
+	}
+
+	/* Clear the interrupt status */
+	//__raw_writel(spi_ver_def->spi_status_transfer_complete,
+	//           master_drv_data->base + MXC_CSPISTAT);
+
+	return ret;
+}
+
+/*!
+ * This function initialize the current SPI device.
+ *
+ * @param        spi     the current SPI device.
+ *
+ */
+int mxc_spi_setup(struct spi_device *spi)
+{
+	struct mxc_spi *master_data = spi_master_get_devdata(spi->master);
+
+	if ((spi->max_speed_hz < 0)
+	    || (spi->max_speed_hz > (master_data->spi_ipg_clk / 4)))
+		return -EINVAL;
+
+	if (!spi->bits_per_word)
+		spi->bits_per_word = 8;
+
+	pr_debug("%s: mode %d, %u bpw, %d hz\n", __FUNCTION__,
+		 spi->mode, spi->bits_per_word, spi->max_speed_hz);
+
+	return 0;
+}
+
+/*!
+ * This function is called when the data has to transfer from/to the
+ * current SPI device. It enables the Rx interrupt, initiates the transfer.
+ * When Rx interrupt occurs, the completion flag is set. It then disables
+ * the Rx interrupt.
+ *
+ * @param        spi        the current spi device
+ * @param        t          the transfer request - read/write buffer pairs
+ *
+ * @return       Returns 0 on success -1 on failure.
+ */
+int mxc_spi_transfer(struct spi_device *spi, struct spi_transfer *t)
+{
+	struct mxc_spi *master_drv_data = NULL;
+
+	/* Get the master controller driver data from spi device's master */
+
+	master_drv_data = spi_master_get_devdata(spi->master);
+
+	/* Modify the Tx, Rx, Count */
+
+	master_drv_data->transfer.tx_buf = t->tx_buf;
+	master_drv_data->transfer.rx_buf = t->rx_buf;
+	master_drv_data->transfer.count = t->len;
+	INIT_COMPLETION(master_drv_data->xfer_done);
+
+	/* Enable the Rx Interrupts */
+
+	spi_enable_interrupt(master_drv_data, MXC_CSPIINT_RREN);
+
+	/* Perform single Tx transaction */
+
+	spi_put_tx_data(master_drv_data->base,
+			master_drv_data->transfer.tx_get(master_drv_data));
+
+	/* Wait for transfer completion */
+
+	wait_for_completion(&master_drv_data->xfer_done);
+
+	/* Disable the Rx Interrupts */
+
+	spi_disable_interrupt(master_drv_data, MXC_CSPIINT_RREN);
+
+	return (t->len - master_drv_data->transfer.count);
+}
+
+/*!
+ * This function releases the current SPI device's resources.
+ *
+ * @param        spi     the current SPI device.
+ *
+ */
+void mxc_spi_cleanup(const struct spi_device *spi)
+{
+	return;
+}
+
+/*!
+ * This function is called during the driver binding process. Based on the CSPI
+ * hardware module that is being probed this function adds the appropriate SPI module
+ * structure in the SPI core driver.
+ *
+ * @param   pdev  the device structure used to store device specific
+ *                information that is used by the suspend, resume and remove
+ *                functions.
+ *
+ * @return  The function returns 0 on successful registration and initialization
+ *          of CSPI module. Otherwise returns specific error code.
+ */
+static int mxc_spi_probe(struct platform_device *pdev)
+{
+	struct mxc_spi_master *mxc_platform_info;
+	struct spi_master *master;
+	struct mxc_spi *master_drv_data = NULL;
+	unsigned int spi_ver;
+	int ret = -ENODEV;
+
+	/* Get the platform specific data for this master device */
+
+	mxc_platform_info = (struct mxc_spi_master *)pdev->dev.platform_data;
+	if (!mxc_platform_info) {
+		dev_err(&pdev->dev, "can't get the platform data for CSPI\n");
+		return -EINVAL;
+	}
+
+	/* Allocate SPI master controller */
+
+	master = spi_alloc_master(&pdev->dev, sizeof(struct mxc_spi));
+	if (!master) {
+		dev_err(&pdev->dev, "can't alloc for spi_master\n");
+		return -ENOMEM;
+	}
+
+	/* Set this device's driver data to master */
+
+	platform_set_drvdata(pdev, master);
+
+	/* Set this master's data from platform_info */
+
+	master->bus_num = pdev->id + 1;
+	master->num_chipselect = mxc_platform_info->maxchipselect;
+
+	/* Set the master controller driver data for this master */
+
+	master_drv_data = spi_master_get_devdata(master);
+	master_drv_data->mxc_bitbang.master = spi_master_get(master);
+
+	/* Set the master bitbang data */
+
+	master_drv_data->mxc_bitbang.chipselect = mxc_spi_chipselect;
+	master_drv_data->mxc_bitbang.txrx_bufs = mxc_spi_transfer;
+	master_drv_data->mxc_bitbang.master->setup = mxc_spi_setup;
+	master_drv_data->mxc_bitbang.master->cleanup = mxc_spi_cleanup;
+
+	/* Initialize the completion object */
+
+	init_completion(&master_drv_data->xfer_done);
+
+	/* Set the master controller register addresses and irqs */
+
+	master_drv_data->res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!master_drv_data->res) {
+		dev_err(&pdev->dev, "can't get platform resource for CSPI%d\n",
+			master->bus_num);
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	if (!request_mem_region(master_drv_data->res->start,
+				master_drv_data->res->end -
+				master_drv_data->res->start + 1, pdev->name)) {
+		dev_err(&pdev->dev, "request_mem_region failed for CSPI%d\n",
+			master->bus_num);
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	master_drv_data->base = (void *)IO_ADDRESS(master_drv_data->res->start);
+	if (!master_drv_data->base) {
+		dev_err(&pdev->dev, "invalid base address for CSPI%d\n",
+			master->bus_num);
+		ret = -EINVAL;
+		goto err1;
+	}
+
+	master_drv_data->irq = platform_get_irq(pdev, 0);
+	if (!master_drv_data->irq) {
+		dev_err(&pdev->dev, "can't get IRQ for CSPI%d\n",
+			master->bus_num);
+		ret = -EINVAL;
+		goto err1;
+	}
+
+	/* Register for SPI Interrupt */
+
+	ret = request_irq(master_drv_data->irq, mxc_spi_isr,
+			  0, "CSPI_IRQ", master_drv_data);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "request_irq failed for CSPI%d\n",
+			master->bus_num);
+		goto err1;
+	}
+
+	/* Setup any GPIO active */
+
+	gpio_spi_active(master->bus_num - 1);
+
+	/* Identify SPI version */
+
+	spi_ver = mxc_platform_info->spi_version;
+	if (spi_ver == 7) {
+		master_drv_data->spi_ver_def = &spi_ver_0_7;
+	} else if (spi_ver == 5) {
+		master_drv_data->spi_ver_def = &spi_ver_0_5;
+	} else if (spi_ver == 4) {
+		master_drv_data->spi_ver_def = &spi_ver_0_4;
+	} else if (spi_ver == 0) {
+		master_drv_data->spi_ver_def = &spi_ver_0_0;
+	}
+
+	dev_dbg(&pdev->dev, "CLOCK %d SPI_REV 0.%d\n",
+		master_drv_data->clock_id, spi_ver);
+
+	/* Enable the CSPI Clock, CSPI Module, set as a master */
+
+	master_drv_data->clk = clk_get(&pdev->dev, "cspi_clk");
+	clk_enable(master_drv_data->clk);
+	master_drv_data->spi_ipg_clk = clk_get_rate(master_drv_data->clk);
+
+	__raw_writel(MXC_CSPICTRL_ENABLE | MXC_CSPICTRL_MASTER,
+		     master_drv_data->base + MXC_CSPICTRL);
+	__raw_writel(MXC_CSPIPERIOD_32KHZ,
+		     master_drv_data->base + MXC_CSPIPERIOD);
+	__raw_writel(0, master_drv_data->base + MXC_CSPIINT);
+
+	/* Start the SPI Master Controller driver */
+
+	ret = spi_bitbang_start(&master_drv_data->mxc_bitbang);
+	if (ret != 0)
+		goto err2;
+
+	printk(KERN_INFO "CSPI: %s-%d probed\n", pdev->name, pdev->id);
+
+#ifdef CONFIG_SPI_MXC_TEST_LOOPBACK
+	{
+		int i;
+		struct spi_board_info *bi = &loopback_info[0];
+		for (i = 0; i < ARRAY_SIZE(loopback_info); i++, bi++) {
+			if (bi->bus_num != master->bus_num)
+				continue;
+
+			dev_info(&pdev->dev,
+				 "registering loopback device '%s'\n",
+				 bi->modalias);
+
+			spi_new_device(master, bi);
+		}
+	}
+#endif
+	return ret;
+
+      err2:
+	gpio_spi_inactive(master->bus_num - 1);
+	clk_disable(master_drv_data->clk);
+	clk_put(master_drv_data->clk);
+	free_irq(master_drv_data->irq, master_drv_data);
+      err1:
+	release_mem_region(pdev->resource[0].start,
+			   pdev->resource[0].end - pdev->resource[0].start + 1);
+      err:
+	spi_master_put(master);
+	kfree(master);
+	platform_set_drvdata(pdev, NULL);
+	return ret;
+}
+
+/*!
+ * Dissociates the driver from the SPI master controller. Disables the CSPI module.
+ * It handles the release of SPI resources like IRQ, memory,..etc.
+ *
+ * @param   pdev  the device structure used to give information on which SPI
+ *                to remove
+ *
+ * @return  The function always returns 0.
+ */
+static int mxc_spi_remove(struct platform_device *pdev)
+{
+	struct spi_master *master = platform_get_drvdata(pdev);
+
+	if (master) {
+		struct mxc_spi *master_drv_data =
+		    spi_master_get_devdata(master);
+
+		gpio_spi_inactive(master->bus_num - 1);
+		clk_disable(master_drv_data->clk);
+
+		/* Disable the CSPI module */
+
+		__raw_writel(MXC_CSPICTRL_DISABLE,
+			     master_drv_data->base + MXC_CSPICTRL);
+
+		/* Unregister for SPI Interrupt */
+
+		free_irq(master_drv_data->irq, master_drv_data);
+
+		release_mem_region(master_drv_data->res->start,
+				   master_drv_data->res->end -
+				   master_drv_data->res->start + 1);
+
+		/* Stop the SPI Master Controller driver */
+
+		spi_bitbang_stop(&master_drv_data->mxc_bitbang);
+
+		spi_master_put(master);
+	}
+
+	printk(KERN_INFO "CSPI: %s-%d removed\n", pdev->name, pdev->id);
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int suspend_devices(struct device *dev, void *pm_message)
+{
+	pm_message_t *state = pm_message;
+
+	if (dev->power.power_state.event != state->event) {
+		dev_warn(dev, "mismatch in pm state request\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static int spi_bitbang_suspend(struct spi_bitbang *bitbang)
+{
+	unsigned long flags;
+	unsigned limit = 500;
+
+	spin_lock_irqsave(&bitbang->lock, flags);
+	bitbang->shutdown = 0;
+	while (!list_empty(&bitbang->queue) && limit--) {
+		spin_unlock_irqrestore(&bitbang->lock, flags);
+
+		dev_dbg(bitbang->master->cdev.dev, "wait for queue\n");
+		msleep(10);
+
+		spin_lock_irqsave(&bitbang->lock, flags);
+	}
+	if (!list_empty(&bitbang->queue)) {
+		dev_err(bitbang->master->cdev.dev, "queue didn't empty\n");
+		return -EBUSY;
+	}
+	spin_unlock_irqrestore(&bitbang->lock, flags);
+
+	bitbang->shutdown = 1;
+
+	return 0;
+}
+
+static void spi_bitbang_resume(struct spi_bitbang *bitbang)
+{
+	spin_lock_init(&bitbang->lock);
+	INIT_LIST_HEAD(&bitbang->queue);
+
+	bitbang->busy = 0;
+	bitbang->shutdown = 0;
+}
+
+/*!
+ * This function puts the SPI master controller in low-power mode/state.
+ *
+ * @param   pdev  the device structure used to give information on which SDHC
+ *                to suspend
+ * @param   state the power state the device is entering
+ *
+ * @return  The function always returns 0.
+ */
+static int mxc_spi_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct spi_master *master = platform_get_drvdata(pdev);
+	struct mxc_spi *master_drv_data = spi_master_get_devdata(master);
+	int ret = 0;
+
+	if (device_for_each_child(&pdev->dev, &state, suspend_devices) != 0) {
+		dev_warn(&pdev->dev, "suspend aborted\n");
+		return -EINVAL;
+	}
+
+	spi_bitbang_suspend(&master_drv_data->mxc_bitbang);
+	__raw_writel(MXC_CSPICTRL_DISABLE,
+		     master_drv_data->base + MXC_CSPICTRL);
+
+	clk_disable(master_drv_data->clk);
+	gpio_spi_inactive(master->bus_num - 1);
+
+	return ret;
+}
+
+/*!
+ * This function brings the SPI master controller back from low-power state.
+ *
+ * @param   pdev  the device structure used to give information on which SDHC
+ *                to resume
+ *
+ * @return  The function always returns 0.
+ */
+static int mxc_spi_resume(struct platform_device *pdev)
+{
+	struct spi_master *master = platform_get_drvdata(pdev);
+	struct mxc_spi *master_drv_data = spi_master_get_devdata(master);
+
+	gpio_spi_active(master->bus_num - 1);
+	clk_enable(master_drv_data->clk);
+
+	spi_bitbang_resume(&master_drv_data->mxc_bitbang);
+	__raw_writel(MXC_CSPICTRL_ENABLE | MXC_CSPICTRL_MASTER,
+		     master_drv_data->base + MXC_CSPICTRL);
+
+	return 0;
+}
+#else
+#define mxc_spi_suspend  NULL
+#define mxc_spi_resume   NULL
+#endif				/* CONFIG_PM */
+
+/*!
+ * This structure contains pointers to the power management callback functions.
+ */
+static struct platform_driver mxc_spi_driver = {
+	.driver = {
+		   .name = "mxc_spi",
+		   .bus = &platform_bus_type,
+		   .owner = THIS_MODULE,
+		   },
+	.probe = mxc_spi_probe,
+	.remove = mxc_spi_remove,
+	.suspend = mxc_spi_suspend,
+	.resume = mxc_spi_resume,
+};
+
+/*!
+ * This function implements the init function of the SPI device.
+ * It is called when the module is loaded. It enables the required
+ * clocks to CSPI module(if any) and activates necessary GPIO pins.
+ *
+ * @return       This function returns 0.
+ */
+static int __init mxc_spi_init(void)
+{
+	pr_debug("Registering the SPI Controller Driver\n");
+	return platform_driver_register(&mxc_spi_driver);
+}
+
+/*!
+ * This function implements the exit function of the SPI device.
+ * It is called when the module is unloaded. It deactivates the
+ * the GPIO pin associated with CSPI hardware modules.
+ *
+ */
+static void __exit mxc_spi_exit(void)
+{
+	pr_debug("Unregistering the SPI Controller Driver\n");
+	platform_driver_unregister(&mxc_spi_driver);
+}
+
+subsys_initcall(mxc_spi_init);
+module_exit(mxc_spi_exit);
+
+MODULE_DESCRIPTION("SPI Master Controller driver");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
Index: linux-2.6.18/drivers/spi/mxc_spi_mx27.h
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/spi/mxc_spi_mx27.h
@@ -0,0 +1,153 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mxc_spi_mx27.h
+ * @brief This header file contains SPI driver low level register definitions for MX27.
+ *
+ * @ingroup SPI
+ */
+
+#ifndef __MXC_SPI_MX27_H__
+#define __MXC_SPI_MX27_H__
+
+#include <asm/hardware.h>
+#include <asm/mach-types.h>
+
+#define MXC_CSPIRXDATA		0x00
+#define MXC_CSPITXDATA		0x04
+#define MXC_CSPICTRL		0x08
+#define MXC_CSPIINT		0x0C
+#define MXC_CSPIDMA		0x18
+#define MXC_CSPISTAT		0x0C
+#define MXC_CSPIPERIOD		0x14
+#define MXC_CSPITEST		0x10
+#define MXC_CSPIRESET		0x1C
+
+#define MXC_CSPICTRL_ENABLE	(1 << 10)
+#define MXC_CSPICTRL_DISABLE	0x0
+#define MXC_CSPICTRL_MASTER	(1 << 11)
+#define MXC_CSPICTRL_SLAVE	0x0
+#define MXC_CSPICTRL_XCH	(1 << 9)
+#define MXC_CSPICTRL_LOWPOL	(1 << 5)
+#define MXC_CSPICTRL_HIGHPOL	0x0
+#define MXC_CSPICTRL_PHA	(1 << 6)
+#define MXC_CSPICTRL_NOPHA	0x0
+#define MXC_CSPICTRL_SSCTL	(1 << 7)
+#define MXC_CSPICTRL_HIGHSSPOL 	(1 << 8)
+#define MXC_CSPICTRL_LOWSSPOL	0x0
+#define MXC_CSPICTRL_CSMASK	0x3
+#define MXC_CSPICTRL_MAXDATRATE	0x10
+#define MXC_CSPICTRL_DATAMASK	0x1F
+#define MXC_CSPICTRL_DATASHIFT 	14
+/* This adjustment in the shift is valid only for even states only(i.e. divide
+   ratio of 2). SDHC_SPIEN is not set by default. If SDHC_SPIEN bit is set in
+   MXC_CSPICTRL, then divide ratio is 3, this shift adjustment is invalid. */
+#define MXC_CSPICTRL_ADJUST_SHIFT(x) ((x) = ((x) - 1) * 2)
+
+#define MXC_CSPICTRL_CSSHIFT_0_7	12
+#define MXC_CSPICTRL_BCSHIFT_0_7	20
+#define MXC_CSPICTRL_BCMASK_0_7		0xFFF
+#define MXC_CSPICTRL_DRCTRLSHIFT_0_7	8
+
+#define MXC_CSPICTRL_CSSHIFT_0_5	12
+#define MXC_CSPICTRL_BCSHIFT_0_5	20
+#define MXC_CSPICTRL_BCMASK_0_5		0xFFF
+#define MXC_CSPICTRL_DRCTRLSHIFT_0_5	8
+
+#define MXC_CSPICTRL_CSSHIFT_0_4	24
+#define MXC_CSPICTRL_BCSHIFT_0_4	8
+#define MXC_CSPICTRL_BCMASK_0_4		0x1F
+#define MXC_CSPICTRL_DRCTRLSHIFT_0_4	20
+
+#define MXC_CSPICTRL_CSSHIFT_0_0	19
+#define MXC_CSPICTRL_BCSHIFT_0_0	0
+#define MXC_CSPICTRL_BCMASK_0_0		0x1F
+#define MXC_CSPICTRL_DRCTRLSHIFT_0_0	12
+
+#define MXC_CSPIINT_IRQSHIFT_0_7	8
+#define MXC_CSPIINT_IRQSHIFT_0_5	9
+#define MXC_CSPIINT_IRQSHIFT_0_4	9
+#define MXC_CSPIINT_IRQSHIFT_0_0	18
+#define MXC_CSPIINT_TEEN	(1 << 9)
+#define MXC_CSPIINT_THEN	(1 << 10)
+#define MXC_CSPIINT_TFEN	(1 << 11)
+#define MXC_CSPIINT_RREN	(1 << 13)
+#define MXC_CSPIINT_RHEN        (1 << 14)
+#define MXC_CSPIINT_RFEN        (1 << 15)
+#define MXC_CSPIINT_ROEN        (1 << 16)
+#define MXC_CSPIINT_TCEN_0_7	(1 << 7)
+#define MXC_CSPIINT_TCEN_0_5	(1 << 8)
+#define MXC_CSPIINT_TCEN_0_4	(1 << 8)
+#define MXC_CSPIINT_TCEN_0_0	(1 << 12)
+#define MXC_CSPIINT_BOEN_0_7	0
+#define MXC_CSPIINT_BOEN_0_5	(1 << 7)
+#define MXC_CSPIINT_BOEN_0_4	(1 << 7)
+#define MXC_CSPIINT_BOEN_0_0	(1 << 17)
+
+#define MXC_CSPISTAT_TE		(1 << 0)
+#define MXC_CSPISTAT_TH		(1 << 1)
+#define MXC_CSPISTAT_TF		(1 << 2)
+#define MXC_CSPISTAT_RR		(1 << 3)
+#define MXC_CSPISTAT_RH         (1 << 4)
+#define MXC_CSPISTAT_RF         (1 << 5)
+#define MXC_CSPISTAT_RO         (1 << 6)
+#define MXC_CSPISTAT_TC_0_7	(1 << 7)
+#define MXC_CSPISTAT_TC_0_5	(1 << 8)
+#define MXC_CSPISTAT_TC_0_4	(1 << 8)
+#define MXC_CSPISTAT_TC_0_0	(1 << 3)
+#define MXC_CSPISTAT_BO_0_7	0
+#define MXC_CSPISTAT_BO_0_5	(1 << 7)
+#define MXC_CSPISTAT_BO_0_4	(1 << 7)
+#define MXC_CSPISTAT_BO_0_0	(1 << 8)
+
+#define MXC_CSPIPERIOD_32KHZ	(1 << 15)
+
+#define MXC_CSPITEST_LBC	(1 << 14)
+
+/*!
+ * @struct mxc_spi_unique_def
+ * @brief This structure contains information that differs with
+ * SPI master controller hardware version
+ */
+struct mxc_spi_unique_def {
+	/*!
+	 * Width of valid bits in MXC_CSPIINT.
+	 */
+	unsigned int intr_bit_shift;
+	/*!
+	 * Chip Select shift.
+	 */
+	unsigned int cs_shift;
+	/*!
+	 * Bit count shift.
+	 */
+	unsigned int bc_shift;
+	/*!
+	 * Bit count mask.
+	 */
+	unsigned int bc_mask;
+	/*!
+	 * Data Control shift.
+	 */
+	unsigned int drctrl_shift;
+	/*!
+	 * Transfer Complete shift.
+	 */
+	unsigned int xfer_complete;
+	/*!
+	 * Bit counnter overflow shift.
+	 */
+	unsigned int bc_overflow;
+};
+#endif				//__MXC_SPI_MX27_H__
Index: linux-2.6.18/include/asm-arm/arch-mxc/mxc.h
===================================================================
--- linux-2.6.18.orig/include/asm-arm/arch-mxc/mxc.h
+++ linux-2.6.18/include/asm-arm/arch-mxc/mxc.h
@@ -18,6 +18,26 @@
 #ifndef __ASSEMBLY__
 #include <linux/types.h>
 
+/*
+ * This structure is used to define the SPI master controller's platform
+ * data. It includes the SPI  bus number and the maximum number of
+ * slaves/chips it supports.
+ */
+struct mxc_spi_master {
+        /*
+         * SPI Master's bus number.
+         */
+        unsigned int bus_num;
+        /*
+         * SPI Master's maximum number of chip selects.
+         */
+        unsigned int maxchipselect;
+        /*
+         * CSPI Hardware Version.
+         */
+        unsigned int spi_version;
+};
+
 #define IOMUX_TO_GPIO(pin) \
 	((((unsigned int)pin >> MUX_IO_P) * GPIO_NUM_PIN) + \
 	 ((pin >> MUX_IO_I) & ((1 << (MUX_IO_P - MUX_IO_I)) -1)))
Index: linux-2.6.18/arch/arm/mach-mx2/mx27ads.c
===================================================================
--- linux-2.6.18.orig/arch/arm/mach-mx2/mx27ads.c
+++ linux-2.6.18/arch/arm/mach-mx2/mx27ads.c
@@ -20,6 +20,7 @@
 #include <linux/interrupt.h>
 #include <linux/irq.h>
 
+#include <linux/spi/spi.h>
 #include <asm/hardware.h>
 #include <asm/mach-types.h>
 #include <asm/mach/arch.h>
@@ -64,6 +65,16 @@ static inline void mxc_init_fb(void)
 }
 #endif
 
+static struct spi_board_info mxc_spi_board_info[] __initdata = {
+        {
+         .modalias = "pmic_spi",
+         .irq = IOMUX_TO_IRQ(MX27_PIN_TOUT),
+         .max_speed_hz = 4000000,
+         .bus_num = 1,
+         .chip_select = 0,
+         },
+};
+
 static const int pbc_card_bit[4][3] = {
 	/* BSTAT            IMR enable       IMR removal */
 	{PBC_BSTAT_SD2_DET, PBC_INTR_SD2_EN, PBC_INTR_SD2_R_EN},
@@ -366,6 +377,10 @@ static void __init mx27ads_board_init(vo
 	mxc_gpio_init();
 	mxc_expio_init();
 	mxc_init_extuart();
+
+        spi_register_board_info(mxc_spi_board_info,
+                                ARRAY_SIZE(mxc_spi_board_info));
+
 	mxc_init_fb();
 }
 
Index: linux-2.6.18/mvl_patches/pro50-0114.c
===================================================================
--- /dev/null
+++ linux-2.6.18/mvl_patches/pro50-0114.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(114);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

