#! /usr/bin/env bash
# Patch: -common_arm_freescale_mxc_dma
# Date: Wed Aug 29 07:24:00 2007

PATCHNUM=107
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Index: linux-2.6.18/arch/arm/mach-mx2/Makefile
===================================================================
--- linux-2.6.18.orig/arch/arm/mach-mx2/Makefile
+++ linux-2.6.18/arch/arm/mach-mx2/Makefile
@@ -4,5 +4,5 @@
 
 # Object file lists.
 
-obj-y		:= mm.o time.o clock.o cpu.o
+obj-y		:= mm.o time.o clock.o cpu.o dma.o
 obj-$(CONFIG_MACH_MX27ADS)	+= mx27ads.o
Index: linux-2.6.18/arch/arm/mach-mx2/dma.c
===================================================================
--- /dev/null
+++ linux-2.6.18/arch/arm/mach-mx2/dma.c
@@ -0,0 +1,711 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file iarch/arm/mach-mx2/dma.c
+ * @brief This file contains the dma parameter which is depend on the platform.
+ * @ingroup System
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <asm/dma.h>
+
+#define MXC_SOUND_PLAYBACK_CHAIN_DMA 1
+#define MXC_SOUND_CAPTURE_CHAIN_DMA 1
+
+/*!
+ * @brief  the structure stored device_id and dma_info pointer
+ */
+typedef struct dma_info_entry_s {
+	mxc_dma_device_t device;
+	/* if there are two dma_info , first is for reading,
+	 * and second is for writing */
+	mx2_dma_info_t *info;
+} dma_info_entry_t;
+
+/*!
+ * @brief dma_info from memory to memory for dma testing
+ */
+static mx2_dma_info_t ram2ram_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,
+	.ren = 0,
+	.burstLength = 4,
+	.request = 0,
+	.busuntils = 0,
+	.sourceType = DMA_TYPE_LINEAR,
+	.sourcePort = TRANSFER_32BIT,
+	.destType = DMA_TYPE_LINEAR,
+	.destPort = TRANSFER_32BIT,
+	.M2D_Valid = 0
+};
+
+/*!
+ * @brief dma_info from 2D memory to 2D memory for dma testing
+ */
+static mx2_dma_info_t ram2d2ram2d_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.rto_en = 0,
+	.dma_chaining = 0,
+	.ren = 0,
+	.burstLength = 4,
+	.request = 0,
+	.busuntils = 0,
+	.sourceType = DMA_TYPE_2D,
+	.sourcePort = TRANSFER_32BIT,
+	.destType = DMA_TYPE_2D,
+	.destPort = TRANSFER_32BIT,
+	.M2D_Valid = 1,
+	.msel = 0,
+	.W = 0x80,
+	.X = 0x40,
+	.Y = 0x10
+};
+
+/*!
+ * @brief dma_info from memory to 2D memory for dma testing
+ */
+static mx2_dma_info_t ram2ram2d_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,
+	.ren = 0,
+	.burstLength = 4,
+	.request = 0,
+	.busuntils = 0,
+	.sourceType = DMA_TYPE_LINEAR,
+	.sourcePort = TRANSFER_32BIT,
+	.destType = DMA_TYPE_2D,
+	.destPort = TRANSFER_32BIT,
+	.M2D_Valid = 1,
+	.msel = 0,
+	.W = 0x100,
+	.X = 0x80,
+	.Y = 0x10
+};
+
+/*!
+ * @brief dma_info from 2D memory to memory for dma testing
+ */
+static mx2_dma_info_t ram2d2ram_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,
+	.ren = 0,
+	.burstLength = 4,
+	.request = 0,
+	.busuntils = 0,
+	.sourceType = DMA_TYPE_2D,
+	.sourcePort = TRANSFER_32BIT,
+	.destType = DMA_TYPE_LINEAR,
+	.destPort = TRANSFER_32BIT,
+	.M2D_Valid = 1,
+	.msel = 0,
+	.W = 0x100,
+	.X = 0x100,
+	.Y = 0x10
+};
+
+/*!
+ * @brief dma_info with dma chaining feature for dma testing
+ */
+static mx2_dma_info_t hw_chaining_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 1,
+	.ren = 0,
+	.burstLength = 4,
+	.request = 0,
+	.busuntils = 0,
+	.sourceType = DMA_TYPE_LINEAR,
+	.sourcePort = TRANSFER_32BIT,
+	.destType = DMA_TYPE_LINEAR,
+	.destPort = TRANSFER_32BIT,
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief dma_info without dma chaining feature for dma testing
+ */
+static mx2_dma_info_t sw_chaining_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,
+	.ren = 0,
+	.burstLength = 4,
+	.request = 0,
+	.busuntils = 0,
+	.sourceType = DMA_TYPE_LINEAR,
+	.sourcePort = TRANSFER_32BIT,
+	.destType = DMA_TYPE_LINEAR,
+	.destPort = TRANSFER_32BIT,
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief dma_info for ATA recieveing
+ */
+static mx2_dma_info_t ata_rx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,
+	.ren = 1,
+	.burstLength = 32,
+	.request = 29,
+	.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,
+	.sourcePort = TRANSFER_32BIT,
+	.destType = DMA_TYPE_LINEAR,
+	.destPort = TRANSFER_32BIT,
+	.per_address = (ATA_BASE_ADDR + 0x18),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief: dma_info for ATA transmitting
+ */
+static mx2_dma_info_t ata_tx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 1,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,
+	.ren = 1,
+	.burstLength = 32,
+	.request = 28,
+	.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,
+	.sourcePort = TRANSFER_32BIT,
+	.destType = DMA_TYPE_LINEAR,
+	.destPort = TRANSFER_32BIT,
+	.per_address = (ATA_BASE_ADDR + 0x18),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief dma_info for UART1 recieveing
+ */
+static mx2_dma_info_t uart1_rx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 1,
+	.dir = 0,
+	.dma_chaining = 0,
+	.ren = 1,
+	.burstLength = 1,
+	.request = 26,
+	.busuntils = 8,
+	.sourceType = DMA_TYPE_FIFO,
+	.sourcePort = TRANSFER_8BIT,
+	.destType = DMA_TYPE_LINEAR,
+	.destPort = TRANSFER_8BIT,
+	.per_address = (UART1_BASE_ADDR),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief: dma_info for UART1 transmitting
+ */
+static mx2_dma_info_t uart1_tx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 1,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,
+	.ren = 1,
+	.burstLength = 1,
+	.request = 27,
+	.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,
+	.sourcePort = TRANSFER_8BIT,
+	.destType = DMA_TYPE_LINEAR,
+	.destPort = TRANSFER_8BIT,
+	.per_address = (UART1_BASE_ADDR + 0x40),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief dma_info for UART2 recieveing
+ */
+static mx2_dma_info_t uart2_rx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,
+	.ren = 1,
+	.burstLength = 1,
+	.request = 24,
+	.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,
+	.sourcePort = TRANSFER_8BIT,
+	.destType = DMA_TYPE_LINEAR,
+	.destPort = TRANSFER_8BIT,
+	.per_address = (UART2_BASE_ADDR),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief: dma_info for UART2 transmitting
+ */
+static mx2_dma_info_t uart2_tx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 1,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,
+	.ren = 1,
+	.burstLength = 1,
+	.request = 25,
+	.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,
+	.sourcePort = TRANSFER_8BIT,
+	.destType = DMA_TYPE_LINEAR,
+	.destPort = TRANSFER_8BIT,
+	.per_address = (UART2_BASE_ADDR + 0x40),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief dma_info for UART3 recieveing
+ */
+static mx2_dma_info_t uart3_rx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,
+	.ren = 1,
+	.burstLength = 1,
+	.request = 22,
+	.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,
+	.sourcePort = TRANSFER_8BIT,
+	.destType = DMA_TYPE_LINEAR,
+	.destPort = TRANSFER_8BIT,
+	.per_address = (UART3_BASE_ADDR),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief: dma_info for UART3 transmitting
+ */
+static mx2_dma_info_t uart3_tx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 1,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,
+	.ren = 1,
+	.burstLength = 1,
+	.request = 23,
+	.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,
+	.sourcePort = TRANSFER_8BIT,
+	.destType = DMA_TYPE_LINEAR,
+	.destPort = TRANSFER_8BIT,
+	.per_address = (UART3_BASE_ADDR + 0x40),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief dma_info for UART4 recieveing
+ */
+static mx2_dma_info_t uart4_rx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,
+	.ren = 1,
+	.burstLength = 1,
+	.request = 20,
+	.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,
+	.sourcePort = TRANSFER_8BIT,
+	.destType = DMA_TYPE_LINEAR,
+	.destPort = TRANSFER_8BIT,
+	.per_address = (UART4_BASE_ADDR),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief: dma_info for UART4transmitting
+ */
+static mx2_dma_info_t uart4_tx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 1,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,
+	.ren = 1,
+	.burstLength = 1,
+	.request = 21,
+	.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,
+	.sourcePort = TRANSFER_8BIT,
+	.destType = DMA_TYPE_LINEAR,
+	.destPort = TRANSFER_8BIT,
+	.per_address = (UART4_BASE_ADDR + 0x40),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief dma_info for UART5 recieveing
+ */
+static mx2_dma_info_t uart5_rx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,
+	.ren = 1,
+	.burstLength = 1,
+	.request = 32,
+	.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,
+	.sourcePort = TRANSFER_8BIT,
+	.destType = DMA_TYPE_LINEAR,
+	.destPort = TRANSFER_8BIT,
+	.per_address = (UART5_BASE_ADDR),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief: dma_info for UART5 transmitting
+ */
+static mx2_dma_info_t uart5_tx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 1,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,
+	.ren = 1,
+	.burstLength = 1,
+	.request = 33,
+	.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,
+	.sourcePort = TRANSFER_8BIT,
+	.destType = DMA_TYPE_LINEAR,
+	.destPort = TRANSFER_8BIT,
+	.per_address = (UART5_BASE_ADDR + 0x40),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief dma_info for UART6 recieveing
+ */
+static mx2_dma_info_t uart6_rx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,
+	.ren = 1,
+	.burstLength = 1,
+	.request = 34,
+	.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,
+	.sourcePort = TRANSFER_8BIT,
+	.destType = DMA_TYPE_LINEAR,
+	.destPort = TRANSFER_8BIT,
+	.per_address = (UART6_BASE_ADDR),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief: dma_info for UART6 transmitting
+ */
+static mx2_dma_info_t uart6_tx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 1,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,
+	.ren = 1,
+	.burstLength = 1,
+	.request = 35,
+	.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,
+	.sourcePort = TRANSFER_8BIT,
+	.destType = DMA_TYPE_LINEAR,
+	.destPort = TRANSFER_8BIT,
+	.per_address = (UART6_BASE_ADDR + 0x40),
+	.M2D_Valid = 0,
+};
+
+static mx2_dma_info_t ssi1_16bit_rx0_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = MXC_SOUND_CAPTURE_CHAIN_DMA,
+	.ren = 1,
+	.burstLength = 8,
+	.request = DMA_REQ_SSI1_RX0,
+	.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,
+	.sourcePort = DMA_MEM_SIZE_16,
+	.destType = DMA_TYPE_LINEAR,
+	.destPort = DMA_MEM_SIZE_32,
+	.per_address = (SSI1_BASE_ADDR + 0x08),
+	.M2D_Valid = 0,
+};
+
+static mx2_dma_info_t ssi1_16bit_tx0_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 1,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = MXC_SOUND_PLAYBACK_CHAIN_DMA,
+	.ren = 1,
+	.burstLength = 8,
+	.request = DMA_REQ_SSI1_TX0,
+	.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,
+	.sourcePort = DMA_MEM_SIZE_16,
+	.destType = DMA_TYPE_LINEAR,
+	.destPort = DMA_MEM_SIZE_32,
+	.per_address = (SSI1_BASE_ADDR),
+	.M2D_Valid = 0,
+};
+
+static mx2_dma_info_t ssi2_16bit_rx0_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = MXC_SOUND_CAPTURE_CHAIN_DMA,
+	.ren = 1,
+	.burstLength = 8,
+	.request = DMA_REQ_SSI2_RX0,
+	.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,
+	.sourcePort = DMA_MEM_SIZE_16,
+	.destType = DMA_TYPE_LINEAR,
+	.destPort = DMA_MEM_SIZE_32,
+	.per_address = (SSI2_BASE_ADDR + 0x08),
+	.M2D_Valid = 0,
+};
+
+static mx2_dma_info_t ssi2_16bit_tx0_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 1,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = MXC_SOUND_PLAYBACK_CHAIN_DMA,
+	.ren = 1,
+	.burstLength = 8,
+	.request = DMA_REQ_SSI2_TX0,
+	.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,
+	.sourcePort = DMA_MEM_SIZE_16,
+	.destType = DMA_TYPE_LINEAR,
+	.destPort = DMA_MEM_SIZE_32,
+	.per_address = (SSI2_BASE_ADDR),
+	.M2D_Valid = 0,
+};
+
+static mx2_dma_info_t mmc1_width1_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,
+	.ren = 1,
+	.burstLength = 16,
+	.request = DMA_REQ_SDHC1,
+	.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,
+	.sourcePort = DMA_MEM_SIZE_32,
+	.destType = DMA_TYPE_LINEAR,
+	.destPort = DMA_MEM_SIZE_32,
+	.per_address = (SDHC1_BASE_ADDR + 0x38),
+	.M2D_Valid = 0,
+};
+
+static mx2_dma_info_t mmc1_width4_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,
+	.ren = 1,
+	.burstLength = 0,
+	.request = DMA_REQ_SDHC1,
+	.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,
+	.sourcePort = DMA_MEM_SIZE_32,
+	.destType = DMA_TYPE_LINEAR,
+	.destPort = DMA_MEM_SIZE_32,
+	.per_address = (SDHC1_BASE_ADDR + 0x38),
+	.M2D_Valid = 0,
+};
+
+static mx2_dma_info_t mmc2_width1_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,
+	.ren = 1,
+	.burstLength = 16,
+	.request = DMA_REQ_SDHC2,
+	.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,
+	.sourcePort = DMA_MEM_SIZE_32,
+	.destType = DMA_TYPE_LINEAR,
+	.destPort = DMA_MEM_SIZE_32,
+	.per_address = (SDHC2_BASE_ADDR + 0x38),
+	.M2D_Valid = 0,
+};
+
+static mx2_dma_info_t mmc2_width4_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,
+	.ren = 1,
+	.burstLength = 0,
+	.request = DMA_REQ_SDHC2,
+	.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,
+	.sourcePort = DMA_MEM_SIZE_32,
+	.destType = DMA_TYPE_LINEAR,
+	.destPort = DMA_MEM_SIZE_32,
+	.per_address = (SDHC2_BASE_ADDR + 0x38),
+	.M2D_Valid = 0,
+};
+
+static mx2_dma_info_t csi_rx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 1,
+	.ren = 1,
+	.burstLength = 64,
+	.request = DMA_REQ_CSI_RX,
+	.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,
+	.sourcePort = DMA_MEM_SIZE_32,
+	.destType = DMA_TYPE_LINEAR,
+	.destPort = DMA_MEM_SIZE_32,
+	.per_address = (CSI_BASE_ADDR + 0x10),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief dma info array which is actived
+ *    DEVICE_ID  RX/(RX&TX)	TX
+ */
+static dma_info_entry_t active_dma_info[] = {
+	{MXC_DMA_TEST_RAM2RAM, &ram2ram_dma_info},
+	{MXC_DMA_TEST_RAM2D2RAM2D, &ram2d2ram2d_dma_info},
+	{MXC_DMA_TEST_RAM2RAM2D, &ram2ram2d_dma_info},
+	{MXC_DMA_TEST_RAM2D2RAM, &ram2d2ram_dma_info},
+	{MXC_DMA_TEST_HW_CHAINING, &hw_chaining_dma_info},
+	{MXC_DMA_TEST_SW_CHAINING, &sw_chaining_dma_info},
+	{MXC_DMA_ATA_RX, &ata_rx_dma_info},
+	{MXC_DMA_ATA_TX, &ata_tx_dma_info},
+	{MXC_DMA_UART1_RX, &uart1_rx_dma_info},
+	{MXC_DMA_UART1_TX, &uart1_tx_dma_info},
+	{MXC_DMA_UART2_RX, &uart2_rx_dma_info},
+	{MXC_DMA_UART2_TX, &uart2_tx_dma_info},
+	{MXC_DMA_UART3_RX, &uart3_rx_dma_info},
+	{MXC_DMA_UART3_TX, &uart3_tx_dma_info},
+	{MXC_DMA_UART4_RX, &uart4_rx_dma_info},
+	{MXC_DMA_UART4_TX, &uart4_tx_dma_info},
+	{MXC_DMA_UART5_RX, &uart5_rx_dma_info},
+	{MXC_DMA_UART5_TX, &uart5_tx_dma_info},
+	{MXC_DMA_UART6_RX, &uart6_rx_dma_info},
+	{MXC_DMA_UART6_TX, &uart6_tx_dma_info},
+	{MXC_DMA_SSI1_16BIT_RX0, &ssi1_16bit_rx0_dma_info},
+	{MXC_DMA_SSI1_16BIT_TX0, &ssi1_16bit_tx0_dma_info},
+	{MXC_DMA_SSI2_16BIT_RX0, &ssi2_16bit_rx0_dma_info},
+	{MXC_DMA_SSI2_16BIT_TX0, &ssi2_16bit_tx0_dma_info},
+	{MXC_DMA_MMC1_WIDTH_1, &mmc1_width1_dma_info},
+	{MXC_DMA_MMC1_WIDTH_4, &mmc1_width4_dma_info},
+	{MXC_DMA_MMC2_WIDTH_1, &mmc2_width1_dma_info},
+	{MXC_DMA_MMC2_WIDTH_4, &mmc2_width4_dma_info},
+	{MXC_DMA_CSI_RX, &csi_rx_dma_info},
+};
+
+/*!
+ * @brief the number of actived dma info
+ */
+static int dma_info_entrys =
+    sizeof(active_dma_info) / sizeof(active_dma_info[0]);
+
+/*!
+ * @brief get the dma info by channel_id
+ */
+mx2_dma_info_t *mxc_dma_get_info(mxc_dma_device_t channel_id)
+{
+	dma_info_entry_t *p = active_dma_info;
+	int i;
+	for (i = 0; i < dma_info_entrys; i++, p++) {
+		if (p->device == channel_id)
+			return p->info;
+	}
+	return NULL;
+}
+EXPORT_SYMBOL(mxc_dma_get_info);
+
+/*!
+ * @brief: scan dma parameter list, collect information about which channels
+ *         are dynamic.
+ */
+void mxc_dma_load_info(mxc_dma_channel_t *dma)
+{
+	int i, idx;
+	dma_info_entry_t *p = active_dma_info;
+
+	BUG_ON(dma == NULL);
+	BUG_ON(p == NULL);
+
+	for (i = 0; i < MXC_DMA_CHANNELS; i++) {
+		dma[i].dynamic = 1;
+	}
+
+	for (i = 0; i < dma_info_entrys; i++, p++) {
+		BUG_ON((p->info == NULL));
+
+		idx = p->info->dma_chan;
+
+		BUG_ON(((idx >= MAX_DMA_CHANNELS)
+			&& (idx != MXC_DMA_DYNAMIC_CHANNEL)));
+		if ((idx < 0) || (idx == MXC_DMA_DYNAMIC_CHANNEL))
+			continue;
+		dma[idx].dynamic = 0;
+	}
+}
+EXPORT_SYMBOL(mxc_dma_load_info);
Index: linux-2.6.18/arch/arm/plat-mxc/Makefile
===================================================================
--- linux-2.6.18.orig/arch/arm/plat-mxc/Makefile
+++ linux-2.6.18/arch/arm/plat-mxc/Makefile
@@ -4,3 +4,4 @@
 
 # Common support
 obj-y := irq.o clock.o
+obj-$(CONFIG_ARCH_MX2) += dma_mx2.o
Index: linux-2.6.18/arch/arm/plat-mxc/dma_mx2.c
===================================================================
--- /dev/null
+++ linux-2.6.18/arch/arm/plat-mxc/dma_mx2.c
@@ -0,0 +1,1240 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*  Front-end to the DMA handling.  This handles the allocation/freeing
+ *  of DMA channels, and provides a unified interface to the machines
+ *  DMA facilities.
+ */
+
+/*!
+ * @file plat-mxc/dma_mx2.c
+ * @brief This file contains functions for DMA  API
+ *
+ * @ingroup DMA_MX27
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/mman.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+
+#include <linux/proc_fs.h>
+#include <asm/io.h>
+
+#include <asm/hardware.h>
+#include <asm/arch/dma.h>
+#include <asm/delay.h>
+
+#include <asm/atomic.h>
+
+/*!
+ * This variable is used to controll the clock of DMA.
+ * It counts the number of actived channels
+ */
+static atomic_t g_dma_actived = ATOMIC_INIT(0);
+
+/*!
+ * This variable point a proc file which contains the information
+ *	of DMA channels
+ */
+static struct proc_dir_entry *g_proc_dir;
+
+/*!
+ * The dma channels
+ */
+static mxc_dma_channel_t g_dma_channels[MAX_DMA_CHANNELS];
+static mx2_dma_priv_t g_dma_privates[MXC_DMA_CHANNELS];
+static mx2_dma_bd_t g_dma_bd_table[MXC_DMA_CHANNELS][MAX_BD_SIZE];
+
+static DEFINE_SPINLOCK(dma_list_lock);
+
+static struct clk *dma_clk;
+
+/*!@brief flush buffer descriptor ring*/
+#define flush_dma_bd(private) do { \
+	atomic_set(&(private->bd_used), 0); \
+	private->bd_rd = private->bd_wr; \
+} while (0)
+
+/*!@brief get next buffer discriptor */
+#define next_dma_bd(private) \
+	({ \
+		int bd_next = (private->bd_rd+1) % MAX_BD_SIZE; \
+		(bd_next == private->bd_wr) ? NULL : \
+					      private->bd_ring + bd_next; \
+	})
+
+static inline int consume_dma_bd(mxc_dma_channel_t *dma, int error);
+/*!
+ *@brief allocate a dma channel.
+ *
+ *@param idx   Requested channel NO.
+ *             @li MXC_INVLAID_CHANNEL     System allocates a free channel which is not statically allocated.
+ *             @li Others                  User requests a specific channel
+ *@return      @li MXC_INVLAID_CHANNEL Failure
+ *             @li Others              Success
+ */
+static inline int get_dma_channel(int idx)
+{
+	int i;
+	mxc_dma_channel_t *p;
+
+	if ((idx >= MAX_DMA_CHANNELS) && (idx != MXC_DMA_DYNAMIC_CHANNEL)) {
+		return -1;
+	}
+	if (idx != MXC_DMA_DYNAMIC_CHANNEL) {
+		p = g_dma_channels + idx;
+		BUG_ON(p->dynamic != 0);
+		if (xchg(&p->lock, 1) != 0) {
+			return -1;
+		}
+		return idx;
+	}
+
+	p = g_dma_channels;
+	for (i = 0; (i < MAX_DMA_CHANNELS); i++, p++) {
+		if (p->dynamic && (xchg(&p->lock, 1) == 0)) {
+			return i;
+		}
+	}
+	return -1;
+}
+
+/*!
+ *@brief release a dma channel.
+ *
+ *@param idx   channel number
+ *@return        none;
+ */
+static inline void put_dma_channel(int idx)
+{
+	mxc_dma_channel_t *p;
+
+	if ((idx < MAX_DMA_CHANNELS) && (idx >= 0)) {
+		p = g_dma_channels + idx;
+		(void)xchg(&p->lock, 0);
+	}
+}
+
+/*!
+ *@brief Get dma list for /proc/dma
+ */
+static int mxc_get_dma_list(char *buf)
+{
+	mxc_dma_channel_t *dma;
+	char *p = buf;
+	int i;
+
+	for (i = 0, dma = g_dma_channels; i < MAX_DMA_CHANNELS; i++, dma++) {
+		if (dma->lock) {
+			p += sprintf(p, "dma channel %2d: %s\n", i,
+				     dma->dev_name ? dma->dev_name : "unknown");
+		} else {
+			p += sprintf(p, "dma channel %2d: unused\n", i);
+		}
+	}
+
+	return p - buf;
+}
+
+/*!@brief save the mask of dma interrupts*/
+#define save_dma_interrupt(flags) \
+		flags = __raw_readl(IO_ADDRESS(DMA_BASE_ADDR) + DMA_DIMR)
+
+/*!@brief restore the mask of dma interrupts*/
+#define restore_dma_interrupt(flags) \
+		__raw_writel(flags, IO_ADDRESS(DMA_BASE_ADDR) + DMA_DIMR)
+
+/*!@brief disable interrupt of dma channel*/
+static inline void mask_dma_interrupt(int channel)
+{
+	unsigned long reg;
+	save_dma_interrupt(reg);
+	reg |= 1 << channel;	/*mask interrupt; */
+	restore_dma_interrupt(reg);
+}
+
+/*!@brief enable interrupt of dma channel */
+static inline void unmask_dma_interrupt(int channel)
+{
+	unsigned long reg;
+	save_dma_interrupt(reg);
+	reg &= ~(1 << channel);	/*unmask interrupt; */
+	restore_dma_interrupt(reg);
+}
+
+/*!@brief get interrupt event of dma channel */
+static inline unsigned long __get_dma_interrupt(int channel)
+{
+	unsigned long mode;
+	mode = 0;
+	if (__raw_readl(IO_ADDRESS(DMA_BASE_ADDR) + DMA_DISR) & (1 << channel))
+		mode |= DMA_DONE;
+
+	if (__raw_readl(IO_ADDRESS(DMA_BASE_ADDR) + DMA_DBTOSR) &
+	    (1 << channel))
+		mode |= DMA_BURST_TIMEOUT;
+	if (__raw_readl(IO_ADDRESS(DMA_BASE_ADDR) + DMA_DSESR) & (1 << channel))
+		mode |= DMA_TRANSFER_ERROR;
+
+	if (__raw_readl(IO_ADDRESS(DMA_BASE_ADDR) + DMA_DBOSR) & (1 << channel))
+		mode |= DMA_BUFFER_OVERFLOW;
+	if (__raw_readl(IO_ADDRESS(DMA_BASE_ADDR) + DMA_DRTOSR) &
+	    (1 << channel))
+		mode |= DMA_REQUEST_TIMEOUT;
+	return mode;
+}
+
+/*!
+ *@brief clean all event of dma interrupt and return the valid event.
+ */
+static inline unsigned long __clear_dma_interrupt(int channel)
+{
+	unsigned long mode;
+	mode = __get_dma_interrupt(channel);
+	__raw_writel(1 << channel, IO_ADDRESS(DMA_BASE_ADDR) + DMA_DISR);
+	__raw_writel(1 << channel, IO_ADDRESS(DMA_BASE_ADDR) + DMA_DBTOSR);
+	__raw_writel(1 << channel, IO_ADDRESS(DMA_BASE_ADDR) + DMA_DRTOSR);
+	__raw_writel(1 << channel, IO_ADDRESS(DMA_BASE_ADDR) + DMA_DSESR);
+	__raw_writel(1 << channel, IO_ADDRESS(DMA_BASE_ADDR) + DMA_DBOSR);
+
+	return mode;
+}
+
+/*!@brief This function enables dma clocks without lock */
+static inline void __enable_dma_clk(void)
+{
+	unsigned long reg;
+	clk_enable(dma_clk);
+	reg = __raw_readl(IO_ADDRESS(DMA_BASE_ADDR) + DMA_DCR);
+	reg |= 0x1;
+	__raw_writel(reg, IO_ADDRESS(DMA_BASE_ADDR) + DMA_DCR);
+}
+
+/*!@brief This function disables dma clocks without lock */
+static inline void __disable_dma_clk(void)
+{
+	unsigned long reg;
+	reg = __raw_readl(IO_ADDRESS(DMA_BASE_ADDR) + DMA_DCR);
+	reg &= ~0x1;
+	__raw_writel(reg, IO_ADDRESS(DMA_BASE_ADDR) + DMA_DCR);
+	clk_disable(dma_clk);
+}
+
+/*!@brief This function enables dma clocks with lock */
+static inline void enable_dma_clk(void)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&dma_list_lock, flags);
+	if (atomic_read(&g_dma_actived) == 0) {
+		__enable_dma_clk();
+	}
+	spin_unlock_irqrestore(&dma_list_lock, flags);
+	return;
+}
+
+/*!@brief This function disables dma clocks without locked */
+static inline void disable_dma_clk(void)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&dma_list_lock, flags);
+	if (atomic_read(&g_dma_actived) == 0) {
+		__disable_dma_clk();
+	}
+	spin_unlock_irqrestore(&dma_list_lock, flags);
+	return;
+}
+
+/*!@brief select a buffer to transfer and
+ * 	setup dma channel for current transfer
+ */
+static void setup_dmac(mxc_dma_channel_t *dma)
+{
+	mx2_dma_priv_t *priv = (mx2_dma_priv_t *) dma->private;
+	dma_regs_t *dma_base = (dma_regs_t *) (priv->dma_base);
+	mx2_dma_bd_t *p, *q;
+	unsigned long ctrl_val;
+
+	if (dma->active == 0) {
+		printk(KERN_ERR
+		       "received interrupt for dma channel %d "
+		       "that is not enabled\n", dma->channel);
+		return;
+	}
+	if (atomic_read(&(priv->bd_used)) <= 0) {
+		printk(KERN_ERR "dma channel %d is empty\n", dma->channel);
+		dma->active = 0;
+		atomic_dec(&g_dma_actived);
+		return;
+	}
+	/* BUSY: transfering
+	 * PEND: Wait for set to DMAC.
+	 * s1: no transfering:
+	 *      set first (one BUSY). If there are more than one tranfer,
+	 *      set second &repeat is enabled (two BUSY).
+	 *
+	 * s2: transfering & just on transfer
+	 *      one BUSY. set the tranesfer and set repeat bit(two BUSY)
+	 * s3: transfering & repeat has set
+	 *     has two BUSY.
+	 */
+	p = priv->bd_ring + priv->bd_rd;
+	q = next_dma_bd(priv);
+	if (!(p->state & DMA_BD_ST_BUSY)) {
+		/* NOTICE: This is first buffer or dma chain does not support
+		 *         chain-buffer. So CEN must clear & set again */
+		ctrl_val =
+		    __raw_readl(&(dma_base->Ctl)) &
+		    (~(DMA_CTL_ACRPT | DMA_CTL_RPT | DMA_CTL_CEN));
+		__raw_writel(ctrl_val, &(dma_base->Ctl));
+		if (p->mode != dma->mode) {
+			/* bi-dir channel do mode change */
+			dma->mode = p->mode;
+			if (dma->mode == MXC_DMA_MODE_READ) {
+				DMA_CTL_SET_SMOD(ctrl_val,
+						 priv->dma_info->sourceType);
+				DMA_CTL_SET_SSIZ(ctrl_val,
+						 priv->dma_info->sourcePort);
+				DMA_CTL_SET_DMOD(ctrl_val,
+						 priv->dma_info->destType);
+				DMA_CTL_SET_DSIZ(ctrl_val,
+						 priv->dma_info->destPort);
+			} else {
+				DMA_CTL_SET_SMOD(ctrl_val,
+						 priv->dma_info->destType);
+				DMA_CTL_SET_SSIZ(ctrl_val,
+						 priv->dma_info->destPort);
+				DMA_CTL_SET_DMOD(ctrl_val,
+						 priv->dma_info->sourceType);
+				DMA_CTL_SET_DSIZ(ctrl_val,
+						 priv->dma_info->sourcePort);
+			}
+		}
+		__raw_writel(p->src_addr, &(dma_base->SourceAddr));
+		__raw_writel(p->dst_addr, &(dma_base->DestAddr));
+		__raw_writel(p->count, &(dma_base->Count));
+		p->state |= DMA_BD_ST_BUSY;
+		p->state &= ~(DMA_BD_ST_PEND);
+		ctrl_val |= DMA_CTL_CEN;
+		__raw_writel(ctrl_val, &(dma_base->Ctl));
+		if (q && priv->dma_chaining) {	/*DO chain-buffer */
+			__raw_writel(q->src_addr, &(dma_base->SourceAddr));
+			__raw_writel(q->dst_addr, &(dma_base->DestAddr));
+			__raw_writel(q->count, &(dma_base->Count));
+			q->state |= DMA_BD_ST_BUSY;
+			q->state &= ~(DMA_BD_ST_PEND);
+			ctrl_val |= DMA_CTL_ACRPT | DMA_CTL_RPT | DMA_CTL_CEN;
+			__raw_writel(ctrl_val, &(dma_base->Ctl));
+		}
+	} else {
+		/* Just dma channel which supports dma buffer can run
+		 * to there */
+		BUG_ON(!priv->dma_chaining);
+		if (q) {
+			/* p is tranfering, then q must be set into
+			 * dma controller */
+			/* WARNING:: [1] dangerous area begin.
+			 *           If the p is completed during MCU run
+			 *           in this erea, the dma channel is crashed.
+			 */
+			__raw_writel(q->src_addr, &(dma_base->SourceAddr));
+			__raw_writel(q->dst_addr, &(dma_base->DestAddr));
+			__raw_writel(q->count, &(dma_base->Count));
+			/* WARNING:: [2] dangerous area end */
+			ctrl_val =
+			    __raw_readl(&(dma_base->Ctl)) | (DMA_CTL_ACRPT |
+							     DMA_CTL_RPT |
+							     DMA_CTL_CEN);
+			__raw_writel(ctrl_val, &(dma_base->Ctl));
+
+			/* WARNING:: This is workaround and it is dangerous:
+			 *      the judgement is not safety.
+			 */
+			if (!__get_dma_interrupt(dma->channel)) {
+				q->state |= DMA_BD_ST_BUSY;
+				q->state &= ~(DMA_BD_ST_PEND);
+			} else {
+				/*Waiting re-enable is in ISR */
+				printk(KERN_ERR
+				       "Warning: The privous transfer "
+				       "is completed. Maybe the chain buffer "
+				       "is stopped.");
+			}
+		} else {
+			/* Last buffer is transfering: just clear RPT bit */
+			ctrl_val =
+			    __raw_readl(&(dma_base->Ctl)) &
+			    (~(DMA_CTL_ACRPT | DMA_CTL_RPT));
+			__raw_writel(ctrl_val, &(dma_base->Ctl));
+		}
+	}
+}
+
+/*!
+ * @brief interrupt handler of dma channel
+ */
+static irqreturn_t dma_irq_handler(int irq, void *dev_id,
+		struct pt_regs *regs)
+{
+	mxc_dma_channel_t *dma = (mxc_dma_channel_t *) dev_id;
+	mx2_dma_priv_t *priv = (mx2_dma_priv_t *) (dma ? dma->private : NULL);
+	dma_regs_t *dma_base;
+	int state, error = MXC_DMA_DONE;
+
+	BUG_ON(priv == NULL);
+
+	dma_base = (dma_regs_t *) priv->dma_base;
+
+	state = __clear_dma_interrupt(dma->channel);
+
+	priv->trans_bytes += dma_base->transferd;
+	if (state != DMA_DONE) {
+		if (state & DMA_REQUEST_TIMEOUT) {
+			error = MXC_DMA_REQUEST_TIMEOUT;
+		} else {
+			error = MXC_DMA_TRANSFER_ERROR;
+		}
+	}
+	if (consume_dma_bd(dma, error)) {
+		disable_dma_clk();
+		if (dma->cb_fn) {
+			dma->cb_fn(dma->cb_args, error, priv->trans_bytes);
+		}
+		priv->trans_bytes = 0;
+	} else {
+		disable_dma_clk();
+	}
+	return IRQ_HANDLED;
+}
+
+/*!
+ *@brief	Set DMA channel parameters
+ *
+ *@param	dma  Requested channel NO.
+ *@param	dma_info  Channel configuration
+ *@return	@li 0        	Success
+ *           	@li others 	Failure
+ */
+static int setup_dma_channel(mxc_dma_channel_t *dma, mx2_dma_info_t *dma_info)
+{
+	mx2_dma_priv_t *priv = (mx2_dma_priv_t *) (dma ? dma->private : NULL);
+	dma_regs_t *dma_base;
+	unsigned long reg;
+
+	if (!dma_info || !priv) {
+		return -1;
+	}
+
+	if (dma_info->sourceType > 3) {
+		return -1;
+	}
+	if (dma_info->destType > 3) {
+		return -1;
+	}
+	if (dma_info->destPort > 3) {
+		return -1;
+	}
+	if (dma_info->sourcePort > 3) {
+		return -1;
+	}
+	if (dma_info->M2D_Valid) {
+		/*add for second dma */
+		if (dma_info->W < dma_info->X) {
+			return -1;
+		}
+	}
+
+	priv->dma_chaining = dma_info->dma_chaining;
+	priv->ren = dma_info->ren;
+
+	if (dma_info->sourceType != DMA_TYPE_FIFO
+	    && dma_info->destType != DMA_TYPE_FIFO) {
+		if (dma_info->ren) {
+			printk(KERN_INFO
+			       "Warning: request enable just affect source "
+			       "or destination port is FIFO\n");
+			priv->ren = 0;
+		}
+	}
+
+	if (dma_info->M2D_Valid) {
+		if (dma_info->msel) {
+			__raw_writel(dma_info->W,
+				     IO_ADDRESS(DMA_BASE_ADDR) + DMA_WSRB);
+			__raw_writel(dma_info->X,
+				     IO_ADDRESS(DMA_BASE_ADDR) + DMA_XSRB);
+			__raw_writel(dma_info->Y,
+				     IO_ADDRESS(DMA_BASE_ADDR) + DMA_YSRB);
+
+		} else {
+			__raw_writel(dma_info->W,
+				     IO_ADDRESS(DMA_BASE_ADDR) + DMA_WSRA);
+			__raw_writel(dma_info->X,
+				     IO_ADDRESS(DMA_BASE_ADDR) + DMA_XSRA);
+			__raw_writel(dma_info->Y,
+				     IO_ADDRESS(DMA_BASE_ADDR) + DMA_YSRA);
+		}
+	}
+
+	dma_base = (dma_regs_t *) (priv->dma_base);
+
+	__raw_writel(dma_info->burstLength, &(dma_base->BurstLength));
+	__raw_writel(dma_info->request, &(dma_base->RequestSource));
+
+	if (dma_info->ren) {
+		reg = dma_info->busuntils & 0x1FFFF;
+		if (dma_info->rto_en) {
+			reg |= 0xE000;
+		}
+		__raw_writel(reg, &(dma_base->BusUtilt));
+	} else {
+		__raw_writel(dma_info->busuntils, &(dma_base->BusUtilt));
+	}
+
+	reg = __raw_readl(&(dma_base->Ctl)) & (~(DMA_CTL_ACRPT | DMA_CTL_RPT));
+
+	if (dma_info->dir) {
+		reg |= DMA_CTL_MDIR;
+	} else {
+		reg &= ~DMA_CTL_MDIR;
+	}
+
+	if (priv->ren) {
+		reg |= DMA_CTL_REN;
+	} else {
+		reg &= ~DMA_CTL_REN;
+	}
+
+	if ((dma_info->M2D_Valid) && (dma_info->msel)) {
+		reg |= DMA_CTL_MSEL;
+	} else {
+		reg &= ~DMA_CTL_MSEL;
+	}
+
+	if (dma_info->mode) {
+		DMA_CTL_SET_SMOD(reg, dma_info->destType);
+		DMA_CTL_SET_SSIZ(reg, dma_info->destPort);
+		DMA_CTL_SET_DMOD(reg, dma_info->sourceType);
+		DMA_CTL_SET_DSIZ(reg, dma_info->sourcePort);
+	} else {
+		DMA_CTL_SET_SMOD(reg, dma_info->sourceType);
+		DMA_CTL_SET_SSIZ(reg, dma_info->sourcePort);
+		DMA_CTL_SET_DMOD(reg, dma_info->destType);
+		DMA_CTL_SET_DSIZ(reg, dma_info->destPort);
+	}
+
+	__raw_writel(reg, &(dma_base->Ctl));
+
+	__clear_dma_interrupt(dma->channel);
+	unmask_dma_interrupt(dma->channel);
+
+	disable_dma_clk();
+	return 0;
+}
+
+/*!@brief setup interrupt and setup dma channel by dma parameter  */
+static inline int __init_dma_channel(mxc_dma_channel_t *chan,
+				     mx2_dma_info_t *dma_info)
+{
+	mx2_dma_priv_t *dma_private = (mx2_dma_priv_t *) chan->private;
+	dma_regs_t *dma_base;
+	int ret;
+
+	mask_dma_interrupt(chan->channel);
+	ret =
+	    request_irq(dma_private->dma_irq, dma_irq_handler,
+			SA_INTERRUPT | SA_SHIRQ, chan->dev_name, (void *)chan);
+	if (ret) {
+		printk(KERN_ERR
+		       "%s: unable to request IRQ %d for DMA channel\n",
+		       chan->dev_name, dma_private->dma_irq);
+		return ret;
+	}
+
+	enable_dma_clk();
+
+	dma_base = (dma_regs_t *) (dma_private->dma_base);
+	__raw_writel(0, &(dma_base->Ctl));
+
+	ret = setup_dma_channel(chan, dma_info);
+	if (ret)
+		free_irq(dma_private->dma_irq, (void *)chan);
+
+	disable_dma_clk();
+	return 0;
+}
+
+/*!@brief initialize buffer descriptor ring.*/
+static inline void init_dma_bd(mx2_dma_priv_t *private)
+{
+	int i;
+	mx2_dma_bd_t *pbd;
+	private->bd_rd = private->bd_wr = 0;
+	atomic_set(&(private->bd_used), 0);
+	for (i = 0, pbd = private->bd_ring; i < MAX_BD_SIZE; i++, pbd++) {
+		pbd->state = 0;
+	}
+}
+
+/*!@brief add dma buffer into buffer descriptor ring */
+static inline int fill_dma_bd(mxc_dma_channel_t *dma,
+			      mxc_dma_requestbuf_t *buf, int num,
+			      mxc_dma_mode_t mode)
+{
+	int i, wr;
+	unsigned long flags, mask;
+	mx2_dma_priv_t *priv = dma->private;
+	mx2_dma_bd_t *p, *q;
+
+	if ((atomic_read(&(priv->bd_used)) + num) > MAX_BD_SIZE) {
+		return -EBUSY;
+	}
+
+	for (i = 0; i < num; i++) {
+		wr = priv->bd_wr;
+		p = priv->bd_ring + wr;
+		p->mode = mode;
+		p->count = buf[i].num_of_bytes;
+		p->src_addr = buf[i].src_addr;
+		p->dst_addr = buf[i].dst_addr;
+		if (i == num - 1) {
+			p->state = DMA_BD_ST_LAST | DMA_BD_ST_PEND;
+		} else {
+			p->state = DMA_BD_ST_PEND;
+		}
+		priv->bd_wr = (wr + 1) % MAX_BD_SIZE;
+		atomic_inc(&(priv->bd_used));
+
+		if (atomic_read(&(priv->bd_used)) != 2)
+			continue;
+		/* Disable interrupt of this channel */
+		local_irq_save(flags);
+		local_irq_disable();
+		save_dma_interrupt(mask);
+		mask_dma_interrupt(dma->channel);
+		local_irq_restore(flags);
+		/*TODO ::
+		 *  If channel is transfering and supports chain_buffer,
+		 *  when the new buffer is 2st buffer , repeat must be enabled
+		 */
+		if (priv->dma_chaining && dma->active) {
+			q = priv->bd_ring + priv->bd_rd;
+			if (q && (q->state & DMA_BD_ST_BUSY)) {
+				if (atomic_read(&(priv->bd_used)) == 2) {
+					setup_dmac(dma);
+				}
+			}
+		}
+		restore_dma_interrupt(mask);
+	}
+	return 0;
+}
+
+/*!@brief add sg-list into buffer descriptor ring */
+static inline int fill_dma_bd_by_sg(mxc_dma_channel_t *dma,
+				    struct scatterlist *sg, int num,
+				    int real_bytes, mxc_dma_mode_t mode)
+{
+	int i, wr, total_bytes = real_bytes;
+	unsigned long flags, mask;
+	mx2_dma_priv_t *priv = dma->private;
+	mx2_dma_bd_t *p, *q;
+	if ((atomic_read(&(priv->bd_used)) + num) > MAX_BD_SIZE) {
+		return -EBUSY;
+	}
+
+	for (i = 0; i < num && ((real_bytes <= 0) || (total_bytes > 0)); i++) {
+		wr = priv->bd_wr;
+		p = priv->bd_ring + wr;
+		p->mode = mode;
+		if (real_bytes > 0) {
+			if (sg[i].length >= total_bytes) {
+				p->count = total_bytes;
+			} else {
+				p->count = sg[i].length;
+			}
+			total_bytes -= p->count;
+		} else {
+			p->count = sg[i].length;
+		}
+		if (mode == MXC_DMA_MODE_READ) {
+			p->src_addr = priv->dma_info->per_address;
+			p->dst_addr = sg[i].dma_address;
+		} else {
+			p->dst_addr = priv->dma_info->per_address;
+			p->src_addr = sg[i].dma_address;
+		}
+		if ((i == num - 1) ||
+		    ((real_bytes > 0) && (total_bytes == 0))) {
+			p->state = DMA_BD_ST_LAST | DMA_BD_ST_PEND;
+		} else {
+			p->state = DMA_BD_ST_PEND;
+		}
+		priv->bd_wr = (wr + 1) % MAX_BD_SIZE;
+		atomic_inc(&(priv->bd_used));
+
+		if (atomic_read(&(priv->bd_used)) != 2)
+			continue;
+		/* Disable interrupt of this channel */
+		local_irq_save(flags);
+		local_irq_disable();
+		save_dma_interrupt(mask);
+		mask_dma_interrupt(dma->channel);
+		local_irq_restore(flags);
+		/*TODO ::
+		 *  If channel is transfering and supports chain_buffer,
+		 *  when the new buffer is 2st buffer , repeat must be enabled
+		 */
+		if (priv->dma_chaining && dma->active) {
+			q = next_dma_bd(priv);
+			if (q && (q->state & DMA_BD_ST_BUSY)) {
+				if ((atomic_read(&(priv->bd_used))) == 2) {
+					setup_dmac(dma);
+				}
+			}
+		}
+		restore_dma_interrupt(mask);
+	}
+	return 0;
+}
+
+/*!@brief select next buffer descripter to transfer.
+ *	return 1: need call call-back function. 0: Not need call call-back.
+ *	it just is called in ISR
+ */
+static inline int consume_dma_bd(mxc_dma_channel_t *dma, int error)
+{
+	mx2_dma_priv_t *priv = dma->private;
+	mx2_dma_bd_t *p;
+	int notify = 0;
+	if (priv == NULL) {
+		printk(KERN_ERR
+		       "request completed on dma channel %d w"
+		       "which is not initialized", dma->channel);
+		return 1;
+	}
+	if (error != MXC_DMA_DONE) {
+		for (p = priv->bd_ring + priv->bd_rd;
+		     atomic_read(&(priv->bd_used)) > 0; ) {
+			priv->bd_rd = (priv->bd_rd + 1) % MAX_BD_SIZE;
+			atomic_dec(&(priv->bd_used));
+			if (p->state & DMA_BD_ST_LAST) {
+				p->state = 0;
+				break;
+			}
+			p->state = 0;
+		}
+		notify = 1;
+	} else {
+		p = priv->bd_ring + priv->bd_rd;
+		priv->bd_rd = (priv->bd_rd + 1) % MAX_BD_SIZE;
+		atomic_dec(&(priv->bd_used));
+		notify = (p->state & DMA_BD_ST_LAST) == DMA_BD_ST_LAST;
+	}
+	if (atomic_read(&(priv->bd_used)) <= 0) {
+		dma->active = 0;
+		atomic_dec(&g_dma_actived);
+	} else {
+		setup_dmac(dma);
+	}
+	return notify;
+}
+
+/*!
+ * This function is generally called by the driver at open time.
+ * The DMA driver would do any initialization steps that is required
+ * to get the channel ready for data transfer.
+ *
+ * @param channel_id   a pre-defined id. The peripheral driver would specify
+ *                     the id associated with its peripheral. This would be
+ *                     used by the DMA driver to identify the peripheral
+ *                     requesting DMA and do the necessary setup on the
+ *                     channel associated with the particular peripheral.
+ *                     The DMA driver could use static or dynamic DMA channel
+ *                     allocation.
+ * @param dev_name     module name or device name
+ * @return returns a negative number on error if request for a DMA channel
+ *         did not succeed, returns the channel number to be used on success.
+ */
+int mxc_dma_request(mxc_dma_device_t channel_id, char *dev_name)
+{
+	mxc_dma_channel_t *dma;
+	mx2_dma_priv_t *dma_private = NULL;
+	mx2_dma_info_t *dma_info = mxc_dma_get_info(channel_id);
+	int index;
+	int ret;
+
+	if (dma_info == NULL) {
+		return -EINVAL;
+	}
+
+	index = get_dma_channel(dma_info->dma_chan);
+	if (index < 0) {
+		return -ENODEV;
+	}
+
+	dma = g_dma_channels + index;
+	dma_private = (mx2_dma_priv_t *) dma->private;
+	if (dma_private == NULL) {
+		printk(KERN_ERR
+		       "request completed on dma channel %d w"
+		       "which is not initialized", index);
+		ret = -EFAULT;
+		goto exit;
+	}
+
+	dma->active = 0;
+	dma_private->dma_info = NULL;
+	dma->cb_fn = NULL;
+	dma->cb_args = NULL;
+	dma->dev_name = dev_name;
+	dma->mode = dma_info->mode ? MXC_DMA_MODE_WRITE : MXC_DMA_MODE_READ;
+	init_dma_bd(dma_private);
+
+	ret = __init_dma_channel(dma, dma_info);
+	if (!ret) {
+		dma_private->dma_info = dma_info;
+		return index;
+	}
+exit:
+	put_dma_channel(index);
+	return ret;
+}
+EXPORT_SYMBOL(mxc_dma_request);
+
+/*!
+ * This function is generally called by the driver at close time. The DMA
+ * driver would do any cleanup associated with this channel.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @return returns a negative number on error or 0 on success
+ */
+int mxc_dma_free(int channel_num)
+{
+	mxc_dma_channel_t *dma;
+	mx2_dma_priv_t *dma_private;
+
+	if ((channel_num >= MAX_DMA_CHANNELS) || (channel_num < 0)) {
+		return -EINVAL;
+	}
+
+	dma = g_dma_channels + channel_num;
+	dma_private = (mx2_dma_priv_t *) dma->private;
+	if (dma_private == NULL) {
+		printk(KERN_ERR
+		       "Free dma %d which is not completely initialized\n",
+		       channel_num);
+		return -EFAULT;
+	}
+	if (dma->lock) {
+		if (dma->active) {	/*Channel is busy */
+			mxc_dma_disable(channel_num);
+		}
+
+		dma_private = (mx2_dma_priv_t *) dma->private;
+
+		enable_dma_clk();
+		mask_dma_interrupt(channel_num);
+		disable_dma_clk();
+
+		free_irq(dma_private->dma_irq, (void *)dma);
+		put_dma_channel(channel_num);
+	}
+	return 0;
+}
+EXPORT_SYMBOL(mxc_dma_free);
+
+/*!
+ * This function would just configure the buffers specified by the user into
+ * dma channel. The caller must call mxc_dma_enable to start this transfer.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @param dma_buf      an array of physical addresses to the user defined
+ *                     buffers. The caller must guarantee the dma_buf is
+ *                     available until the transfer is completed.
+ * @param num_buf      number of buffers in the array
+ * @param mode         specifies whether this is READ or WRITE operation
+ * @return This function returns a negative number on error if buffer could
+ *         not be added with DMA for transfer. On Success, it returns 0
+ */
+int mxc_dma_config(int channel_num, mxc_dma_requestbuf_t *dma_buf, int num_buf,
+		   mxc_dma_mode_t mode)
+{
+	mxc_dma_channel_t *dma;
+	mx2_dma_priv_t *dma_private;
+
+	if ((dma_buf == NULL) || (num_buf < 1)) {
+		return -EINVAL;
+	}
+
+	if ((channel_num >= MAX_DMA_CHANNELS) || (channel_num < 0)) {
+		return -EINVAL;
+	}
+
+	dma = g_dma_channels + channel_num;
+	dma_private = (mx2_dma_priv_t *) dma->private;
+	if (dma_private == NULL) {
+		printk(KERN_ERR
+		       "config dma %d which is not completely initialized\n",
+		       channel_num);
+		return -EFAULT;
+	}
+
+	if (dma->lock == 0) {
+		return -ENODEV;
+	}
+
+	/*TODO: dma chainning can not support on bi-dir channel */
+	if (dma_private->dma_chaining && (dma->mode != mode)) {
+		return -EINVAL;
+	}
+
+	/*TODO: fill dma buffer into driver .
+	 * If driver is no enought buffer to save them , it will return -EBUSY
+	 */
+	if (fill_dma_bd(dma, dma_buf, num_buf, mode)) {
+		return -EBUSY;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(mxc_dma_config);
+
+/*!
+ * This function would just configure the scatterlist specified by the
+ * user into dma channel. This is a slight variation of mxc_dma_config(),
+ * it is provided for the convenience of drivers that have a scatterlist
+ * passed into them. It is the calling driver's responsibility to have the
+ * correct physical address filled in the "dma_address" field of the
+ * scatterlist.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @param sg           a scatterlist of buffers. The caller must guarantee
+ *                     the dma_buf is available until the transfer is
+ *                     completed.
+ * @param num_buf      number of buffers in the array
+ * @param num_of_bytes total number of bytes to transfer. If set to 0, this
+ *                     would imply to use the length field of the scatterlist
+ *                     for each DMA transfer. Else it would calculate the size
+ *                     for each DMA transfer.
+ * @param mode         specifies whether this is READ or WRITE operation
+ * @return This function returns a negative number on error if buffer could not
+ *         be added with DMA for transfer. On Success, it returns 0
+ */
+int mxc_dma_sg_config(int channel_num, struct scatterlist *sg,
+		      int num_buf, int num_of_bytes, mxc_dma_mode_t mode)
+{
+	mxc_dma_channel_t *dma;
+	mx2_dma_priv_t *dma_private;
+
+	if ((sg == NULL) || (num_buf < 1) || (num_of_bytes < 0)) {
+		return -EINVAL;
+	}
+
+	if ((channel_num >= MAX_DMA_CHANNELS) || (channel_num < 0)) {
+		return -EINVAL;
+	}
+
+	dma = g_dma_channels + channel_num;
+	dma_private = (mx2_dma_priv_t *) dma->private;
+	if (dma_private == NULL) {
+		printk(KERN_ERR
+		       "config_sg dma %d which is not completely "
+		       "initialized\n", channel_num);
+		return -EFAULT;
+	}
+
+	if (dma->lock == 0) {
+		return -ENODEV;
+	}
+
+	/*TODO: dma chainning can not support on bi-dir channel */
+	if (dma_private->dma_chaining && (dma->mode != mode)) {
+		return -EINVAL;
+	}
+
+	/*TODO: fill dma buffer into driver .
+	 * If driver is no enought buffer to save them , it will return -EBUSY
+	 */
+	if (fill_dma_bd_by_sg(dma, sg, num_buf, num_of_bytes, mode)) {
+		return -EBUSY;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(mxc_dma_sg_config);
+
+/*!
+ * This function is provided if the driver would like to set/change its
+ * callback function.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @param callback     a callback function to provide notification on transfer
+ *                     completion, user could specify NULL if he does not wish
+ *                     to be notified
+ * @param arg          an argument that gets passed in to the callback
+ *                     function, used by the user to do any driver specific
+ *                     operations.
+ * @return this function returns an error if the callback could not be set
+ *         for the channel
+ */
+int mxc_dma_callback_set(int channel_num, mxc_dma_callback_t callback,
+			 void *arg)
+{
+	mxc_dma_channel_t *dma;
+
+	if ((channel_num >= MAX_DMA_CHANNELS) || (channel_num < 0)) {
+		return -EINVAL;
+	}
+	dma = g_dma_channels + channel_num;
+
+	if (!dma->lock) {
+		return -ENODEV;
+	}
+
+	if (dma->active) {
+		return -EBUSY;
+	}
+	dma->cb_fn = callback;
+	dma->cb_args = arg;
+	return 0;
+
+}
+EXPORT_SYMBOL(mxc_dma_callback_set);
+
+/*!
+ * This stops the DMA channel and any ongoing transfers. Subsequent use of
+ * mxc_dma_enable() will restart the channel and restart the transfer.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @return returns a negative number on error or 0 on success
+ */
+int mxc_dma_disable(int channel_num)
+{
+	mxc_dma_channel_t *dma;
+	mx2_dma_priv_t *priv;
+	unsigned long ctrl_val;
+
+	if ((channel_num >= MAX_DMA_CHANNELS) || (channel_num < 0)) {
+		return -EINVAL;
+	}
+
+	dma = g_dma_channels + channel_num;
+
+	if (dma->lock == 0) {
+		return -EINVAL;
+	}
+
+	if (!dma->active) {
+		return -EINVAL;
+	}
+
+	priv = (mx2_dma_priv_t *) dma->private;
+	if (priv == NULL) {
+		printk(KERN_ERR "disable uncompleted dma channel %d\n",
+		       channel_num);
+		return -EFAULT;
+	}
+
+	dma->active = 0;
+	enable_dma_clk();
+
+	__clear_dma_interrupt(channel_num);
+	ctrl_val =
+	    __raw_readl(IO_ADDRESS(DMA_BASE_ADDR) + DMA_CCR(channel_num));
+	ctrl_val &= ~DMA_CTL_CEN;	/* clear CEN bit */
+	__raw_writel(ctrl_val,
+		     IO_ADDRESS(DMA_BASE_ADDR) + DMA_CCR(channel_num));
+	disable_dma_clk();
+	atomic_dec(&g_dma_actived);
+
+	/*TODO: Clear all request buffers */
+	flush_dma_bd(priv);
+	return 0;
+}
+EXPORT_SYMBOL(mxc_dma_disable);
+
+/*!
+ * This starts DMA transfer. Or it restarts DMA on a stopped channel
+ * previously stopped with mxc_dma_disable().
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @return returns a negative number on error or 0 on success
+ */
+int mxc_dma_enable(int channel_num)
+{
+	mxc_dma_channel_t *dma;
+	mx2_dma_priv_t *priv;
+
+	if ((channel_num >= MAX_DMA_CHANNELS) || (channel_num < 0)) {
+		return -EINVAL;
+	}
+
+	dma = g_dma_channels + channel_num;
+
+	if (dma->lock == 0) {
+		return -EINVAL;
+	}
+
+	priv = (mx2_dma_priv_t *) dma->private;
+	if (priv == NULL) {
+		printk(KERN_ERR "enable uncompleted dma channel %d\n",
+		       channel_num);
+		return -EFAULT;
+	}
+
+	if (dma->active) {
+		return 0;
+	}
+	dma->active = 1;
+	priv->trans_bytes = 0;
+
+	enable_dma_clk();
+
+	atomic_inc(&g_dma_actived);
+	__clear_dma_interrupt(channel_num);
+
+	setup_dmac(dma);
+	disable_dma_clk();
+	return 0;
+}
+EXPORT_SYMBOL(mxc_dma_enable);
+
+/*!
+*@brief Dump DMA registers
+*
+*@param channel  Requested channel NO.
+*@return     none
+*/
+
+void mxc_dump_dma_register(int channel)
+{
+	mxc_dma_channel_t *dma = &g_dma_channels[channel];
+	mx2_dma_priv_t *priv = (mx2_dma_priv_t *) dma->private;
+	dma_regs_t *dma_base;
+
+	printk(KERN_INFO "======== Dump dma channel %d \n", channel);
+	if ((unsigned)channel >= MXC_DMA_CHANNELS) {
+		printk(KERN_INFO "Channel number is invalid \n");
+		return;
+	}
+	if (!dma->lock) {
+		printk(KERN_INFO "Channel is not allocated \n");
+		return;
+	}
+
+	printk(KERN_INFO "g_dma_actived = %d\n", atomic_read(&g_dma_actived));
+
+	enable_dma_clk();
+	dma_base = (dma_regs_t *) (priv->dma_base);
+	printk(KERN_INFO "DMA COMMON REGISTER\n");
+	printk(KERN_INFO "DMA CONTROL             DMA_DCR: %08x\n",
+	       __raw_readl(IO_ADDRESS(DMA_BASE_ADDR) + DMA_DCR));
+	printk(KERN_INFO "DMA Interrupt status    DMA_DISR: %08x\n",
+	       __raw_readl(IO_ADDRESS(DMA_BASE_ADDR) + DMA_DISR));
+	printk(KERN_INFO "DMA Interrupt Mask      DMA_DIMR: %08x\n",
+	       __raw_readl(IO_ADDRESS(DMA_BASE_ADDR) + DMA_DIMR));
+	printk(KERN_INFO "DMA Burst Time Out      DMA_DBTOSR: %08x\n",
+	       __raw_readl(IO_ADDRESS(DMA_BASE_ADDR) + DMA_DBTOSR));
+	printk(KERN_INFO "DMA request Time Out    DMA_DRTOSR: %08x\n",
+	       __raw_readl(IO_ADDRESS(DMA_BASE_ADDR) + DMA_DRTOSR));
+	printk(KERN_INFO "DMA Transfer Error      DMA_DSESR: %08x\n",
+	       __raw_readl(IO_ADDRESS(DMA_BASE_ADDR) + DMA_DSESR));
+	printk(KERN_INFO "DMA DMA_Overflow        DMA_DBOSR: %08x\n",
+	       __raw_readl(IO_ADDRESS(DMA_BASE_ADDR) + DMA_DBOSR));
+	printk(KERN_INFO "DMA Burst Time OutCtl   DMA_BurstTOCtl: %08x\n",
+	       __raw_readl(IO_ADDRESS(DMA_BASE_ADDR) + DMA_DBTOCR));
+
+	printk(KERN_INFO "DMA 2D X size: %08x\n",
+	       __raw_readl(IO_ADDRESS(DMA_BASE_ADDR) + DMA_XSRA));
+	printk(KERN_INFO "DMA 2D Y size: %08x\n",
+	       __raw_readl(IO_ADDRESS(DMA_BASE_ADDR) + DMA_YSRA));
+	printk(KERN_INFO "DMA 2D Z size: %08x\n",
+	       __raw_readl(IO_ADDRESS(DMA_BASE_ADDR) + DMA_WSRA));
+
+	printk(KERN_INFO "DMA Chan %2d  Sourc     SourceAddr: %08x\n", channel,
+	       __raw_readl(&(dma_base->SourceAddr)));
+	printk(KERN_INFO "DMA Chan %2d  dest      DestAddr: %08x\n", channel,
+	       __raw_readl(&(dma_base->DestAddr)));
+	printk(KERN_INFO "DMA Chan %2d  count     Count: %08x\n", channel,
+	       __raw_readl(&(dma_base->Count)));
+	printk(KERN_INFO "DMA Chan %2d  Ctl       Ctl: %08x\n", channel,
+	       __raw_readl(&(dma_base->Ctl)));
+	printk(KERN_INFO "DMA Chan %2d  request   RequestSource: %08x\n",
+	       channel, __raw_readl(&(dma_base->RequestSource)));
+	printk(KERN_INFO "DMA Chan %2d  burstL    BurstLength: %08x\n", channel,
+	       __raw_readl(&(dma_base->BurstLength)));
+	printk(KERN_INFO "DMA Chan %2d  requestTO ReqTimeout: %08x\n", channel,
+	       __raw_readl(&(dma_base->ReqTimeout)));
+	printk(KERN_INFO "DMA Chan %2d  BusUtilt  BusUtilt: %08x\n", channel,
+	       __raw_readl(&(dma_base->BusUtilt)));
+
+	disable_dma_clk();
+}
+EXPORT_SYMBOL(mxc_dump_dma_register);
+
+int __init mxc_dma_init(void)
+{
+	int i;
+	mxc_dma_channel_t *dma = g_dma_channels;
+	mx2_dma_priv_t *private = g_dma_privates;
+
+	memset(dma, 0, sizeof(mxc_dma_channel_t) * MXC_DMA_CHANNELS);
+	for (i = 0; i < MXC_DMA_CHANNELS; i++, dma++, private++) {
+		dma->channel = i;
+		dma->private = private;
+		private->dma_base =
+		    (unsigned int)(IO_ADDRESS(DMA_BASE_ADDR + DMA_CH_BASE(i)));
+		private->dma_irq = i + MXC_DMA_INTR_0;	/* Dma channel interrupt number */
+		private->bd_ring = &g_dma_bd_table[i][0];
+	}
+
+	mxc_dma_load_info(g_dma_channels);
+
+	dma_clk = clk_get(NULL, "dma_clk");
+	clk_enable(dma_clk);
+
+	__raw_writel(0x2, IO_ADDRESS(DMA_BASE_ADDR) + DMA_DCR);	/* reset DMA; */
+
+	disable_dma_clk();
+
+	/* use module init because create_proc after init_dma */
+	g_proc_dir = create_proc_entry("dma", 0, NULL);
+	g_proc_dir->read_proc = (read_proc_t *) mxc_get_dma_list;
+	g_proc_dir->data = NULL;
+
+	return 0;
+}
+
+arch_initcall(mxc_dma_init);
Index: linux-2.6.18/include/asm-arm/arch-mxc/dma.h
===================================================================
--- linux-2.6.18.orig/include/asm-arm/arch-mxc/dma.h
+++ linux-2.6.18/include/asm-arm/arch-mxc/dma.h
@@ -18,4 +18,237 @@
  *
  * @ingroup SDMA
  */
+
+#define MXC_DMA_DYNAMIC_CHANNEL   255
+
+#define MXC_DMA_DONE		  0x0
+#define MXC_DMA_REQUEST_TIMEOUT   0x1
+#define MXC_DMA_TRANSFER_ERROR    0x2
+
+/*! This defines the list of device ID's for DMA */
+typedef enum mxc_dma_device {
+	MXC_DMA_UART1_RX,
+	MXC_DMA_UART1_TX,
+	MXC_DMA_UART2_RX,
+	MXC_DMA_UART2_TX,
+	MXC_DMA_UART3_RX,
+	MXC_DMA_UART3_TX,
+	MXC_DMA_UART4_RX,
+	MXC_DMA_UART4_TX,
+	MXC_DMA_UART5_RX,
+	MXC_DMA_UART5_TX,
+	MXC_DMA_UART6_RX,
+	MXC_DMA_UART6_TX,
+	MXC_DMA_MMC1_WIDTH_1,
+	MXC_DMA_MMC1_WIDTH_4,
+	MXC_DMA_MMC2_WIDTH_1,
+	MXC_DMA_MMC2_WIDTH_4,
+	MXC_DMA_SSI1_8BIT_RX0,
+	MXC_DMA_SSI1_8BIT_TX0,
+	MXC_DMA_SSI1_16BIT_RX0,
+	MXC_DMA_SSI1_16BIT_TX0,
+	MXC_DMA_SSI1_24BIT_RX0,
+	MXC_DMA_SSI1_24BIT_TX0,
+	MXC_DMA_SSI1_8BIT_RX1,
+	MXC_DMA_SSI1_8BIT_TX1,
+	MXC_DMA_SSI1_16BIT_RX1,
+	MXC_DMA_SSI1_16BIT_TX1,
+	MXC_DMA_SSI1_24BIT_RX1,
+	MXC_DMA_SSI1_24BIT_TX1,
+	MXC_DMA_SSI2_8BIT_RX0,
+	MXC_DMA_SSI2_8BIT_TX0,
+	MXC_DMA_SSI2_16BIT_RX0,
+	MXC_DMA_SSI2_16BIT_TX0,
+	MXC_DMA_SSI2_24BIT_RX0,
+	MXC_DMA_SSI2_24BIT_TX0,
+	MXC_DMA_SSI2_8BIT_RX1,
+	MXC_DMA_SSI2_8BIT_TX1,
+	MXC_DMA_SSI2_16BIT_RX1,
+	MXC_DMA_SSI2_16BIT_TX1,
+	MXC_DMA_SSI2_24BIT_RX1,
+	MXC_DMA_SSI2_24BIT_TX1,
+	MXC_DMA_FIR_RX,
+	MXC_DMA_FIR_TX,
+	MXC_DMA_CSPI1_RX,
+	MXC_DMA_CSPI1_TX,
+	MXC_DMA_CSPI2_RX,
+	MXC_DMA_CSPI2_TX,
+	MXC_DMA_CSPI3_RX,
+	MXC_DMA_CSPI3_TX,
+	MXC_DMA_ATA_RX,
+	MXC_DMA_ATA_TX,
+	MXC_DMA_MEMORY,
+	MXC_DMA_DSP_PACKET_DATA0_RD,
+	MXC_DMA_DSP_PACKET_DATA0_WR,
+	MXC_DMA_DSP_PACKET_DATA1_RD,
+	MXC_DMA_DSP_PACKET_DATA1_WR,
+	MXC_DMA_DSP_LOG0_CHNL,
+	MXC_DMA_DSP_LOG1_CHNL,
+	MXC_DMA_DSP_LOG2_CHNL,
+	MXC_DMA_DSP_LOG3_CHNL,
+	MXC_DMA_CSI_RX,
+	MXC_DMA_TEST_RAM2D2RAM,
+	MXC_DMA_TEST_RAM2RAM2D,
+	MXC_DMA_TEST_RAM2D2RAM2D,
+	MXC_DMA_TEST_RAM2RAM,
+	MXC_DMA_TEST_HW_CHAINING,
+	MXC_DMA_TEST_SW_CHAINING
+} mxc_dma_device_t;
+
+/*! This defines the prototype of callback funtion registered by the drivers */
+typedef void (*mxc_dma_callback_t) (void *arg, int error_status,
+				    unsigned int count);
+
+/*! This defines the type of DMA transfer requested */
+typedef enum mxc_dma_mode {
+	MXC_DMA_MODE_READ,
+	MXC_DMA_MODE_WRITE,
+} mxc_dma_mode_t;
+
+/*! This defines the DMA channel parameters */
+typedef struct mxc_dma_channel {
+	unsigned int active:1;	/*!< When there has a active tranfer, it is set to 1 */
+	unsigned int lock;	/*!< Defines the channel is allocated or not */
+	int curr_buf;		/*!< Current buffer */
+	mxc_dma_mode_t mode;	/*!< Read or Write */
+	unsigned int channel;	/*!< Channel info */
+	unsigned int dynamic:1;	/*!< Channel not statically allocated when 1 */
+	char *dev_name;		/*!< Device name */
+	void *private;		/*!< Private structure for platform */
+	mxc_dma_callback_t cb_fn;	/*!< The callback function */
+	void *cb_args;		/*!< The argument of callback function */
+} mxc_dma_channel_t;
+
+/*! This structure contains the information about a dma transfer */
+typedef struct mxc_dma_requestbuf {
+	dma_addr_t src_addr;	/*!< source address */
+	dma_addr_t dst_addr;	/*!< destination address */
+	int num_of_bytes;	/*!< the length of this transfer : bytes */
+} mxc_dma_requestbuf_t;
+
+#if defined(CONFIG_ARCH_MX2)
+#include <asm/arch/mx2_dma.h>
+#endif
+
+/*!
+ * This function is generally called by the driver at open time.
+ * The DMA driver would do any initialization steps that is required
+ * to get the channel ready for data transfer.
+ *
+ * @param channel_id   a pre-defined id. The peripheral driver would specify
+ *                     the id associated with its peripheral. This would be
+ *                     used by the DMA driver to identify the peripheral
+ *                     requesting DMA and do the necessary setup on the
+ *                     channel associated with the particular peripheral.
+ *                     The DMA driver could use static or dynamic DMA channel
+ *                     allocation.
+ * @param dev_name     module name or device name
+ * @return on success, returns the channel number to be used
+ *         on failure, returns a negative error code.
+ */
+extern int mxc_dma_request(mxc_dma_device_t channel_id, char *dev_name);
+
+/*!
+ * This function is generally called by the driver at close time. The DMA
+ * driver would do any cleanup associated with this channel.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @return returns a negative number on error or 0 on success
+ */
+extern int mxc_dma_free(int channel_num);
+
+/*!
+ * This function would just configure the buffers specified by the user into
+ * dma channel. The caller must call mxc_dma_enable to start this transfer.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @param dma_buf      an array of physical addresses to the user defined
+ *                     buffers. The caller must guarantee the dma_buf is
+ *                     available until the transfer is completed.
+ * @param num_buf      number of buffers in the array
+ * @param mode         specifies whether this is READ or WRITE operation
+ * @return This function returns a negative number on error if buffer could not be
+ *         added with DMA for transfer. On Success, it returns 0
+ */
+extern int mxc_dma_config(int channel_num, mxc_dma_requestbuf_t *dma_buf,
+			  int num_buf, mxc_dma_mode_t mode);
+
+/*!
+ * This function would just configure the scatterlist specified by the
+ * user into dma channel. This is a slight variation of mxc_dma_config(),
+ * it is provided for the convenience of drivers that have a scatterlist
+ * passed into them. It is the calling driver's responsibility to have the
+ * correct physical address filled in the "dma_address" field of the
+ * scatterlist.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @param sg           a scatterlist of buffers. The caller must guarantee
+ *                     the dma_buf is available until the transfer is
+ *                     completed.
+ * @param num_buf      number of buffers in the array
+ * @param num_of_bytes total number of bytes to transfer. If set to 0, this
+ *                     would imply to use the length field of the scatterlist
+ *                     for each DMA transfer. Else it would calculate the size
+ *                     for each DMA transfer.
+ * @param mode         specifies whether this is READ or WRITE operation
+ * @return This function returns a negative number on error if buffer could not
+ *         be added with DMA for transfer. On Success, it returns 0
+ */
+extern int mxc_dma_sg_config(int channel_num, struct scatterlist *sg,
+			     int num_buf, int num_of_bytes,
+			     mxc_dma_mode_t mode);
+
+/*!
+ * This function is provided if the driver would like to set/change its
+ * callback function.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @param callback     a callback function to provide notification on transfer
+ *                     completion, user could specify NULL if he does not wish
+ *                     to be notified
+ * @param arg          an argument that gets passed in to the callback
+ *                     function, used by the user to do any driver specific
+ *                     operations.
+ * @return this function returns a negative number on error if the callback
+ *         could not be set for the channel or 0 on success
+ */
+extern int mxc_dma_callback_set(int channel_num, mxc_dma_callback_t callback,
+				void *arg);
+
+/*!
+ * This stops the DMA channel and any ongoing transfers. Subsequent use of
+ * mxc_dma_enable() will restart the channel and restart the transfer.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @return returns a negative number on error or 0 on success
+ */
+extern int mxc_dma_disable(int channel_num);
+
+/*!
+ * This starts DMA transfer. Or it restarts DMA on a stopped channel
+ * previously stopped with mxc_dma_disable().
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @return returns a negative number on error or 0 on success
+ */
+extern int mxc_dma_enable(int channel_num);
+
 #endif
Index: linux-2.6.18/include/asm-arm/arch-mxc/mx27.h
===================================================================
--- linux-2.6.18.orig/include/asm-arm/arch-mxc/mx27.h
+++ linux-2.6.18/include/asm-arm/arch-mxc/mx27.h
@@ -273,6 +273,43 @@
  */
 #define GPIO_NUM_PIN            32
 
+#define DMA_REQ_NFC             37
+#define DMA_REQ_SDHC3           36
+#define DMA_REQ_UART6_RX        35
+#define DMA_REQ_UART6_TX        34
+#define DMA_REQ_UART5_RX        33
+#define DMA_REQ_UART5_TX        32
+#define DMA_REQ_CSI_RX          31
+#define DMA_REQ_CSI_STAT        30
+#define DMA_REQ_ATA_RCV         29
+#define DMA_REQ_ATA_TX          28
+#define DMA_REQ_UART1_TX        27
+#define DMA_REQ_UART1_RX        26
+#define DMA_REQ_UART2_TX        25
+#define DMA_REQ_UART2_RX        24
+#define DMA_REQ_UART3_TX        23
+#define DMA_REQ_UART3_RX        22
+#define DMA_REQ_UART4_TX        21
+#define DMA_REQ_UART4_RX        20
+#define DMA_REQ_CSPI1_TX        19
+#define DMA_REQ_CSPI1_RX        18
+#define DMA_REQ_CSPI2_TX        17
+#define DMA_REQ_CSPI2_RX        16
+#define DMA_REQ_SSI1_TX1        15
+#define DMA_REQ_SSI1_RX1        14
+#define DMA_REQ_SSI1_TX0        13
+#define DMA_REQ_SSI1_RX0        12
+#define DMA_REQ_SSI2_TX1        11
+#define DMA_REQ_SSI2_RX1        10
+#define DMA_REQ_SSI2_TX0        9
+#define DMA_REQ_SSI2_RX0        8
+#define DMA_REQ_SDHC1           7
+#define DMA_REQ_SDHC2           6
+#define DMA_REQ_MSHC            4
+#define DMA_REQ_EXT             3
+#define DMA_REQ_CSPI3_TX        2
+#define DMA_REQ_CSPI3_RX        1
+
 #define MXC_TIMER_GPT1          1
 #define MXC_TIMER_GPT2          2
 #define MXC_TIMER_GPT3          3
Index: linux-2.6.18/include/asm-arm/arch-mxc/mx2_dma.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/asm-arm/arch-mxc/mx2_dma.h
@@ -0,0 +1,259 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_MX2_H__
+#define __ASM_ARCH_MXC_MX2_H__
+
+/*!
+ * @defgroup DMA_MX27 DMA driver for i.MX27
+ */
+
+/*!
+ *@file arch-mxc/mx2_dma.h
+ *@brief DMA driver header file
+ *
+ * @ingroup DMA_MX27
+ *
+ */
+
+#include <asm/hardware.h>
+#include <asm/dma.h>
+#include <stdarg.h>
+
+#define MXC_DMA_INTR_0		32
+
+#define DMA_DCR		0x000	/* 32bit dma control reg */
+#define DMA_DISR	0x004	/* 32bit dma interrupt status reg */
+#define DMA_DIMR	0x008	/* 32bit dma interrupt mask reg */
+#define DMA_DBTOSR	0x00c	/* 32bit dma burst timeout stat reg */
+#define DMA_DRTOSR	0x010	/* 32bit dma req timeout status reg */
+#define DMA_DSESR	0x014	/* 32bit dma transfer err status reg */
+#define DMA_DBOSR	0x018	/* 32bit dma buffer overflow stat reg */
+#define DMA_DBTOCR	0x01c	/* 32bit dma burst timeout ctrl reg */
+
+#define DMA_WSRA	0x040	/* 32bit dma W-size A reg */
+#define DMA_XSRA	0x044	/* 32bit dma X-size A reg */
+#define DMA_YSRA	0x048	/* 32bit dma Y-size A reg */
+#define DMA_WSRB	0x04C	/* 32bit dma W-size B reg */
+#define DMA_XSRB	0x050	/* 32bit dma X-size B reg */
+#define DMA_YSRB	0x054	/* 32bit dma Y-size B reg */
+
+#define DMA_CH_BASE(x)	(0x080+0x040*(x))
+
+#define DMA_SAR(x)	(DMA_CH_BASE(x)+0x000)
+#define DMA_DAR(x)	(DMA_CH_BASE(x)+0x004)
+#define DMA_CNTR(x)	(DMA_CH_BASE(x)+0x008)
+#define DMA_CCR(x)	(DMA_CH_BASE(x)+0x00C)	/* 32bit dma ch0 control reg */
+#define DMA_RSSR(x)	(DMA_CH_BASE(x)+0x010)	/* 32bit dma ch0 req source sel reg */
+#define DMA_BLR(x)	(DMA_CH_BASE(x)+0x014)	/* 32bit dma ch0 burst lenght reg */
+#define DMA_RTOR(x)	(DMA_CH_BASE(x)+0x018)	/* 32bit dma ch0 req time out reg */
+#define DMA_BUCR(x)	(DMA_CH_BASE(x)+0x018)	/* 32bit dma ch0 bus utilization reg */
+#define DMA_CCNR(x)	(DMA_CH_BASE(x)+0x01C)	/* 32bit dma ch0 */
+
+#define DMA_TCR		0x480	/* 32bit dma test control reg */
+#define DMA_TFIFOA	0x484	/* 32bit dma test fifo A reg */
+#define DMA_TDRR	0x488	/* 32bit dma test request reg */
+#define DMA_TDIPR	0x48c	/* 32bit dma test in progress reg */
+#define DMA_TFIFOB	0x490	/* 32bit dma test fifo B reg */
+
+/*!
+ * This defines maximum DMA address
+ */
+#define MAX_DMA_ADDRESS 0xffffffff
+
+#define MXC_DMA_CHANNELS 16
+#define MAX_DMA_CHANNELS MXC_DMA_CHANNELS
+
+#define MX_DMA_CHANNELS		MXC_DMA_CHANNELS
+
+/*!@def DMA_MEM_SIZE_8 DMA access port size, 8 bit*/
+/*!@def DMA_MEM_SIZE_16 DMA access port size, 16 bit*/
+/*!@def DMA_MEM_SIZE_32 DMA access port size, 32 bit*/
+#define DMA_MEM_SIZE_8		0x1
+#define DMA_MEM_SIZE_16		0x2
+#define DMA_MEM_SIZE_32		0x0
+
+/*!@def DMA_TYPE_LINEAR DMA transfer type, linear*/
+/*!@def DMA_TYPE_2D DMA transfer type, 2D*/
+/*!@def DMA_TYPE_FIFO DMA transfer type, FIFO*/
+/*!@def DMA_TYPE_EBE DMA transfer type, end-of-burst enable FIFO*/
+#define DMA_TYPE_LINEAR		0x0
+#define DMA_TYPE_2D		0x1
+#define DMA_TYPE_FIFO		0x2
+#define DMA_TYPE_EBE		0x3
+
+/*!@def DMA_DONE DMA transfer done*/
+/*!@def DMA_BURST_TIMEOUT DMA transfer timeout error*/
+/*!@def DMA_REQUEST_TIMEOUT DMA transfer request timeout error*/
+/*!@def DMA_TRANSFER_ERROR DMA transfer error*/
+/*!@def DMA_BUFFER_OVERFLOW DMA transfer buffer overflow error*/
+#define DMA_DONE		0x1000
+#define DMA_BURST_TIMEOUT 	0x1
+#define DMA_REQUEST_TIMEOUT 	0x2
+#define DMA_TRANSFER_ERROR	0x4
+#define DMA_BUFFER_OVERFLOW	0x8
+
+/*!@brief DMA control register*/
+typedef struct {
+	volatile u32 CEN:1;		/*!< DMA channel enable */
+	volatile u32 FRC:1;		/*!< force a dma cycle bit */
+	volatile u32 RPT:1;		/*!< repeat bit */
+	volatile u32 REN:1;		/*!< request enable bit */
+	volatile u32 SSIZ:2;		/*!< source port size, 2 bit in length */
+	volatile u32 DSIZ:2;		/*!< dest port size, 2 bit in length */
+	volatile u32 MSEL:1;		/*!< 2D memory register set  bit */
+	volatile u32 MDIR:1;		/*!< transfer direction, inversed or normal */
+	volatile u32 SMOD:2;		/*!< source mode, 2 bit in length */
+	volatile u32 DMOD:2;		/*!< dest mode, 2 bit in length */
+	volatile u32 ACRPT:1;		/*!< auto clear repeat bit */
+	volatile u32 Reserved:17;	/*!< reserved bits */
+} dma_regs_control;
+
+#define DMA_CTL_CEN 0x1
+#define DMA_CTL_FRC 0x2
+#define DMA_CTL_RPT 0x4
+#define DMA_CTL_REN 0x8
+
+#define DMA_CTL_MSEL 0x100
+#define DMA_CTL_MDIR 0x200
+#define DMA_CTL_ACRPT 0x4000
+
+#define DMA_CTL_GET_SSIZ(x)	(((x)>>4)&0x3)
+#define DMA_CTL_GET_DSIZ(x)	(((x)>>6)&0x3)
+#define DMA_CTL_GET_SMOD(x)	(((x)>>10)&0x3)
+#define DMA_CTL_GET_DMOD(x)	(((x)>>12)&0x3)
+
+#define DMA_CTL_SET_SSIZ(x, value) do {	\
+	(x) &= ~(0x3 << 4);		\
+	(x) |= (value) << 4;		\
+} while (0)
+
+#define DMA_CTL_SET_DSIZ(x, value) do {	\
+	(x) &= ~(0x3 << 6);		\
+	(x) |= (value) << 6;		\
+} while (0)
+
+#define DMA_CTL_SET_SMOD(x, value) do {	\
+	(x) &= ~(0x3 << 10);		\
+	(x) |= (value) << 10;		\
+} while (0)
+
+#define DMA_CTL_SET_DMOD(x, value) do {	\
+	(x) &= ~(0x3 << 12);		\
+	(x) |= (value) << 12;		\
+} while (0)
+
+typedef struct {
+	volatile u32 SourceAddr;
+	volatile u32 DestAddr;
+	volatile u32 Count;
+	volatile u32 Ctl;
+	volatile u32 RequestSource;
+	volatile u32 BurstLength;
+	union {
+		volatile u32 ReqTimeout;
+		volatile u32 BusUtilt;
+	};
+	volatile u32 transferd;
+} dma_regs_t;
+
+#ifndef TRANSFER_32BIT
+/*!
+ * This defines DMA access data size
+ */
+
+#define TRANSFER_8BIT       DMA_MEM_SIZE_8
+#define TRANSFER_16BIT      DMA_MEM_SIZE_16
+#define TRANSFER_32BIT      DMA_MEM_SIZE_32
+
+#endif
+
+/*!
+ * This defines maximum device name length passed during mxc_request_dma().
+ */
+#define MAX_DEVNAME_LENGTH 32
+#define MAX_BD_SIZE	64
+
+/*!
+ * Structure containing dma channel parameters.
+ */
+typedef struct {
+	unsigned long dma_chan;	/*!< the dma channel information: dynamic or channel number */
+	u32 mode:1;		/*!< the initialized dma mode, 0 for dma read, 1 for dma write */
+	u32 rto_en:1;		/*!< enable request-timeout. It is valid when REN=1 */
+	u32 dir:1;		/*!< transfer direction, 0 for increment, 1 for decrement */
+	u32 dma_chaining:1;	/*!< autoclear bit for chainbuffer */
+	u32 ren:1;		/*!< enable transfer based request signal */
+	u32 M2D_Valid:1;	/*!< enable 2D address module. 0 for disable it. 1 for enabled it */
+	u32 msel:1;		/*!< 2D memory selection, 0 for set A, 1 for set B */
+	u32 burstLength;	/*!< channel burst length */
+	u32 request;		/*!< request source */
+	u32 busuntils;		/*!< when REN=0, Bus utilization, otherwise it it request timeout */
+	u32 sourceType;		/*!< source type, see DMA_TYPE_* */
+	u32 sourcePort;		/*!< source port size, see DMA_MEM_SIZE_* */
+	u32 destType;		/*!< destination type, see DMA_TYPE_* */
+	u32 destPort;		/*!< destination port size, see DMA_MEM_SIZE_* */
+	__u32 per_address;	/*!< peripheral source/destination physical address */
+	u32 W;			/*!< 2D Wide-size */
+	u32 X;			/*!< 2D X-size */
+	u32 Y;			/*!< 2D Y-size */
+} mx2_dma_info_t;
+
+/*!
+ * Structure of dma buffer descriptor
+ */
+typedef struct {
+	unsigned long state;	/*!< dma bd state */
+	int mode;		/*!< the dma mode of this bd */
+	unsigned long count;	/*!< the length of the dma transfer */
+	unsigned long src_addr;	/*!< the source address of the dma transfer */
+	unsigned long dst_addr;	/*!< the destination address of the dma transfer */
+} mx2_dma_bd_t;
+
+/*!
+ * the states of dma buffer descriptor
+ */
+#define DMA_BD_ST_BUSY	0x20000000	/*!< dma bd is transfering or has be configured into controller */
+#define DMA_BD_ST_PEND	0x10000000	/*!< dma bd is waiting to be configured into controller */
+#define DMA_BD_ST_LAST	0x08000000	/*!< dma bd is the last dma bd which is built in one dma transfer request
+					 *          When completed this bd, the callback function must be called.
+					 */
+
+/*!
+ *  This structure containing the private information for MX2
+ */
+typedef struct mx2_dma_priv_s {
+	unsigned int dma_chaining:1;	/* 1: using headware dma chaining feature */
+	unsigned int ren:1;		/* 1: dma start besed on request signal */
+	unsigned long trans_bytes;	/* To store the transfered data bytes in this transfer */
+	mx2_dma_info_t *dma_info;	/* To store the pointer for dma parameter for reading and wirting */
+	int bd_rd;			/* the read index of bd ring */
+	int bd_wr;			/* the write index of bd ring */
+	atomic_t bd_used;		/* the valid bd number in bd ring */
+	mx2_dma_bd_t *bd_ring;		/* the pointer of bd ring */
+	unsigned long dma_base;		/* register base address of this channel */
+	int dma_irq;			/* irq number of this channel */
+} mx2_dma_priv_t;
+
+/*!
+ * @brief get the dma info by channel_id
+ */
+extern mx2_dma_info_t *mxc_dma_get_info(mxc_dma_device_t channel_id);
+
+/*!
+ * @brief: scan dma parameter list, collect information about which channels
+ *         are dynamic.
+ */
+extern void mxc_dma_load_info(mxc_dma_channel_t *dma);
+
+#endif
Index: linux-2.6.18/mvl_patches/pro50-0107.c
===================================================================
--- /dev/null
+++ linux-2.6.18/mvl_patches/pro50-0107.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(107);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

