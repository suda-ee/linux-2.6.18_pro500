#! /usr/bin/env bash
# Patch: -common_arm_freescale_mx27ads_v4l2_support
# Date: Wed Aug 29 07:28:24 2007
# Source:  http://opensource.freescale.com/pub/scm/linux-2.6-mx.git
# MR: 24410
# Type: Integration
# Disposition: merged from bsp-imx27ads-rel2 branch of opensource.freescale.com/pub/scm/linux-2.6-mx.git
# Signed-off-by: Pavel Kiryukhin <pkiryukhin@ru.mvista.com>
# Description:
#     V4L2 and OPL support for i.mx27ads board.
# 

PATCHNUM=124
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Source:  http://opensource.freescale.com/pub/scm/linux-2.6-mx.git
MR: 24410
Type: Integration
Disposition: merged from bsp-imx27ads-rel2 branch of opensource.freescale.com/pub/scm/linux-2.6-mx.git
Signed-off-by: Pavel Kiryukhin <pkiryukhin@ru.mvista.com>
Description:
    V4L2 and OPL support for i.mx27ads board.

Index: linux-2.6.18/arch/arm/plat-mxc/Kconfig
===================================================================
--- linux-2.6.18.orig/arch/arm/plat-mxc/Kconfig
+++ linux-2.6.18/arch/arm/plat-mxc/Kconfig
@@ -8,6 +8,7 @@ choice
 
 config ARCH_MX2
 	bool "MX2-based"
+        select MXC_EMMA
 	select GENERIC_TIME
 	help
 	  This enables support for systems based on Freescale i.MX2x
@@ -18,4 +19,8 @@ source "arch/arm/mach-mx2/Kconfig"
 
 endmenu
 
+config MXC_EMMA
+        bool
+        depends on ARCH_MXC
+
 endif
Index: linux-2.6.18/drivers/media/video/Kconfig
===================================================================
--- linux-2.6.18.orig/drivers/media/video/Kconfig
+++ linux-2.6.18/drivers/media/video/Kconfig
@@ -96,6 +96,24 @@ config VIDEO_W9966
 	  Check out <file:Documentation/video4linux/w9966.txt> for more
 	  information.
 
+config VIDEO_MXC_CAMERA
+        tristate "MXC Video For Linux Camera"
+        depends on VIDEO_DEV && ARCH_MXC
+        default y
+        ---help---
+          This is the video4linux2 capture driver based on MXC IPU/eMMA module.
+
+source "drivers/media/video/mxc/capture/Kconfig"
+
+config VIDEO_MXC_OPL
+        tristate "ARM9-optimized OPL (Open Primitives Library)"
+        depends on VIDEO_DEV && ARCH_MXC
+        default n
+        ---help---
+          This is the ARM9-optimized OPL (Open Primitives Library) software
+          rotation/mirroring implementation. It may be used by eMMA video
+          capture or output device.
+
 config VIDEO_CPIA
 	tristate "CPiA Video For Linux"
 	depends on VIDEO_V4L1
Index: linux-2.6.18/drivers/media/video/Makefile
===================================================================
--- linux-2.6.18.orig/drivers/media/video/Makefile
+++ linux-2.6.18/drivers/media/video/Makefile
@@ -39,6 +39,9 @@ obj-$(CONFIG_VIDEO_PMS) += pms.o
 obj-$(CONFIG_VIDEO_PLANB) += planb.o
 obj-$(CONFIG_VIDEO_VINO) += vino.o saa7191.o indycam.o
 obj-$(CONFIG_VIDEO_STRADIS) += stradis.o
+obj-$(CONFIG_VIDEO_MXC_IPU_CAMERA) += mxc/capture/
+obj-$(CONFIG_VIDEO_MXC_EMMA_CAMERA) += mxc/capture/
+obj-$(CONFIG_VIDEO_MXC_OPL) += mxc/opl/
 obj-$(CONFIG_VIDEO_CPIA) += cpia.o
 obj-$(CONFIG_VIDEO_CPIA_PP) += cpia_pp.o
 obj-$(CONFIG_VIDEO_CPIA_USB) += cpia_usb.o
Index: linux-2.6.18/drivers/media/video/mxc/capture/Kconfig
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/media/video/mxc/capture/Kconfig
@@ -0,0 +1,39 @@
+if VIDEO_MXC_CAMERA
+
+menu "MXC Camera/V4L2 PRP Features support"
+
+config VIDEO_MXC_EMMA_CAMERA
+	tristate "MX27 eMMA support"
+	depends on VIDEO_MXC_CAMERA && MXC_EMMA && FB_MXC_SYNC_PANEL && (MXC_CAMERA_MICRON111 || MXC_CAMERA_MC521DA)
+	select VIDEO_MXC_OPL
+	default y
+
+config VIDEO_MXC_CSI_DMA
+	bool "CSI-DMA Still Image Capture support"
+	depends on VIDEO_MXC_EMMA_CAMERA
+	default n
+	---help---
+	  Use CSI-DMA method instead of CSI-PrP link to capture still image. This allows
+	  to use less physical contiguous memory to capture big resolution still image. But
+	  with this method the CSC (Color Space Conversion) and resize are not supported.
+	  If unsure, say N.
+
+choice
+	depends on (VIDEO_MXC_CAMERA && I2C_MXC)
+	prompt "Select Camera"
+	default MXC_CAMERA_MICRON111
+
+config MXC_CAMERA_MC521DA
+	bool "Magnachip mc521da camera support"
+	---help---
+	  If you plan to use the mc521da Camera with your MXC system, say Y here.
+
+config MXC_CAMERA_MICRON111
+	bool "Micron mt9v111 camera support"
+	---help---
+	  If you plan to use the mt9v111 Camera with your MXC system, say Y here.
+endchoice
+
+endmenu
+
+endif
Index: linux-2.6.18/drivers/media/video/mxc/capture/Makefile
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/media/video/mxc/capture/Makefile
@@ -0,0 +1,5 @@
+mx27_capture-objs := mx27_prphw.o mx27_prpsw.o mx27_v4l2_capture.o
+obj-$(CONFIG_VIDEO_MXC_EMMA_CAMERA) += mx27_csi.o mx27_capture.o
+
+mt9v111_camera-objs := mt9v111.o sensor_clock.o
+obj-$(CONFIG_MXC_CAMERA_MICRON111) += mt9v111_camera.o
Index: linux-2.6.18/drivers/media/video/mxc/capture/mt9v111.c
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/media/video/mxc/capture/mt9v111.c
@@ -0,0 +1,895 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mt9v111.c
+ *
+ * @brief mt9v111 camera driver functions
+ *
+ * @ingroup Camera
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/ctype.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <linux/clk.h>
+#include <asm/arch/mxc_i2c.h>
+#include "mxc_v4l2_capture.h"
+#include "mt9v111.h"
+
+#ifdef MT9V111_DEBUG
+static u16 testpattern = 0;
+#endif
+
+static sensor_interface *interface_param = NULL;
+static mt9v111_conf mt9v111_device;
+static int reset_frame_rate = 30;
+
+#define MT9V111_FRAME_RATE_NUM    20
+
+static mt9v111_image_format format[2] = {
+	{
+	 .index = 0,
+	 .width = 640,
+	 .height = 480,
+	 },
+	{
+	 .index = 1,
+	 .width = 352,
+	 .height = 288,
+	 },
+};
+
+static int mt9v111_attach(struct i2c_adapter *adapter);
+static int mt9v111_detach(struct i2c_client *client);
+
+static struct i2c_driver mt9v111_i2c_driver = {
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = "MT9V111 Client",
+		   },
+	.attach_adapter = mt9v111_attach,
+	.detach_client = mt9v111_detach,
+};
+
+static struct i2c_client mt9v111_i2c_client = {
+	.name = "mt9v111 I2C dev",
+	.addr = MT9V111_I2C_ADDRESS,
+	.driver = &mt9v111_i2c_driver,
+};
+
+/*
+ * Function definitions
+ */
+
+static int mt9v111_i2c_client_xfer(unsigned int addr, char *reg, int reg_len,
+				   char *buf, int num, int tran_flag)
+{
+	struct i2c_msg msg[2];
+	int ret;
+
+	msg[0].addr = addr;
+	msg[0].len = reg_len;
+	msg[0].buf = reg;
+	msg[0].flags = tran_flag;
+	msg[0].flags &= ~I2C_M_RD;
+
+	msg[1].addr = addr;
+	msg[1].len = num;
+	msg[1].buf = buf;
+	msg[1].flags = tran_flag;
+
+	if (tran_flag & MXC_I2C_FLAG_READ) {
+		msg[1].flags |= I2C_M_RD;
+	} else {
+		msg[1].flags &= ~I2C_M_RD;
+	}
+
+	ret = i2c_transfer(mt9v111_i2c_client.adapter, msg, 2);
+	if (ret >= 0)
+		return 0;
+
+	return ret;
+}
+
+static int mt9v111_read_reg(u8 * reg, u16 * val)
+{
+	return mt9v111_i2c_client_xfer(MT9V111_I2C_ADDRESS, reg, 1,
+				       (u8 *) val, 2, MXC_I2C_FLAG_READ);
+}
+
+static int mt9v111_write_reg(u8 reg, u16 val)
+{
+	u8 temp1;
+	u16 temp2;
+	temp1 = reg;
+	temp2 = cpu_to_be16(val);
+	pr_debug("write reg %x val %x.\n", reg, val);
+	return mt9v111_i2c_client_xfer(MT9V111_I2C_ADDRESS, &temp1, 1,
+				       (u8 *) & temp2, 2, 0);
+}
+
+/*!
+ * Initialize mt9v111_sensor_lib
+ * Libarary for Sensor configuration through I2C
+ *
+ * @param       coreReg       Core Registers
+ * @param       ifpReg        IFP Register
+ *
+ * @return status
+ */
+static u8 mt9v111_sensor_lib(mt9v111_coreReg * coreReg, mt9v111_IFPReg * ifpReg)
+{
+	u8 reg;
+	u16 data;
+	u8 error = 0;
+
+	/*
+	 * setup to IFP registers
+	 */
+	reg = MT9V111I_ADDR_SPACE_SEL;
+	data = ifpReg->addrSpaceSel;
+	mt9v111_write_reg(reg, data);
+
+	// Operation Mode Control
+	reg = MT9V111I_MODE_CONTROL;
+	data = ifpReg->modeControl;
+	mt9v111_write_reg(reg, data);
+
+	// Output format
+	reg = MT9V111I_FORMAT_CONTROL;
+	data = ifpReg->formatControl;	// Set bit 12
+	mt9v111_write_reg(reg, data);
+
+	// Flicker Control
+	reg = MT9V111I_FLICKER_CONTROL;
+	data = ifpReg->flickerCtrl;
+	mt9v111_write_reg(reg, data);
+
+	// AE limit 4
+	reg = MT9V111I_SHUTTER_WIDTH_LIMIT_AE;
+	data = ifpReg->gainLimitAE;
+	mt9v111_write_reg(reg, data);
+
+	reg = MT9V111I_OUTPUT_FORMAT_CTRL2;
+	data = ifpReg->outputFormatCtrl2;
+	mt9v111_write_reg(reg, data);
+
+	reg = MT9V111I_AE_SPEED;
+	data = ifpReg->AESpeed;
+	mt9v111_write_reg(reg, data);
+
+	/* output image size */
+	reg = MT9V111i_H_PAN;
+	data = 0x8000 | ifpReg->HPan;
+	mt9v111_write_reg(reg, data);
+
+	reg = MT9V111i_H_ZOOM;
+	data = 0x8000 | ifpReg->HZoom;
+	mt9v111_write_reg(reg, data);
+
+	reg = MT9V111i_H_SIZE;
+	data = 0x8000 | ifpReg->HSize;
+	mt9v111_write_reg(reg, data);
+
+	reg = MT9V111i_V_PAN;
+	data = 0x8000 | ifpReg->VPan;
+	mt9v111_write_reg(reg, data);
+
+	reg = MT9V111i_V_ZOOM;
+	data = 0x8000 | ifpReg->VZoom;
+	mt9v111_write_reg(reg, data);
+
+	reg = MT9V111i_V_SIZE;
+	data = 0x8000 | ifpReg->VSize;
+	mt9v111_write_reg(reg, data);
+
+	reg = MT9V111i_H_PAN;
+	data = ~0x8000 & ifpReg->HPan;
+	mt9v111_write_reg(reg, data);
+#if 0
+	reg = MT9V111I_UPPER_SHUTTER_DELAY_LIM;
+	data = ifpReg->upperShutterDelayLi;
+	mt9v111_write_reg(reg, data);
+
+	reg = MT9V111I_SHUTTER_60;
+	data = ifpReg->shutter_width_60;
+	mt9v111_write_reg(reg, data);
+
+	reg = MT9V111I_SEARCH_FLICK_60;
+	data = ifpReg->search_flicker_60;
+	mt9v111_write_reg(reg, data);
+#endif
+
+	/*
+	 * setup to sensor core registers
+	 */
+	reg = MT9V111I_ADDR_SPACE_SEL;
+	data = coreReg->addressSelect;
+	mt9v111_write_reg(reg, data);
+
+	// enable changes and put the Sync bit on
+	reg = MT9V111S_OUTPUT_CTRL;
+	data = MT9V111S_OUTCTRL_SYNC | MT9V111S_OUTCTRL_CHIP_ENABLE | 0x3000;
+	mt9v111_write_reg(reg, data);
+
+	// min PIXCLK - Default
+	reg = MT9V111S_PIXEL_CLOCK_SPEED;
+	data = coreReg->pixelClockSpeed;
+	mt9v111_write_reg(reg, data);
+
+	//Setup image flipping / Dark rows / row/column skip
+	reg = MT9V111S_READ_MODE;
+	data = coreReg->readMode;
+	mt9v111_write_reg(reg, data);
+
+	//zoom 0
+	reg = MT9V111S_DIGITAL_ZOOM;
+	data = coreReg->digitalZoom;
+	mt9v111_write_reg(reg, data);
+
+	// min H-blank
+	reg = MT9V111S_HOR_BLANKING;
+	data = coreReg->horizontalBlanking;
+	mt9v111_write_reg(reg, data);
+
+	// min V-blank
+	reg = MT9V111S_VER_BLANKING;
+	data = coreReg->verticalBlanking;
+	mt9v111_write_reg(reg, data);
+
+	reg = MT9V111S_SHUTTER_WIDTH;
+	data = coreReg->shutterWidth;
+	mt9v111_write_reg(reg, data);
+
+	reg = MT9V111S_SHUTTER_DELAY;
+	data = ifpReg->upperShutterDelayLi;
+	mt9v111_write_reg(reg, data);
+
+	// changes become effective
+	reg = MT9V111S_OUTPUT_CTRL;
+	data = MT9V111S_OUTCTRL_CHIP_ENABLE | 0x3000;
+	mt9v111_write_reg(reg, data);
+
+	return error;
+}
+
+/*!
+ * mt9v111 sensor interface Initialization
+ * @param param            sensor_interface *
+ * @param width            u32
+ * @param height           u32
+ * @return  None
+ */
+static void mt9v111_interface(sensor_interface * param, u32 width, u32 height)
+{
+	param->Vsync_pol = 0x0;
+	param->clk_mode = 0x0;	//gated
+	param->pixclk_pol = 0x0;
+	param->data_width = 0x1;
+	param->data_pol = 0x0;
+	param->ext_vsync = 0x0;
+	param->Vsync_pol = 0x0;
+	param->Hsync_pol = 0x0;
+	param->width = width - 1;
+	param->height = height - 1;
+	param->pixel_fmt = IPU_PIX_FMT_UYVY;
+	param->mclk = 27000000;
+}
+
+/*!
+ * MT9V111 frame rate calculate
+ *
+ * @param frame_rate       int *
+ * @param mclk             int
+ * @return  None
+ */
+static void mt9v111_rate_cal(int *frame_rate, int mclk)
+{
+	int num_clock_per_row;
+	int max_rate = 0;
+
+	mt9v111_device.coreReg->horizontalBlanking = MT9V111_HORZBLANK_MIN;
+
+	num_clock_per_row = (format[0].width + 114 + MT9V111_HORZBLANK_MIN) * 2;
+	max_rate = mclk / (num_clock_per_row *
+			   (format[0].height + MT9V111_VERTBLANK_DEFAULT));
+
+	if ((*frame_rate > max_rate) || (*frame_rate == 0)) {
+		*frame_rate = max_rate;
+	}
+
+	mt9v111_device.coreReg->verticalBlanking
+	    = mclk / (*frame_rate * num_clock_per_row) - format[0].height;
+
+	reset_frame_rate = *frame_rate;
+}
+
+/*!
+ * MT9V111 sensor configuration
+ *
+ * @param frame_rate       int *
+ * @param high_quality     int
+ * @return  sensor_interface *
+ */
+sensor_interface *mt9v111_config(int *frame_rate, int high_quality)
+{
+	u32 out_width, out_height;
+
+	mt9v111_device.coreReg->addressSelect = MT9V111I_SEL_SCA;
+	mt9v111_device.ifpReg->addrSpaceSel = MT9V111I_SEL_IFP;
+
+	mt9v111_device.coreReg->windowHeight = MT9V111_WINHEIGHT;
+	mt9v111_device.coreReg->windowWidth = MT9V111_WINWIDTH;
+	mt9v111_device.coreReg->zoomColStart = 0;
+	mt9v111_device.coreReg->zomRowStart = 0;
+	mt9v111_device.coreReg->digitalZoom = 0x0;
+
+	mt9v111_device.coreReg->verticalBlanking = MT9V111_VERTBLANK_DEFAULT;
+	mt9v111_device.coreReg->horizontalBlanking = MT9V111_HORZBLANK_MIN;
+	mt9v111_device.coreReg->pixelClockSpeed = 0;
+	mt9v111_device.coreReg->readMode = 0xd0a1;
+
+	mt9v111_device.ifpReg->outputFormatCtrl2 = 0;
+	mt9v111_device.ifpReg->gainLimitAE = 0x300;
+	mt9v111_device.ifpReg->AESpeed = 0x80;
+
+	// here is the default value
+	mt9v111_device.ifpReg->formatControl = 0xc800;
+	mt9v111_device.ifpReg->modeControl = 0x708e;
+	mt9v111_device.ifpReg->awbSpeed = 0x4514;
+	mt9v111_device.ifpReg->flickerCtrl = 0x02;
+	mt9v111_device.coreReg->shutterWidth = 0xf8;
+
+	out_width = 640;
+	out_height = 480;
+
+	/*output size */
+	mt9v111_device.ifpReg->HPan = 0;
+	mt9v111_device.ifpReg->HZoom = 640;
+	mt9v111_device.ifpReg->HSize = out_width;
+	mt9v111_device.ifpReg->VPan = 0;
+	mt9v111_device.ifpReg->VZoom = 480;
+	mt9v111_device.ifpReg->VSize = out_height;
+
+	mt9v111_interface(interface_param, out_width, out_height);
+	set_mclk_rate(&interface_param->mclk);
+	mt9v111_rate_cal(frame_rate, interface_param->mclk);
+	mt9v111_sensor_lib(mt9v111_device.coreReg, mt9v111_device.ifpReg);
+
+	return interface_param;
+}
+
+/*!
+ * mt9v111 sensor set color configuration
+ *
+ * @param bright       int
+ * @param saturation   int
+ * @param red          int
+ * @param green        int
+ * @param blue         int
+ * @return  None
+ */
+static void
+mt9v111_set_color(int bright, int saturation, int red, int green, int blue)
+{
+	u8 reg;
+	u16 data;
+
+	switch (saturation) {
+	case 100:
+		mt9v111_device.ifpReg->awbSpeed = 0x4514;
+		break;
+	case 150:
+		mt9v111_device.ifpReg->awbSpeed = 0x6D14;
+		break;
+	case 75:
+		mt9v111_device.ifpReg->awbSpeed = 0x4D14;
+		break;
+	case 50:
+		mt9v111_device.ifpReg->awbSpeed = 0x5514;
+		break;
+	case 37:
+		mt9v111_device.ifpReg->awbSpeed = 0x5D14;
+		break;
+	case 25:
+		mt9v111_device.ifpReg->awbSpeed = 0x6514;
+		break;
+	default:
+		mt9v111_device.ifpReg->awbSpeed = 0x4514;
+		break;
+	}
+
+	reg = MT9V111I_ADDR_SPACE_SEL;
+	data = mt9v111_device.ifpReg->addrSpaceSel;
+	mt9v111_write_reg(reg, data);
+
+	// Operation Mode Control
+	reg = MT9V111I_AWB_SPEED;
+	data = mt9v111_device.ifpReg->awbSpeed;
+	mt9v111_write_reg(reg, data);
+}
+
+/*!
+ * mt9v111 sensor get color configuration
+ *
+ * @param bright       int *
+ * @param saturation   int *
+ * @param red          int *
+ * @param green        int *
+ * @param blue         int *
+ * @return  None
+ */
+static void
+mt9v111_get_color(int *bright, int *saturation, int *red, int *green, int *blue)
+{
+	*saturation = (mt9v111_device.ifpReg->awbSpeed & 0x3800) >> 11;
+	switch (*saturation) {
+	case 0:
+		*saturation = 100;
+		break;
+	case 1:
+		*saturation = 75;
+		break;
+	case 2:
+		*saturation = 50;
+		break;
+	case 3:
+		*saturation = 37;
+		break;
+	case 4:
+		*saturation = 25;
+		break;
+	case 5:
+		*saturation = 150;
+		break;
+	case 6:
+		*saturation = 0;
+		break;
+	default:
+		*saturation = 0;
+		break;
+	}
+}
+
+/*!
+ * mt9v111 sensor set AE measurement window mode configuration
+ *
+ * @param ae_mode      int
+ * @return  None
+ */
+static void mt9v111_set_ae_mode(int ae_mode)
+{
+	u8 reg;
+	u16 data;
+
+	mt9v111_device.ifpReg->modeControl &= 0xfff3;
+	mt9v111_device.ifpReg->modeControl |= (ae_mode & 0x03) << 2;
+
+	reg = MT9V111I_ADDR_SPACE_SEL;
+	data = mt9v111_device.ifpReg->addrSpaceSel;
+	mt9v111_write_reg(reg, data);
+
+	reg = MT9V111I_MODE_CONTROL;
+	data = mt9v111_device.ifpReg->modeControl;
+	mt9v111_write_reg(reg, data);
+}
+
+/*!
+ * mt9v111 sensor get AE measurement window mode configuration
+ *
+ * @param ae_mode      int *
+ * @return  None
+ */
+static void mt9v111_get_ae_mode(int *ae_mode)
+{
+	if (ae_mode != NULL) {
+		*ae_mode = (mt9v111_device.ifpReg->modeControl & 0xc) >> 2;
+	}
+}
+
+/*!
+ * mt9v111 sensor enable/disable AE
+ *
+ * @param active      int
+ * @return  None
+ */
+static void mt9v111_set_ae(int active)
+{
+	u8 reg;
+	u16 data;
+
+	mt9v111_device.ifpReg->modeControl &= 0xfff3;
+	mt9v111_device.ifpReg->modeControl |= (active & 0x01) << 14;
+
+	reg = MT9V111I_ADDR_SPACE_SEL;
+	data = mt9v111_device.ifpReg->addrSpaceSel;
+	mt9v111_write_reg(reg, data);
+
+	reg = MT9V111I_MODE_CONTROL;
+	data = mt9v111_device.ifpReg->modeControl;
+	mt9v111_write_reg(reg, data);
+}
+
+/*!
+ * mt9v111 sensor enable/disable auto white balance
+ *
+ * @param active      int
+ * @return  None
+ */
+static void mt9v111_set_awb(int active)
+{
+	u8 reg;
+	u16 data;
+
+	mt9v111_device.ifpReg->modeControl &= 0xfff3;
+	mt9v111_device.ifpReg->modeControl |= (active & 0x01) << 1;
+
+	reg = MT9V111I_ADDR_SPACE_SEL;
+	data = mt9v111_device.ifpReg->addrSpaceSel;
+	mt9v111_write_reg(reg, data);
+
+	reg = MT9V111I_MODE_CONTROL;
+	data = mt9v111_device.ifpReg->modeControl;
+	mt9v111_write_reg(reg, data);
+}
+
+/*!
+ * mt9v111 sensor set the flicker control
+ *
+ * @param control      int
+ * @return  None
+ */
+static void mt9v111_flicker_control(int control)
+{
+	u8 reg;
+	u16 data;
+
+	reg = MT9V111I_ADDR_SPACE_SEL;
+	data = mt9v111_device.ifpReg->addrSpaceSel;
+	mt9v111_write_reg(reg, data);
+
+	switch (control) {
+	case MT9V111_FLICKER_DISABLE:
+		mt9v111_device.ifpReg->formatControl &= ~(0x01 << 11);
+
+		reg = MT9V111I_FORMAT_CONTROL;
+		data = mt9v111_device.ifpReg->formatControl;
+		mt9v111_write_reg(reg, data);
+		break;
+
+	case MT9V111_FLICKER_MANUAL_50:
+		if (!(mt9v111_device.ifpReg->formatControl & (0x01 << 11))) {
+			mt9v111_device.ifpReg->formatControl |= (0x01 << 11);
+			reg = MT9V111I_FORMAT_CONTROL;
+			data = mt9v111_device.ifpReg->formatControl;
+			mt9v111_write_reg(reg, data);
+		}
+		mt9v111_device.ifpReg->flickerCtrl = 0x01;
+		reg = MT9V111I_FLICKER_CONTROL;
+		data = mt9v111_device.ifpReg->flickerCtrl;
+		mt9v111_write_reg(reg, data);
+		break;
+
+	case MT9V111_FLICKER_MANUAL_60:
+		if (!(mt9v111_device.ifpReg->formatControl & (0x01 << 11))) {
+			mt9v111_device.ifpReg->formatControl |= (0x01 << 11);
+			reg = MT9V111I_FORMAT_CONTROL;
+			data = mt9v111_device.ifpReg->formatControl;
+			mt9v111_write_reg(reg, data);
+		}
+		mt9v111_device.ifpReg->flickerCtrl = 0x03;
+		reg = MT9V111I_FLICKER_CONTROL;
+		data = mt9v111_device.ifpReg->flickerCtrl;
+		mt9v111_write_reg(reg, data);
+		break;
+
+	case MT9V111_FLICKER_AUTO_DETECTION:
+		if (!(mt9v111_device.ifpReg->formatControl & (0x01 << 11))) {
+			mt9v111_device.ifpReg->formatControl |= (0x01 << 11);
+			reg = MT9V111I_FORMAT_CONTROL;
+			data = mt9v111_device.ifpReg->formatControl;
+			mt9v111_write_reg(reg, data);
+		}
+		mt9v111_device.ifpReg->flickerCtrl = 0x10;
+		reg = MT9V111I_FLICKER_CONTROL;
+		data = mt9v111_device.ifpReg->flickerCtrl;
+		mt9v111_write_reg(reg, data);
+		break;
+	}
+	return;
+
+}
+
+/*!
+ * mt9v111 Get mode&flicker control parameters
+ *
+ * @return  None
+ */
+static void mt9v111_get_control_params(int *ae, int *awb, int *flicker)
+{
+	if ((ae != NULL) && (awb != NULL) && (flicker != NULL)) {
+		*ae = (mt9v111_device.ifpReg->modeControl & 0x4000) >> 14;
+		*awb = (mt9v111_device.ifpReg->modeControl & 0x02) >> 1;
+		*flicker = (mt9v111_device.ifpReg->formatControl & 0x800) >> 9;
+		if (*flicker) {
+			*flicker = (mt9v111_device.ifpReg->flickerCtrl & 0x03);
+			switch (*flicker) {
+			case 1:
+				*flicker = MT9V111_FLICKER_MANUAL_50;
+				break;
+			case 3:
+				*flicker = MT9V111_FLICKER_MANUAL_60;
+				break;
+			default:
+				*flicker = MT9V111_FLICKER_AUTO_DETECTION;
+				break;
+			}
+		} else
+			*flicker = MT9V111_FLICKER_DISABLE;
+	}
+	return;
+}
+
+/*!
+ * mt9v111 Reset function
+ *
+ * @return  None
+ */
+static sensor_interface *mt9v111_reset(void)
+{
+	return mt9v111_config(&reset_frame_rate, 0);
+}
+
+/*!
+ * mt9v111 get_status function
+ *
+ * @return  int
+ */
+static int mt9v111_get_status(void)
+{
+	int retval = 0;
+	u8 reg;
+	u16 data = 0;
+
+	if (!interface_param)
+		return -ENODEV;
+
+	reg = MT9V111I_ADDR_SPACE_SEL;
+	data = MT9V111I_SEL_SCA;
+	retval = mt9v111_write_reg(reg, data);
+
+	reg = MT9V111S_SENSOR_CORE_VERSION;
+	retval = mt9v111_read_reg(&reg, &data);
+	data = cpu_to_be16(data);
+	if (MT9V111_CHIP_VERSION != data)
+		retval = -ENODEV;
+
+	return retval;
+}
+
+struct camera_sensor camera_sensor_if = {
+	.set_color = mt9v111_set_color,
+	.get_color = mt9v111_get_color,
+	.set_ae_mode = mt9v111_set_ae_mode,
+	.get_ae_mode = mt9v111_get_ae_mode,
+	.set_ae = mt9v111_set_ae,
+	.set_awb = mt9v111_set_awb,
+	.flicker_control = mt9v111_flicker_control,
+	.get_control_params = mt9v111_get_control_params,
+	.config = mt9v111_config,
+	.reset = mt9v111_reset,
+	.get_status = mt9v111_get_status,
+};
+
+#ifdef MT9V111_DEBUG
+/*!
+ * Set sensor to test mode, which will generate test pattern.
+ *
+ * @return none
+ */
+static void mt9v111_test_pattern(bool flag)
+{
+	u8 reg;
+	u16 data;
+
+	// switch to sensor registers
+	reg = MT9V111I_ADDR_SPACE_SEL;
+	data = MT9V111I_SEL_SCA;
+	mt9v111_write_reg(reg, data);
+
+	if (flag == true) {
+		testpattern = MT9V111S_OUTCTRL_TEST_MODE;
+
+		reg = MT9V111S_ROW_NOISE_CTRL;
+		data = mt9v111_read_reg(&reg, &data) & 0xBF;
+		data = cpu_to_be16(data);
+		mt9v111_write_reg(reg, data);
+
+		reg = MT9V111S_TEST_DATA;
+		data = 0;
+		mt9v111_write_reg(reg, data);
+
+		reg = MT9V111S_OUTPUT_CTRL;
+		// changes take effect
+		data = MT9V111S_OUTCTRL_CHIP_ENABLE | testpattern | 0x3000;
+		mt9v111_write_reg(reg, data);
+	} else {
+		testpattern = 0;
+
+		reg = MT9V111S_ROW_NOISE_CTRL;
+		data = mt9v111_read_reg(&reg, &data) | 0x40;
+		data = cpu_to_be16(data);
+		mt9v111_write_reg(reg, data);
+
+		reg = MT9V111S_OUTPUT_CTRL;
+		// changes take effect
+		data = MT9V111S_OUTCTRL_CHIP_ENABLE | testpattern | 0x3000;
+		mt9v111_write_reg(reg, data);
+	}
+}
+#endif
+
+/*!
+ * mt9v111 I2C detect_client function
+ *
+ * @param adapter            struct i2c_adapter *
+ * @param address            int
+ * @param kind               int
+ *
+ * @return  Error code indicating success or failure
+ */
+static int mt9v111_detect_client(struct i2c_adapter *adapter, int address,
+				 int kind)
+{
+	mt9v111_i2c_client.adapter = adapter;
+	if (i2c_attach_client(&mt9v111_i2c_client)) {
+		mt9v111_i2c_client.adapter = NULL;
+		printk(KERN_ERR "mt9v111_attach: i2c_attach_client failed\n");
+		return -1;
+	}
+
+	interface_param = (sensor_interface *)
+	    kmalloc(sizeof(sensor_interface), GFP_KERNEL);
+	if (!interface_param) {
+		printk(KERN_ERR "mt9v111_attach: kmalloc failed \n");
+		return -1;
+	}
+
+	printk(KERN_INFO "MT9V111 Detected\n");
+
+	return 0;
+}
+
+static unsigned short normal_i2c[] = { MT9V111_I2C_ADDRESS, I2C_CLIENT_END };
+
+/* Magic definition of all other variables and things */
+I2C_CLIENT_INSMOD;
+
+/*!
+ * mt9v111 I2C attach function
+ *
+ * @param adapter            struct i2c_adapter *
+ * @return  Error code indicating success or failure
+ */
+static int mt9v111_attach(struct i2c_adapter *adap)
+{
+	uint32_t mclk = 27000000;
+	struct clk *clk;
+	int err;
+
+	clk = clk_get(NULL, "csi_clk");
+	clk_enable(clk);
+	set_mclk_rate(&mclk);
+
+	err = i2c_probe(adap, &addr_data, &mt9v111_detect_client);
+	clk_disable(clk);
+	clk_put(clk);
+
+	return err;
+}
+
+/*!
+ * mt9v111 I2C detach function
+ *
+ * @param client            struct i2c_client *
+ * @return  Error code indicating success or failure
+ */
+static int mt9v111_detach(struct i2c_client *client)
+{
+	int err;
+
+	if (!mt9v111_i2c_client.adapter)
+		return -1;
+
+	err = i2c_detach_client(&mt9v111_i2c_client);
+	mt9v111_i2c_client.adapter = NULL;
+
+	if (interface_param)
+		kfree(interface_param);
+	interface_param = NULL;
+
+	return err;
+}
+
+extern void gpio_sensor_active(void);
+
+/*!
+ * MT9V111 init function
+ *
+ * @return  Error code indicating success or failure
+ */
+static __init int mt9v111_init(void)
+{
+	u8 err;
+
+	gpio_sensor_active();
+
+	mt9v111_device.coreReg = (mt9v111_coreReg *)
+	    kmalloc(sizeof(mt9v111_coreReg), GFP_KERNEL);
+	if (!mt9v111_device.coreReg)
+		return -1;
+
+	memset(mt9v111_device.coreReg, 0, sizeof(mt9v111_coreReg));
+
+	mt9v111_device.ifpReg = (mt9v111_IFPReg *)
+	    kmalloc(sizeof(mt9v111_IFPReg), GFP_KERNEL);
+	if (!mt9v111_device.ifpReg) {
+		kfree(mt9v111_device.coreReg);
+		mt9v111_device.coreReg = NULL;
+		return -1;
+	}
+
+	memset(mt9v111_device.ifpReg, 0, sizeof(mt9v111_IFPReg));
+
+	err = i2c_add_driver(&mt9v111_i2c_driver);
+	return err;
+}
+
+extern void gpio_sensor_inactive(void);
+/*!
+ * MT9V111 cleanup function
+ *
+ * @return  Error code indicating success or failure
+ */
+static void __exit mt9v111_clean(void)
+{
+	if (mt9v111_device.coreReg) {
+		kfree(mt9v111_device.coreReg);
+		mt9v111_device.coreReg = NULL;
+	}
+
+	if (mt9v111_device.ifpReg) {
+		kfree(mt9v111_device.ifpReg);
+		mt9v111_device.ifpReg = NULL;
+	}
+
+	i2c_del_driver(&mt9v111_i2c_driver);
+
+	gpio_sensor_inactive();
+}
+
+module_init(mt9v111_init);
+module_exit(mt9v111_clean);
+
+/* Exported symbols for modules. */
+EXPORT_SYMBOL(camera_sensor_if);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("Mt9v111 Camera Driver");
+MODULE_LICENSE("GPL");
Index: linux-2.6.18/drivers/media/video/mxc/capture/mt9v111.h
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/media/video/mxc/capture/mt9v111.h
@@ -0,0 +1,445 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup Camera Sensor Drivers
+ */
+
+/*!
+ * @file mt9v111.h
+ *
+ * @brief MT9V111 Camera Header file
+ *
+ * It include all the defines for bitmaps operations, also two main structure
+ * one for IFP interface structure, other for sensor core registers.
+ *
+ * @ingroup Camera
+ */
+
+#ifndef MT9V111_H_
+#define MT9V111_H_
+
+/*!
+ * mt9v111 CHIP VERSION
+ */
+#define MT9V111_CHIP_VERSION	0x823A
+
+/*!
+ * mt9v111 IFP REGISTER BANK MAP
+ */
+#define MT9V111I_ADDR_SPACE_SEL           0x1
+#define MT9V111I_BASE_MAXTRIX_SIGN        0x2
+#define MT9V111I_BASE_MAXTRIX_SCALE15     0x3
+#define MT9V111I_BASE_MAXTRIX_SCALE69     0x4
+#define MT9V111I_APERTURE_GAIN            0x5
+#define MT9V111I_MODE_CONTROL             0x6
+#define MT9V111I_SOFT_RESET               0x7
+#define MT9V111I_FORMAT_CONTROL           0x8
+#define MT9V111I_BASE_MATRIX_CFK1         0x9
+#define MT9V111I_BASE_MATRIX_CFK2         0xa
+#define MT9V111I_BASE_MATRIX_CFK3         0xb
+#define MT9V111I_BASE_MATRIX_CFK4         0xc
+#define MT9V111I_BASE_MATRIX_CFK5         0xd
+#define MT9V111I_BASE_MATRIX_CFK6         0xe
+#define MT9V111I_BASE_MATRIX_CFK7         0xf
+#define MT9V111I_BASE_MATRIX_CFK8         0x10
+#define MT9V111I_BASE_MATRIX_CFK9         0x11
+#define MT9V111I_AWB_POSITION             0x12
+#define MT9V111I_AWB_RED_GAIN             0x13
+#define MT9V111I_AWB_BLUE_GAIN            0x14
+#define MT9V111I_DELTA_MATRIX_CF_SIGN     0x15
+#define MT9V111I_DELTA_MATRIX_CF_D1       0x16
+#define MT9V111I_DELTA_MATRIX_CF_D2       0x17
+#define MT9V111I_DELTA_MATRIX_CF_D3       0x18
+#define MT9V111I_DELTA_MATRIX_CF_D4       0x19
+#define MT9V111I_DELTA_MATRIX_CF_D5       0x1a
+#define MT9V111I_DELTA_MATRIX_CF_D6       0x1b
+#define MT9V111I_DELTA_MATRIX_CF_D7       0x1c
+#define MT9V111I_DELTA_MATRIX_CF_D8       0x1d
+#define MT9V111I_DELTA_MATRIX_CF_D9       0x1e
+#define MT9V111I_LUMINANCE_LIMIT_WB       0x20
+#define MT9V111I_RBG_MANUUAL_WB           0x21
+#define MT9V111I_AWB_RED_LIMIT            0x22
+#define MT9V111I_AWB_BLUE_LIMIT           0x23
+#define MT9V111I_MATRIX_ADJUST_LIMIT      0x24
+#define MT9V111I_AWB_SPEED                0x25
+#define MT9V111I_H_BOUND_AE               0x26
+#define MT9V111I_V_BOUND_AE               0x27
+#define MT9V111I_H_BOUND_AE_CEN_WIN       0x2b
+#define MT9V111I_V_BOUND_AE_CEN_WIN       0x2c
+#define MT9V111I_BOUND_AWB_WIN            0x2d
+#define MT9V111I_AE_PRECISION_TARGET      0x2e
+#define MT9V111I_AE_SPEED                 0x2f
+#define MT9V111I_RED_AWB_MEASURE          0x30
+#define MT9V111I_LUMA_AWB_MEASURE         0x31
+#define MT9V111I_BLUE_AWB_MEASURE         0x32
+#define MT9V111I_LIMIT_SHARP_SATU_CTRL    0x33
+#define MT9V111I_LUMA_OFFSET              0x34
+#define MT9V111I_CLIP_LIMIT_OUTPUT_LUMI   0x35
+#define MT9V111I_GAIN_LIMIT_AE            0x36
+#define MT9V111I_SHUTTER_WIDTH_LIMIT_AE   0x37
+#define MT9V111I_UPPER_SHUTTER_DELAY_LIM  0x39
+#define MT9V111I_OUTPUT_FORMAT_CTRL2      0x3a
+#define MT9V111I_IPF_BLACK_LEVEL_SUB      0x3b
+#define MT9V111I_IPF_BLACK_LEVEL_ADD      0x3c
+#define MT9V111I_ADC_LIMIT_AE_ADJ         0x3d
+#define MT9V111I_GAIN_THRE_CCAM_ADJ       0x3e
+#define MT9V111I_LINEAR_AE                0x3f
+#define MT9V111I_THRESHOLD_EDGE_DEFECT    0x47
+#define MT9V111I_LUMA_SUM_MEASURE         0x4c
+#define MT9V111I_TIME_ADV_SUM_LUMA        0x4d
+#define MT9V111I_MOTION                   0x52
+#define MT9V111I_GAMMA_KNEE_Y12           0x53
+#define MT9V111I_GAMMA_KNEE_Y34           0x54
+#define MT9V111I_GAMMA_KNEE_Y56           0x55
+#define MT9V111I_GAMMA_KNEE_Y78           0x56
+#define MT9V111I_GAMMA_KNEE_Y90           0x57
+#define MT9V111I_GAMMA_VALUE_Y0           0x58
+#define MT9V111I_SHUTTER_60               0x59
+#define MT9V111I_FLICKER_CONTROL	  0x5B
+#define MT9V111I_SEARCH_FLICK_60          0x5c
+#define MT9V111I_RATIO_IMAGE_GAIN_BASE    0x5e
+#define MT9V111I_RATIO_IMAGE_GAIN_DELTA   0x5f
+#define MT9V111I_SIGN_VALUE_REG5F         0x60
+#define MT9V111I_AE_GAIN                  0x62
+#define MT9V111I_MAX_GAIN_AE              0x67
+#define MT9V111I_LENS_CORRECT_CTRL        0x80
+#define MT9V111I_SHADING_PARAMETER1       0x81
+#define MT9V111I_SHADING_PARAMETER2       0x82
+#define MT9V111I_SHADING_PARAMETER3       0x83
+#define MT9V111I_SHADING_PARAMETER4       0x84
+#define MT9V111I_SHADING_PARAMETER5       0x85
+#define MT9V111I_SHADING_PARAMETER6       0x86
+#define MT9V111I_SHADING_PARAMETER7       0x87
+#define MT9V111I_SHADING_PARAMETER8       0x88
+#define MT9V111I_SHADING_PARAMETER9       0x89
+#define MT9V111I_SHADING_PARAMETER10      0x8A
+#define MT9V111I_SHADING_PARAMETER11      0x8B
+#define MT9V111I_SHADING_PARAMETER12      0x8C
+#define MT9V111I_SHADING_PARAMETER13      0x8D
+#define MT9V111I_SHADING_PARAMETER14      0x8E
+#define MT9V111I_SHADING_PARAMETER15      0x8F
+#define MT9V111I_SHADING_PARAMETER16      0x90
+#define MT9V111I_SHADING_PARAMETER17      0x91
+#define MT9V111I_SHADING_PARAMETER18      0x92
+#define MT9V111I_SHADING_PARAMETER19      0x93
+#define MT9V111I_SHADING_PARAMETER20      0x94
+#define MT9V111I_SHADING_PARAMETER21      0x95
+#define MT9V111i_FLASH_CTRL               0x98
+#define MT9V111i_LINE_COUNTER             0x99
+#define MT9V111i_FRAME_COUNTER            0x9A
+#define MT9V111i_H_PAN                    0xA5
+#define MT9V111i_H_ZOOM                   0xA6
+#define MT9V111i_H_SIZE                   0xA7
+#define MT9V111i_V_PAN                    0xA8
+#define MT9V111i_V_ZOOM                   0xA9
+#define MT9V111i_V_SIZE                   0xAA
+
+#define MT9V111I_SEL_IFP                  0x1
+#define MT9V111I_SEL_SCA                  0x4
+#define MT9V111I_FC_RGB_OR_YUV            0x1000
+
+/*!
+ * Mt9v111 SENSOR CORE REGISTER BANK MAP
+ */
+#define MT9V111S_ADDR_SPACE_SEL           0x1
+#define MT9V111S_COLUMN_START             0x2
+#define MT9V111S_WIN_HEIGHT               0x3
+#define MT9V111S_WIN_WIDTH                0x4
+#define MT9V111S_HOR_BLANKING             0x5
+#define MT9V111S_VER_BLANKING             0x6
+#define MT9V111S_OUTPUT_CTRL              0x7
+#define MT9V111S_ROW_START                0x8
+#define MT9V111S_SHUTTER_WIDTH            0x9
+#define MT9V111S_PIXEL_CLOCK_SPEED        0xa
+#define MT9V111S_RESTART                  0xb
+#define MT9V111S_SHUTTER_DELAY            0xc
+#define MT9V111S_RESET                    0xd
+#define MT9V111S_COLUMN_START_IN_ZOOM     0x12
+#define MT9V111S_ROW_START_IN_ZOOM        0x13
+#define MT9V111S_DIGITAL_ZOOM             0x1e
+#define MT9V111S_READ_MODE                0x20
+#define MT9V111S_DAC_CTRL                 0x27
+#define MT9V111S_GREEN1_GAIN              0x2b
+#define MT9V111S_BLUE_GAIN                0x2c
+#define MT9V111S_READ_GAIN                0x2d
+#define MT9V111S_GREEN2_GAIN              0x2e
+#define MT9V111S_ROW_NOISE_CTRL           0x30
+#define MT9V111S_DARK_TARGET_W            0x31
+#define MT9V111S_TEST_DATA                0x32
+#define MT9V111S_GLOBAL_GAIN              0x35
+#define MT9V111S_SENSOR_CORE_VERSION      0x36
+#define MT9V111S_DARK_TARGET_WO           0x37
+#define MT9V111S_VERF_DAC                 0x41
+#define MT9V111S_VCM_VCL                  0x42
+#define MT9V111S_DISABLE_BYPASS           0x58
+#define MT9V111S_CALIB_MEAN_TEST          0x59
+#define MT9V111S_DARK_G1_AVE              0x5B
+#define MT9V111S_DARK_G2_AVE              0x5C
+#define MT9V111S_DARK_R_AVE               0x5D
+#define MT9V111S_DARK_B_AVE               0x5E
+#define MT9V111S_CAL_THRESHOLD            0x5f
+#define MT9V111S_CAL_G1                   0x60
+#define MT9V111S_CAL_G2                   0x61
+#define MT9V111S_CAL_CTRL                 0x62
+#define MT9V111S_CAL_R                    0x63
+#define MT9V111S_CAL_B                    0x64
+#define MT9V111S_CHIP_ENABLE              0xF1
+#define MT9V111S_CHIP_VERSION             0xFF
+
+// OUTPUT_CTRL
+#define MT9V111S_OUTCTRL_SYNC             0x1
+#define MT9V111S_OUTCTRL_CHIP_ENABLE      0x2
+#define MT9V111S_OUTCTRL_TEST_MODE        0x40
+
+// READ_MODE
+#define MT9V111S_RM_NOBADFRAME            0x1
+#define MT9V111S_RM_NODESTRUCT            0x2
+#define MT9V111S_RM_COLUMNSKIP            0x4
+#define MT9V111S_RM_ROWSKIP               0x8
+#define MT9V111S_RM_BOOSTEDRESET          0x1000
+#define MT9V111S_RM_COLUMN_LATE           0x10
+#define MT9V111S_RM_ROW_LATE              0x80
+#define MT9V111S_RM_RIGTH_TO_LEFT         0x4000
+#define MT9V111S_RM_BOTTOM_TO_TOP         0x8000
+
+/*! I2C Slave Address */
+#define MT9V111_I2C_ADDRESS	0x48
+
+/*!
+ * The image resolution enum for the mt9v111 sensor
+ */
+typedef enum {
+	MT9V111_OutputResolution_VGA = 0,	/*!< VGA size */
+	MT9V111_OutputResolution_QVGA,	/*!< QVGA size */
+	MT9V111_OutputResolution_CIF,	/*!< CIF size */
+	MT9V111_OutputResolution_QCIF,	/*!< QCIF size */
+	MT9V111_OutputResolution_QQVGA,	/*!< QQVGA size */
+	MT9V111_OutputResolution_SXGA	/*!< SXGA size */
+} MT9V111_OutputResolution;
+
+/*!
+ * The flicker control setting
+ */
+enum {
+	MT9V111_FLICKER_DISABLE = 0,
+	MT9V111_FLICKER_MANUAL_50,
+	MT9V111_FLICKER_MANUAL_60,
+	MT9V111_FLICKER_AUTO_DETECTION
+};
+
+enum {
+	MT9V111_WINWIDTH = 0x287,
+	MT9V111_WINWIDTH_DEFAULT = 0x287,
+	MT9V111_WINWIDTH_MIN = 0x9,
+
+	MT9V111_WINHEIGHT = 0x1E7,
+	MT9V111_WINHEIGHT_DEFAULT = 0x1E7,
+
+	MT9V111_HORZBLANK_DEFAULT = 0x26,
+	MT9V111_HORZBLANK_MIN = 0x9,
+	MT9V111_HORZBLANK_MAX = 0x3FF,
+
+	MT9V111_VERTBLANK_DEFAULT = 0x4,
+	MT9V111_VERTBLANK_MIN = 0x3,
+	MT9V111_VERTBLANK_MAX = 0xFFF,
+};
+
+/*!
+ * Mt9v111 Core Register structure.
+ */
+typedef struct {
+	u32 addressSelect;	/*!< select address bank for Core Register 0x4 */
+	u32 columnStart;	/*!< Starting Column */
+	u32 windowHeight;	/*!< Window Height */
+	u32 windowWidth;	/*!< Window Width */
+	u32 horizontalBlanking;	/*!< Horizontal Blank time, in pixels */
+	u32 verticalBlanking;	/*!< Vertical Blank time, in pixels */
+	u32 outputControl;	/*!< Register to control sensor output */
+	u32 rowStart;		/*!< Starting Row */
+	u32 shutterWidth;
+	u32 pixelClockSpeed;	/*!< pixel date rate */
+	u32 restart;		/*!< Abandon the readout of current frame */
+	u32 shutterDelay;
+	u32 reset;		/*!< reset the sensor to the default mode */
+	u32 zoomColStart;	/*!< Column start in the Zoom mode */
+	u32 zomRowStart;	/*!< Row start in the Zoom mode */
+	u32 digitalZoom;	/*!< 1 means zoom by 2 */
+	u32 readMode;		/*!< Readmode: aspects of the readout of the sensor */
+	u32 dACStandbyControl;
+	u32 green1Gain;		/*!< Gain Settings */
+	u32 blueGain;
+	u32 redGain;
+	u32 green2Gain;
+	u32 rowNoiseControl;
+	u32 darkTargetwNC;
+	u32 testData;		/*!< test mode */
+	u32 globalGain;
+	u32 chipVersion;
+	u32 darkTargetwoNC;
+	u32 vREFDACs;
+	u32 vCMandVCL;
+	u32 disableBypass;
+	u32 calibMeanTest;
+	u32 darkG1average;
+	u32 darkG2average;
+	u32 darkRaverage;
+	u32 darkBaverage;
+	u32 calibThreshold;
+	u32 calibGreen1;
+	u32 calibGreen2;
+	u32 calibControl;
+	u32 calibRed;
+	u32 calibBlue;
+	u32 chipEnable;		/*!< Image core Registers written by image flow processor */
+} mt9v111_coreReg;
+
+/*!
+ * Mt9v111 IFP Register structure.
+ */
+typedef struct {
+	u32 addrSpaceSel;	/*!< select address bank for Core Register 0x1 */
+	u32 baseMaxtrixSign;	/*!< sign of coefficient for base color correction matrix */
+	u32 baseMaxtrixScale15;	/*!< scaling of color correction coefficient K1-5 */
+	u32 baseMaxtrixScale69;	/*!< scaling of color correction coefficient K6-9 */
+	u32 apertureGain;	/*!< sharpening */
+	u32 modeControl;	/*!< bit 7 CCIR656 sync codes are embedded in the image */
+	u32 softReset;		/*!< Image processing mode: 1 reset mode, 0 operational mode */
+	u32 formatControl;	/*!< bit12 1 for RGB565, 0 for YcrCb */
+	u32 baseMatrixCfk1;	/*!< K1 Color correction coefficient */
+	u32 baseMatrixCfk2;	/*!< K2 Color correction coefficient */
+	u32 baseMatrixCfk3;	/*!< K3 Color correction coefficient */
+	u32 baseMatrixCfk4;	/*!< K4 Color correction coefficient */
+	u32 baseMatrixCfk5;	/*!< K5 Color correction coefficient */
+	u32 baseMatrixCfk6;	/*!< K6 Color correction coefficient */
+	u32 baseMatrixCfk7;	/*!< K7 Color correction coefficient */
+	u32 baseMatrixCfk8;	/*!< K8 Color correction coefficient */
+	u32 baseMatrixCfk9;	/*!< K9 Color correction coefficient */
+	u32 awbPosition;	/*!< Current position of AWB color correction matrix */
+	u32 awbRedGain;		/*!< Current value of AWB red channel gain */
+	u32 awbBlueGain;	/*!< Current value of AWB blue channel gain */
+	u32 deltaMatrixCFSign;	/*!< Sign of coefficients of delta color correction matrix register */
+	u32 deltaMatrixCFD1;	/*!< D1 Delta coefficient */
+	u32 deltaMatrixCFD2;	/*!< D2 Delta coefficient */
+	u32 deltaMatrixCFD3;	/*!< D3 Delta coefficient */
+	u32 deltaMatrixCFD4;	/*!< D4 Delta coefficient */
+	u32 deltaMatrixCFD5;	/*!< D5 Delta coefficient */
+	u32 deltaMatrixCFD6;	/*!< D6 Delta coefficient */
+	u32 deltaMatrixCFD7;	/*!< D7 Delta coefficient */
+	u32 deltaMatrixCFD8;	/*!< D8 Delta coefficient */
+	u32 deltaMatrixCFD9;	/*!< D9 Delta coefficient */
+	u32 lumLimitWB;		/*!< Luminance range of pixels considered in WB statistics */
+	u32 RBGManualWB;	/*!< Red and Blue color channel gains for manual white balance */
+	u32 awbRedLimit;	/*!< Limits on Red channel gain adjustment through AWB */
+	u32 awbBlueLimit;	/*!< Limits on Blue channel gain adjustment through AWB */
+	u32 matrixAdjLimit;	/*!< Limits on color correction matrix adjustment through AWB */
+	u32 awbSpeed;		/*!< AWB speed and color saturation control */
+	u32 HBoundAE;		/*!< Horizontal boundaries of AWB measurement window */
+	u32 VBoundAE;		/*!< Vertical boundaries of AWB measurement window */
+	u32 HBoundAECenWin;	/*!< Horizontal boundaries of AE measurement window for backlight compensation */
+	u32 VBoundAECenWin;	/*!< Vertical boundaries of AE measurement window for backlight compensation */
+	u32 boundAwbWin;	/*!< Boundaries of AWB measurement window */
+	u32 AEPrecisionTarget;	/*!< Auto exposure target and precision control */
+	u32 AESpeed;		/*!< AE speed and sensitivity control register */
+	u32 redAWBMeasure;	/*!< Measure of the red channel value used by AWB */
+	u32 lumaAWBMeasure;	/*!< Measure of the luminance channel value used by AWB */
+	u32 blueAWBMeasure;	/*!< Measure of the blue channel value used by AWB */
+	u32 limitSharpSatuCtrl;	/*!< Automatic control of sharpness and color saturation */
+	u32 lumaOffset;		/*!< Luminance offset control (brightness control) */
+	u32 clipLimitOutputLumi;	/*!< Clipping limits for output luminance */
+	u32 gainLimitAE;	/*!< Imager gain limits for AE adjustment */
+	u32 shutterWidthLimitAE;	/*!< Shutter width (exposure time) limits for AE adjustment */
+	u32 upperShutterDelayLi;	/*!< Upper Shutter Delay Limit */
+	u32 outputFormatCtrl2;	/*!< Output Format Control 2
+				   00 = 16-bit RGB565.
+				   01 = 15-bit RGB555.
+				   10 = 12-bit RGB444x.
+				   11 = 12-bit RGBx444.       */
+	u32 ipfBlackLevelSub;	/*!< IFP black level subtraction */
+	u32 ipfBlackLevelAdd;	/*!< IFP black level addition */
+	u32 adcLimitAEAdj;	/*!< ADC limits for AE adjustment */
+	u32 agimnThreCamAdj;	/*!< Gain threshold for CCM adjustment */
+	u32 linearAE;
+	u32 thresholdEdgeDefect;	/*!< Edge threshold for interpolation and defect correction */
+	u32 lumaSumMeasure;	/*!< Luma measured by AE engine */
+	u32 timeAdvSumLuma;	/*!< Time-averaged luminance value tracked by auto exposure */
+	u32 motion;		/*!< 1 when motion is detected */
+	u32 gammaKneeY12;	/*!< Gamma knee points Y1 and Y2 */
+	u32 gammaKneeY34;	/*!< Gamma knee points Y3 and Y4 */
+	u32 gammaKneeY56;	/*!< Gamma knee points Y5 and Y6 */
+	u32 gammaKneeY78;	/*!< Gamma knee points Y7 and Y8 */
+	u32 gammaKneeY90;	/*!< Gamma knee points Y9 and Y10 */
+	u32 gammaKneeY0;	/*!< Gamma knee point Y0 */
+	u32 shutter_width_60;
+	u32 flickerCtrl;
+	u32 search_flicker_60;
+	u32 ratioImageGainBase;
+	u32 ratioImageGainDelta;
+	u32 signValueReg5F;
+	u32 aeGain;
+	u32 maxGainAE;
+	u32 lensCorrectCtrl;
+	u32 shadingParameter1;	/*!< Shade Parameters */
+	u32 shadingParameter2;
+	u32 shadingParameter3;
+	u32 shadingParameter4;
+	u32 shadingParameter5;
+	u32 shadingParameter6;
+	u32 shadingParameter7;
+	u32 shadingParameter8;
+	u32 shadingParameter9;
+	u32 shadingParameter10;
+	u32 shadingParameter11;
+	u32 shadingParameter12;
+	u32 shadingParameter13;
+	u32 shadingParameter14;
+	u32 shadingParameter15;
+	u32 shadingParameter16;
+	u32 shadingParameter17;
+	u32 shadingParameter18;
+	u32 shadingParameter19;
+	u32 shadingParameter20;
+	u32 shadingParameter21;
+	u32 flashCtrl;		/*!< Flash control */
+	u32 lineCounter;	/*!< Line counter */
+	u32 frameCounter;	/*!< Frame counter */
+	u32 HPan;		/*!< Horizontal pan in decimation */
+	u32 HZoom;		/*!< Horizontal zoom in decimation */
+	u32 HSize;		/*!< Horizontal output size iIn decimation */
+	u32 VPan;		/*!< Vertical pan in decimation */
+	u32 VZoom;		/*!< Vertical zoom in decimation */
+	u32 VSize;		/*!< Vertical output size in decimation */
+} mt9v111_IFPReg;
+
+/*!
+ * mt9v111 Config structure
+ */
+typedef struct {
+	mt9v111_coreReg *coreReg;	/*!< Sensor Core Register Bank */
+	mt9v111_IFPReg *ifpReg;	/*!< IFP Register Bank */
+} mt9v111_conf;
+
+typedef struct {
+	u8 index;
+	u16 width;
+	u16 height;
+} mt9v111_image_format;
+
+typedef struct {
+	u16 ae;
+	u16 awb;
+	u16 flicker;
+	u16 reserved;
+} mt9v111_ctrl_params;
+
+#endif				// MT9V111_H_
Index: linux-2.6.18/drivers/media/video/mxc/capture/mx27_csi.c
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/media/video/mxc/capture/mx27_csi.c
@@ -0,0 +1,333 @@
+/*
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mx27_csi.c
+ *
+ * @brief CMOS Sensor interface functions
+ *
+ * @ingroup CSI
+ */
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/hardware.h>
+#include <asm/io.h>
+
+#include "mx27_csi.h"
+
+static csi_config_t g_csi_cfg;	/* csi hardware configuration */
+static bool gcsi_mclk_on = false;
+static csi_irq_callback_t g_callback = 0;
+static void *g_callback_data = 0;
+static struct clk csi_mclk;
+
+static irqreturn_t csi_irq_handler(int irq, void *data, struct pt_regs *regs)
+{
+	unsigned long status = __raw_readl(CSI_CSISR);
+
+	__raw_writel(status, CSI_CSISR);
+	if (g_callback)
+		g_callback(g_callback_data, status);
+
+	pr_debug("CSI status = 0x%08lX\n", status);
+
+	return IRQ_HANDLED;
+}
+
+static void csihw_set_config(csi_config_t * cfg)
+{
+	unsigned val = 0;
+
+	/* control reg 1 */
+	val |= cfg->swap16_en ? BIT_SWAP16_EN : 0;
+	val |= cfg->ext_vsync ? BIT_EXT_VSYNC : 0;
+	val |= cfg->eof_int_en ? BIT_EOF_INT_EN : 0;
+	val |= cfg->prp_if_en ? BIT_PRP_IF_EN : 0;
+	val |= cfg->ccir_mode ? BIT_CCIR_MODE : 0;
+	val |= cfg->cof_int_en ? BIT_COF_INT_EN : 0;
+	val |= cfg->sf_or_inten ? BIT_SF_OR_INTEN : 0;
+	val |= cfg->rf_or_inten ? BIT_RF_OR_INTEN : 0;
+	val |= cfg->statff_level << SHIFT_STATFF_LEVEL;
+	val |= cfg->staff_inten ? BIT_STATFF_INTEN : 0;
+	val |= cfg->rxff_level << SHIFT_RXFF_LEVEL;
+	val |= cfg->rxff_inten ? BIT_RXFF_INTEN : 0;
+	val |= cfg->sof_pol ? BIT_SOF_POL : 0;
+	val |= cfg->sof_inten ? BIT_SOF_INTEN : 0;
+	val |= cfg->mclkdiv << SHIFT_MCLKDIV;
+	val |= cfg->hsync_pol ? BIT_HSYNC_POL : 0;
+	val |= cfg->ccir_en ? BIT_CCIR_EN : 0;
+	val |= cfg->mclken ? BIT_MCLKEN : 0;
+	val |= cfg->fcc ? BIT_FCC : 0;
+	val |= cfg->pack_dir ? BIT_PACK_DIR : 0;
+	val |= cfg->gclk_mode ? BIT_GCLK_MODE : 0;
+	val |= cfg->inv_data ? BIT_INV_DATA : 0;
+	val |= cfg->inv_pclk ? BIT_INV_PCLK : 0;
+	val |= cfg->redge ? BIT_REDGE : 0;
+
+	__raw_writel(val, CSI_CSICR1);
+
+	/* control reg 3 */
+	val = 0x0;
+	val |= cfg->csi_sup ? BIT_CSI_SUP : 0;
+	val |= cfg->zero_pack_en ? BIT_ZERO_PACK_EN : 0;
+	val |= cfg->ecc_int_en ? BIT_ECC_INT_EN : 0;
+	val |= cfg->ecc_auto_en ? BIT_ECC_AUTO_EN : 0;
+
+	__raw_writel(val, CSI_CSICR3);
+
+	/* rxfifo counter */
+	__raw_writel(cfg->rxcnt, CSI_CSIRXCNT);
+
+	/* update global config */
+	memcpy(&g_csi_cfg, cfg, sizeof(csi_config_t));
+}
+
+static void csihw_reset_frame_count(void)
+{
+	__raw_writel(__raw_readl(CSI_CSICR3) | BIT_FRMCNT_RST, CSI_CSICR3);
+}
+
+static void csihw_reset(void)
+{
+	csihw_reset_frame_count();
+	__raw_writel(CSICR1_RESET_VAL, CSI_CSICR1);
+	__raw_writel(CSICR2_RESET_VAL, CSI_CSICR2);
+	__raw_writel(CSICR3_RESET_VAL, CSI_CSICR3);
+}
+
+/*!
+ * csi_init_interface
+ *    Sets initial values for the CSI registers.
+ *    The width and height of the sensor and the actual frame size will be
+ *    set to the same values.
+ * @param       width        Sensor width
+ * @param       height       Sensor height
+ * @param       pixel_fmt    pixel format
+ * @param       sig          csi_signal_cfg_t
+ *
+ * @return      0 for success, -EINVAL for error
+ */
+int32_t csi_init_interface(uint16_t width, uint16_t height,
+			   uint32_t pixel_fmt, csi_signal_cfg_t sig)
+{
+	csi_config_t cfg;
+
+	/* Set the CSI_SENS_CONF register remaining fields */
+	cfg.swap16_en = 1;
+	cfg.ext_vsync = sig.ext_vsync;
+	cfg.eof_int_en = 0;
+	cfg.prp_if_en = 1;
+	cfg.ccir_mode = 0;
+	cfg.cof_int_en = 0;
+	cfg.sf_or_inten = 0;
+	cfg.rf_or_inten = 0;
+	cfg.statff_level = 0;
+	cfg.staff_inten = 0;
+	cfg.rxff_level = 2;
+	cfg.rxff_inten = 0;
+	cfg.sof_pol = 1;
+	cfg.sof_inten = 0;
+	cfg.mclkdiv = 0;
+	cfg.hsync_pol = 1;
+	cfg.ccir_en = 0;
+	cfg.mclken = gcsi_mclk_on ? 1 : 0;
+	cfg.fcc = 1;
+	cfg.pack_dir = 0;
+	cfg.gclk_mode = 1;
+	cfg.inv_data = sig.data_pol;
+	cfg.inv_pclk = sig.pixclk_pol;
+	cfg.redge = 1;
+	cfg.csicnt1_rsv = 0;
+
+	/* control reg 3 */
+	cfg.frmcnt = 0;
+	cfg.frame_reset = 0;
+	cfg.csi_sup = 0;
+	cfg.zero_pack_en = 0;
+	cfg.ecc_int_en = 0;
+	cfg.ecc_auto_en = 0;
+
+	csihw_set_config(&cfg);
+
+	return 0;
+}
+
+/*!
+ * csi_enable_prpif
+ *    Enable or disable CSI-PrP interface
+ * @param       enable        Non-zero to enable, zero to disable
+ */
+void csi_enable_prpif(uint32_t enable)
+{
+	if (enable) {
+		g_csi_cfg.prp_if_en = 1;
+		g_csi_cfg.sof_inten = 0;
+		g_csi_cfg.pack_dir = 0;
+	} else {
+		g_csi_cfg.prp_if_en = 0;
+		g_csi_cfg.sof_inten = 1;
+		g_csi_cfg.pack_dir = 1;
+	}
+
+	csihw_set_config(&g_csi_cfg);
+}
+
+/*!
+ * csi_enable_mclk
+ *
+ * @param       src         enum define which source to control the clk
+ *                          CSI_MCLK_VF CSI_MCLK_ENC CSI_MCLK_RAW CSI_MCLK_I2C
+ * @param       flag        true to enable mclk, false to disable mclk
+ * @param       wait        true to wait 100ms make clock stable, false not wait
+ *
+ * @return      0 for success
+ */
+int32_t csi_enable_mclk(int src, bool flag, bool wait)
+{
+	if (flag == true) {
+		clk_enable(&csi_mclk);
+		if (wait == true)
+			msleep(10);
+		pr_debug("Enable csi clock from source %d\n", src);
+		gcsi_mclk_on = true;
+	} else {
+		clk_disable(&csi_mclk);
+		pr_debug("Disable csi clock from source %d\n", src);
+		gcsi_mclk_on = false;
+	}
+
+	return 0;
+}
+
+/*!
+ * csi_read_mclk_flag
+ *
+ * @return  0
+ */
+int csi_read_mclk_flag(void)
+{
+	return 0;
+}
+
+void csi_set_callback(csi_irq_callback_t callback, void *data)
+{
+	g_callback = callback;
+	g_callback_data = data;
+}
+
+static void _mclk_recalc(struct clk *clk)
+{
+	u32 div;
+
+	div = (__raw_readl(CSI_CSICR1) & BIT_MCLKDIV) >> SHIFT_MCLKDIV;
+	div = (div + 1) * 2;
+
+	clk->rate = clk->parent->rate / div;
+}
+
+static unsigned long _mclk_round_rate(struct clk *clk, unsigned long rate)
+{
+	/* Keep CSI divider and change parent clock */
+	if (clk->parent->round_rate) {
+		return clk->parent->round_rate(clk->parent, rate * 2);
+	}
+	return 0;
+}
+
+static int _mclk_set_rate(struct clk *clk, unsigned long rate)
+{
+	int ret = -EINVAL;
+
+	/* Keep CSI divider and change parent clock */
+	if (clk->parent->set_rate) {
+		ret = clk->parent->set_rate(clk->parent, rate * 2);
+		if (ret == 0) {
+			clk->rate = clk->parent->rate / 2;
+		}
+	}
+
+	return ret;
+}
+
+static int _mclk_enable(struct clk *clk)
+{
+	__raw_writel(__raw_readl(CSI_CSICR1) | BIT_MCLKEN, CSI_CSICR1);
+	return 0;
+}
+
+static void _mclk_disable(struct clk *clk)
+{
+	__raw_writel(__raw_readl(CSI_CSICR1) & ~BIT_MCLKEN, CSI_CSICR1);
+}
+
+static struct clk csi_mclk = {
+	.name = "csi_clk",
+	.recalc = _mclk_recalc,
+	.round_rate = _mclk_round_rate,
+	.set_rate = _mclk_set_rate,
+	.enable = _mclk_enable,
+	.disable = _mclk_disable,
+};
+
+int32_t __init csi_init_module(void)
+{
+	int ret = 0;
+	struct clk *per_clk;
+
+	per_clk = clk_get(NULL, "csi_perclk");
+	if (IS_ERR(per_clk))
+		return PTR_ERR(per_clk);
+	clk_put(per_clk);
+	csi_mclk.parent = per_clk;
+	clk_register(&csi_mclk);
+	clk_enable(per_clk);
+	csi_mclk.recalc(&csi_mclk);
+
+	csihw_reset();
+
+	/* interrupt enable */
+	ret = request_irq(MXC_INT_CSI, csi_irq_handler, 0, "csi", 0);
+	if (ret)
+		pr_debug("CSI error: irq request fail\n");
+
+	return ret;
+}
+
+void __exit csi_cleanup_module(void)
+{
+	/* free irq */
+	free_irq(MXC_INT_CSI, 0);
+
+	clk_disable(&csi_mclk);
+}
+
+module_init(csi_init_module);
+module_exit(csi_cleanup_module);
+
+EXPORT_SYMBOL(csi_init_interface);
+EXPORT_SYMBOL(csi_enable_mclk);
+EXPORT_SYMBOL(csi_read_mclk_flag);
+EXPORT_SYMBOL(csi_set_callback);
+EXPORT_SYMBOL(csi_enable_prpif);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MX27 CSI driver");
+MODULE_LICENSE("GPL");
Index: linux-2.6.18/drivers/media/video/mxc/capture/mx27_csi.h
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/media/video/mxc/capture/mx27_csi.h
@@ -0,0 +1,165 @@
+/*
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mx27_csi.h
+ *
+ * @brief CMOS Sensor interface functions
+ *
+ * @ingroup CSI
+ */
+
+#ifndef MX27_CSI_H
+#define MX27_CSI_H
+
+/* reset values */
+#define CSICR1_RESET_VAL	0x40000800
+#define CSICR2_RESET_VAL	0x0
+#define CSICR3_RESET_VAL	0x0
+
+/* csi control reg 1 */
+#define BIT_SWAP16_EN		(0x1 << 31)
+#define BIT_EXT_VSYNC		(0x1 << 30)
+#define BIT_EOF_INT_EN		(0x1 << 29)
+#define BIT_PRP_IF_EN		(0x1 << 28)
+#define BIT_CCIR_MODE		(0x1 << 27)
+#define BIT_COF_INT_EN		(0x1 << 26)
+#define BIT_SF_OR_INTEN		(0x1 << 25)
+#define BIT_RF_OR_INTEN		(0x1 << 24)
+#define BIT_STATFF_LEVEL	(0x3 << 22)
+#define BIT_STATFF_INTEN	(0x1 << 21)
+#define BIT_RXFF_LEVEL		(0x3 << 19)
+#define BIT_RXFF_INTEN		(0x1 << 18)
+#define BIT_SOF_POL		(0x1 << 17)
+#define BIT_SOF_INTEN		(0x1 << 16)
+#define BIT_MCLKDIV		(0xF << 12)
+#define BIT_HSYNC_POL		(0x1 << 11)
+#define BIT_CCIR_EN		(0x1 << 10)
+#define BIT_MCLKEN		(0x1 << 9)
+#define BIT_FCC			(0x1 << 8)
+#define BIT_PACK_DIR		(0x1 << 7)
+#define BIT_CLR_STATFIFO	(0x1 << 6)
+#define BIT_CLR_RXFIFO		(0x1 << 5)
+#define BIT_GCLK_MODE		(0x1 << 4)
+#define BIT_INV_DATA		(0x1 << 3)
+#define BIT_INV_PCLK		(0x1 << 2)
+#define BIT_REDGE		(0x1 << 1)
+
+#define SHIFT_STATFF_LEVEL	22
+#define SHIFT_RXFF_LEVEL	19
+#define SHIFT_MCLKDIV		12
+
+/* control reg 3 */
+#define BIT_FRMCNT		(0xFFFF << 16)
+#define BIT_FRMCNT_RST		(0x1 << 15)
+#define BIT_CSI_SUP		(0x1 << 3)
+#define BIT_ZERO_PACK_EN	(0x1 << 2)
+#define BIT_ECC_INT_EN		(0x1 << 1)
+#define BIT_ECC_AUTO_EN		(0x1)
+
+#define SHIFT_FRMCNT		16
+
+/* csi status reg */
+#define BIT_SFF_OR_INT		(0x1 << 25)
+#define BIT_RFF_OR_INT		(0x1 << 24)
+#define BIT_STATFF_INT		(0x1 << 21)
+#define BIT_RXFF_INT		(0x1 << 18)
+#define BIT_EOF_INT		(0x1 << 17)
+#define BIT_SOF_INT		(0x1 << 16)
+#define BIT_F2_INT		(0x1 << 15)
+#define BIT_F1_INT		(0x1 << 14)
+#define BIT_COF_INT		(0x1 << 13)
+#define BIT_ECC_INT		(0x1 << 1)
+#define BIT_DRDY		(0x1 << 0)
+
+#define CSI_MCLK_VF		1
+#define CSI_MCLK_ENC		2
+#define CSI_MCLK_RAW		4
+#define CSI_MCLK_I2C		8
+
+#define CSI_CSICR1		(IO_ADDRESS(CSI_BASE_ADDR))
+#define CSI_CSICR2		(IO_ADDRESS(CSI_BASE_ADDR + 0x4))
+#define CSI_CSISR		(IO_ADDRESS(CSI_BASE_ADDR + 0x8))
+#define CSI_STATFIFO		(IO_ADDRESS(CSI_BASE_ADDR + 0xC))
+#define CSI_CSIRXFIFO		(IO_ADDRESS(CSI_BASE_ADDR + 0x10))
+#define CSI_CSIRXCNT		(IO_ADDRESS(CSI_BASE_ADDR + 0x14))
+#define CSI_CSICR3		(IO_ADDRESS(CSI_BASE_ADDR + 0x1C))
+
+#define CSI_CSIRXFIFO_PHYADDR	(CSI_BASE_ADDR + 0x10)
+
+static __inline void csi_clear_status(unsigned long status)
+{
+	__raw_writel(status, CSI_CSISR);
+}
+
+typedef struct {
+	unsigned data_width:3;
+	unsigned clk_mode:2;
+	unsigned ext_vsync:1;
+	unsigned Vsync_pol:1;
+	unsigned Hsync_pol:1;
+	unsigned pixclk_pol:1;
+	unsigned data_pol:1;
+	unsigned sens_clksrc:1;
+} csi_signal_cfg_t;
+
+typedef struct {
+	/* control reg 1 */
+	unsigned int swap16_en:1;
+	unsigned int ext_vsync:1;
+	unsigned int eof_int_en:1;
+	unsigned int prp_if_en:1;
+	unsigned int ccir_mode:1;
+	unsigned int cof_int_en:1;
+	unsigned int sf_or_inten:1;
+	unsigned int rf_or_inten:1;
+	unsigned int statff_level:2;
+	unsigned int staff_inten:1;
+	unsigned int rxff_level:2;
+	unsigned int rxff_inten:1;
+	unsigned int sof_pol:1;
+	unsigned int sof_inten:1;
+	unsigned int mclkdiv:4;
+	unsigned int hsync_pol:1;
+	unsigned int ccir_en:1;
+	unsigned int mclken:1;
+	unsigned int fcc:1;
+	unsigned int pack_dir:1;
+	unsigned int gclk_mode:1;
+	unsigned int inv_data:1;
+	unsigned int inv_pclk:1;
+	unsigned int redge:1;
+	unsigned int csicnt1_rsv:1;
+
+	/* control reg 3 */
+	unsigned int frmcnt:16;
+	unsigned int frame_reset:1;
+	unsigned int csi_sup:1;
+	unsigned int zero_pack_en:1;
+	unsigned int ecc_int_en:1;
+	unsigned int ecc_auto_en:1;
+
+	/* fifo counter */
+	unsigned int rxcnt;
+} csi_config_t;
+
+typedef void (*csi_irq_callback_t) (void *data, unsigned long status);
+
+int32_t csi_enable_mclk(int src, bool flag, bool wait);
+int32_t csi_init_interface(uint16_t width, uint16_t height,
+			   uint32_t pixel_fmt, csi_signal_cfg_t sig);
+int csi_read_mclk_flag(void);
+void csi_set_callback(csi_irq_callback_t callback, void *data);
+void csi_enable_prpif(uint32_t enable);
+
+#endif
Index: linux-2.6.18/drivers/media/video/mxc/capture/mx27_prp.h
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/media/video/mxc/capture/mx27_prp.h
@@ -0,0 +1,308 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mx27_prp.h
+ *
+ * @brief Header file for MX27 V4L2 capture driver
+ *
+ * @ingroup MXC_V4L2_CAPTURE
+ */
+#ifndef __MX27_PRP_H__
+#define __MX27_PRP_H__
+
+#define PRP_REG(ofs)	(IO_ADDRESS(EMMA_BASE_ADDR) + ofs)
+
+/* Register definitions of PrP */
+#define PRP_CNTL			PRP_REG(0x00)
+#define PRP_INTRCNTL	 		PRP_REG(0x04)
+#define PRP_INTRSTATUS			PRP_REG(0x08)
+#define PRP_SOURCE_Y_PTR		PRP_REG(0x0C)
+#define PRP_SOURCE_CB_PTR		PRP_REG(0x10)
+#define PRP_SOURCE_CR_PTR		PRP_REG(0x14)
+#define PRP_DEST_RGB1_PTR		PRP_REG(0x18)
+#define PRP_DEST_RGB2_PTR		PRP_REG(0x1C)
+#define PRP_DEST_Y_PTR			PRP_REG(0x20)
+#define PRP_DEST_CB_PTR			PRP_REG(0x24)
+#define PRP_DEST_CR_PTR			PRP_REG(0x28)
+#define PRP_SOURCE_FRAME_SIZE  		PRP_REG(0x2C)
+#define PRP_CH1_LINE_STRIDE		PRP_REG(0x30)
+#define PRP_SRC_PIXEL_FORMAT_CNTL	PRP_REG(0x34)
+#define PRP_CH1_PIXEL_FORMAT_CNTL	PRP_REG(0x38)
+#define PRP_CH1_OUT_IMAGE_SIZE		PRP_REG(0x3C)
+#define PRP_CH2_OUT_IMAGE_SIZE		PRP_REG(0x40)
+#define PRP_SOURCE_LINE_STRIDE		PRP_REG(0x44)
+#define PRP_CSC_COEF_012		PRP_REG(0x48)
+#define PRP_CSC_COEF_345		PRP_REG(0x4C)
+#define PRP_CSC_COEF_678		PRP_REG(0x50)
+#define PRP_CH1_RZ_HORI_COEF1		PRP_REG(0x54)
+#define PRP_CH1_RZ_HORI_COEF2		PRP_REG(0x58)
+#define PRP_CH1_RZ_HORI_VALID		PRP_REG(0x5C)
+#define PRP_CH1_RZ_VERT_COEF1		PRP_REG(0x60)
+#define PRP_CH1_RZ_VERT_COEF2		PRP_REG(0x64)
+#define PRP_CH1_RZ_VERT_VALID		PRP_REG(0x68)
+#define PRP_CH2_RZ_HORI_COEF1		PRP_REG(0x6C)
+#define PRP_CH2_RZ_HORI_COEF2		PRP_REG(0x70)
+#define PRP_CH2_RZ_HORI_VALID		PRP_REG(0x74)
+#define PRP_CH2_RZ_VERT_COEF1		PRP_REG(0x78)
+#define PRP_CH2_RZ_VERT_COEF2		PRP_REG(0x7C)
+#define PRP_CH2_RZ_VERT_VALID		PRP_REG(0x80)
+
+#define B_SET(b)			(1 << (b))
+
+/* Bit definitions for PrP control register */
+#define PRP_CNTL_RSTVAL			0x28
+#define PRP_CNTL_CH1EN			B_SET(0)
+#define PRP_CNTL_CH2EN			B_SET(1)
+#define PRP_CNTL_CSI			B_SET(2)
+#define PRP_CNTL_IN_32			B_SET(3)
+#define PRP_CNTL_IN_RGB			B_SET(4)
+#define PRP_CNTL_IN_YUV420		0
+#define PRP_CNTL_IN_YUV422		PRP_CNTL_IN_32
+#define PRP_CNTL_IN_RGB16		PRP_CNTL_IN_RGB
+#define PRP_CNTL_IN_RGB32		(PRP_CNTL_IN_RGB | PRP_CNTL_IN_32)
+#define PRP_CNTL_CH1_RGB8		0
+#define PRP_CNTL_CH1_RGB16		B_SET(5)
+#define PRP_CNTL_CH1_RGB32		B_SET(6)
+#define PRP_CNTL_CH1_YUV422		(B_SET(5) | B_SET(6))
+#define PRP_CNTL_CH2_YUV420		0
+#define PRP_CNTL_CH2_YUV422		B_SET(7)
+#define PRP_CNTL_CH2_YUV444		B_SET(8)
+#define PRP_CNTL_CH1_LOOP		B_SET(9)
+#define PRP_CNTL_CH2_LOOP		B_SET(10)
+#define PRP_CNTL_AUTODROP		B_SET(11)
+#define PRP_CNTL_RST			B_SET(12)
+#define PRP_CNTL_CNTREN			B_SET(13)
+#define PRP_CNTL_WINEN			B_SET(14)
+#define PRP_CNTL_UNCHAIN		B_SET(15)
+#define PRP_CNTL_IN_SKIP_NONE		0
+#define PRP_CNTL_IN_SKIP_1_2		B_SET(16)
+#define PRP_CNTL_IN_SKIP_1_3		B_SET(17)
+#define PRP_CNTL_IN_SKIP_2_3		(B_SET(16) | B_SET(17))
+#define PRP_CNTL_IN_SKIP_1_4		B_SET(18)
+#define PRP_CNTL_IN_SKIP_3_4		(B_SET(16) | B_SET(18))
+#define PRP_CNTL_IN_SKIP_2_5		(B_SET(17) | B_SET(18))
+#define PRP_CNTL_IN_SKIP_3_5		(B_SET(16) | B_SET(17) | B_SET(18))
+#define PRP_CNTL_CH1_SKIP_NONE		0
+#define PRP_CNTL_CH1_SKIP_1_2		B_SET(19)
+#define PRP_CNTL_CH1_SKIP_1_3		B_SET(20)
+#define PRP_CNTL_CH1_SKIP_2_3		(B_SET(19) | B_SET(20))
+#define PRP_CNTL_CH1_SKIP_1_4		B_SET(21)
+#define PRP_CNTL_CH1_SKIP_3_4		(B_SET(19) | B_SET(21))
+#define PRP_CNTL_CH1_SKIP_2_5		(B_SET(20) | B_SET(21))
+#define PRP_CNTL_CH1_SKIP_3_5		(B_SET(19) | B_SET(20) | B_SET(21))
+#define PRP_CNTL_CH2_SKIP_NONE		0
+#define PRP_CNTL_CH2_SKIP_1_2		B_SET(22)
+#define PRP_CNTL_CH2_SKIP_1_3		B_SET(23)
+#define PRP_CNTL_CH2_SKIP_2_3		(B_SET(22) | B_SET(23))
+#define PRP_CNTL_CH2_SKIP_1_4		B_SET(24)
+#define PRP_CNTL_CH2_SKIP_3_4		(B_SET(22) | B_SET(24))
+#define PRP_CNTL_CH2_SKIP_2_5		(B_SET(23) | B_SET(24))
+#define PRP_CNTL_CH2_SKIP_3_5		(B_SET(22) | B_SET(23) | B_SET(24))
+#define PRP_CNTL_FIFO_I128		0
+#define PRP_CNTL_FIFO_I96		B_SET(25)
+#define PRP_CNTL_FIFO_I64		B_SET(26)
+#define PRP_CNTL_FIFO_I32		(B_SET(25) | B_SET(26))
+#define PRP_CNTL_FIFO_O64		0
+#define PRP_CNTL_FIFO_O48		B_SET(27)
+#define PRP_CNTL_FIFO_O32		B_SET(28)
+#define PRP_CNTL_FIFO_O16		(B_SET(27) | B_SET(28))
+#define PRP_CNTL_CH2B1			B_SET(29)
+#define PRP_CNTL_CH2B2			B_SET(30)
+#define PRP_CNTL_CH2_FLOWEN		B_SET(31)
+
+/* Bit definitions for PrP interrupt control register */
+#define PRP_INTRCNTL_RDERR		B_SET(0)
+#define PRP_INTRCNTL_CH1WERR		B_SET(1)
+#define PRP_INTRCNTL_CH2WERR		B_SET(2)
+#define PRP_INTRCNTL_CH1FC		B_SET(3)
+#define PRP_INTRCNTL_CH2FC		B_SET(5)
+#define PRP_INTRCNTL_LBOVF		B_SET(7)
+#define PRP_INTRCNTL_CH2OVF		B_SET(8)
+
+/* Bit definitions for PrP interrupt status register */
+#define PRP_INTRSTAT_RDERR		B_SET(0)
+#define PRP_INTRSTAT_CH1WERR		B_SET(1)
+#define PRP_INTRSTAT_CH2WERR		B_SET(2)
+#define PRP_INTRSTAT_CH2BUF2		B_SET(3)
+#define PRP_INTRSTAT_CH2BUF1		B_SET(4)
+#define PRP_INTRSTAT_CH1BUF2		B_SET(5)
+#define PRP_INTRSTAT_CH1BUF1		B_SET(6)
+#define PRP_INTRSTAT_LBOVF		B_SET(7)
+#define PRP_INTRSTAT_CH2OVF		B_SET(8)
+
+#define PRP_CHANNEL_1		0x1
+#define PRP_CHANNEL_2		0x2
+
+/* PRP-CSI config */
+#define PRP_CSI_EN		0x80
+#define PRP_CSI_LOOP		(0x40 | PRP_CSI_EN)
+#define PRP_CSI_IRQ_FRM		(0x08 | PRP_CSI_LOOP)
+#define PRP_CSI_IRQ_CH1ERR	(0x10 | PRP_CSI_LOOP)
+#define PRP_CSI_IRQ_CH2ERR	(0x20 | PRP_CSI_LOOP)
+#define PRP_CSI_IRQ_ALL		(0x38 | PRP_CSI_LOOP)
+#define PRP_CSI_SKIP_NONE	0
+#define PRP_CSI_SKIP_1OF2	1
+#define PRP_CSI_SKIP_1OF3	2
+#define PRP_CSI_SKIP_2OF3	3
+#define PRP_CSI_SKIP_1OF4	4
+#define PRP_CSI_SKIP_3OF4	5
+#define PRP_CSI_SKIP_2OF5	6
+#define PRP_CSI_SKIP_4OF5	7
+
+#define PRP_PIXIN_RGB565	0x2CA00565
+#define PRP_PIXIN_RGB888	0x41000888
+#define PRP_PIXIN_YUV420	0
+#define PRP_PIXIN_YUYV		0x22000888
+#define PRP_PIXIN_YVYU		0x20100888
+#define PRP_PIXIN_UYVY		0x03080888
+#define PRP_PIXIN_VYUY		0x01180888
+#define PRP_PIXIN_YUV422	0x62080888
+
+#define PRP_PIX1_RGB332		0x14400322
+#define PRP_PIX1_RGB565		0x2CA00565
+#define PRP_PIX1_RGB888		0x41000888
+#define PRP_PIX1_YUYV		0x62000888
+#define PRP_PIX1_YVYU		0x60100888
+#define PRP_PIX1_UYVY		0x43080888
+#define PRP_PIX1_VYUY		0x41180888
+#define PRP_PIX1_UNUSED		0
+
+#define PRP_PIX2_YUV420		0
+#define PRP_PIX2_YUV422		1
+#define PRP_PIX2_YUV444		4
+#define PRP_PIX2_UNUSED		8
+
+#define PRP_ALGO_WIDTH_ANY	0
+#define PRP_ALGO_HEIGHT_ANY	0
+#define PRP_ALGO_WIDTH_BIL	1
+#define PRP_ALGO_WIDTH_AVG	2
+#define PRP_ALGO_HEIGHT_BIL	4
+#define PRP_ALGO_HEIGHT_AVG	8
+#define PRP_ALGO_BYPASS		0x10
+
+typedef struct _emma_prp_ratio {
+	unsigned short num;
+	unsigned short den;
+} emma_prp_ratio;
+
+/*
+ * The following definitions are for resizing. Definition values must not
+ * be changed otherwise decision logic will be wrong.
+ */
+#define BC_COEF		3
+#define MAX_TBL		20
+#define SZ_COEF		(1 << BC_COEF)
+
+#define ALGO_AUTO	0
+#define ALGO_BIL	1
+#define ALGO_AVG	2
+
+typedef struct {
+	char tbl[20];		/* table entries */
+	char len;		/* table length used */
+	char algo;		/* ALGO_xxx */
+	char ratio[20];		/* ratios used */
+} scale_t;
+
+/*
+ * structure for prp scaling.
+ * algorithm - bilinear or averaging for each axis
+ * PRP_ALGO_WIDTH_x | PRP_ALGO_HEIGHT_x | PRP_ALGO_BYPASS
+ * PRP_ALGO_BYPASS - Ch1 will not use Ch2 scaling with this flag
+ */
+typedef struct _emma_prp_scale {
+	unsigned char algo;
+	emma_prp_ratio width;
+	emma_prp_ratio height;
+} emma_prp_scale;
+
+typedef struct emma_prp_cfg {
+	unsigned int in_pix;	/* PRP_PIXIN_xxx */
+	unsigned short in_width;	/* image width, 32 - 2044 */
+	unsigned short in_height;	/* image height, 32 - 2044 */
+	unsigned char in_csi;	/* PRP_CSI_SKIP_x | PRP_CSI_LOOP */
+	unsigned short in_line_stride;	/* in_line_stride and in_line_skip */
+	unsigned short in_line_skip;	/* allow cropping from CSI */
+	unsigned int in_ptr;	/* bus address */
+	/*
+	 * in_csc[9] = 1 -> Y-16
+	 * if in_csc[1..9] == 0
+	 *      in_csc[0] represents YUV range 0-3 = A0,A1,B0,B1;
+	 * else
+	 *      in_csc[0..9] represents either format
+	 */
+	unsigned short in_csc[10];
+
+	unsigned char ch2_pix;	/* PRP_PIX2_xxx */
+	emma_prp_scale ch2_scale;	/* resizing paramters */
+	unsigned short ch2_width;	/* 4-2044, 0 = scaled */
+	unsigned short ch2_height;	/* 4-2044, 0 = scaled */
+	unsigned int ch2_ptr;	/* bus addr */
+	unsigned int ch2_ptr2;	/* bus addr for 2nd buf (loop mode) */
+	unsigned char ch2_csi;	/* PRP_CSI_SKIP_x | PRP_CSI_LOOP */
+
+	unsigned int ch1_pix;	/* PRP_PIX1_xxx */
+	emma_prp_scale ch1_scale;	/* resizing parameters */
+	unsigned short ch1_width;	/* 4-2044, 0 = scaled */
+	unsigned short ch1_height;	/* 4-2044, 0 = scaled */
+	unsigned short ch1_stride;	/* 4-4088, 0 = ch1_width */
+	unsigned int ch1_ptr;	/* bus addr */
+	unsigned int ch1_ptr2;	/* bus addr for 2nd buf (loop mode) */
+	unsigned char ch1_csi;	/* PRP_CSI_SKIP_x | PRP_CSI_LOOP */
+
+	/*
+	 * channel resizing coefficients
+	 * scale[0] for channel 1 width
+	 * scale[1] for channel 1 height
+	 * scale[2] for channel 2 width
+	 * scale[3] for channel 2 height
+	 */
+	scale_t scale[4];
+} emma_prp_cfg;
+
+int prphw_reset(void);
+int prphw_enable(int channel);
+int prphw_disable(int channel);
+int prphw_inptr(emma_prp_cfg *);
+int prphw_ch1ptr(emma_prp_cfg *);
+int prphw_ch1ptr2(emma_prp_cfg *);
+int prphw_ch2ptr(emma_prp_cfg *);
+int prphw_ch2ptr2(emma_prp_cfg *);
+int prphw_cfg(emma_prp_cfg *);
+int prphw_isr(void);
+void prphw_init(void);
+void prphw_exit(void);
+
+/*
+ * scale	out	coefficient table
+ * din		in	scale numerator
+ * dout		in	scale denominator
+ * inv		in	pre-scale dimension
+ * vout		in/out	post-scale output dimension
+ * pout		out	post-scale internal dimension [opt]
+ * retry	in	retry times (round the output length) when need
+ */
+int prp_scale(scale_t * pscale, int din, int dout, int inv,
+	      unsigned short *vout, unsigned short *pout, int ch);
+
+int prp_init(void *dev_id);
+void prp_exit(void *dev_id);
+int prp_enc_select(void *data);
+int prp_enc_deselect(void *data);
+int prp_vf_select(void *data);
+int prp_vf_deselect(void *data);
+int prp_still_select(void *data);
+int prp_still_deselect(void *data);
+
+#endif				/* __MX27_PRP_H__ */
Index: linux-2.6.18/drivers/media/video/mxc/capture/mx27_prphw.c
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/media/video/mxc/capture/mx27_prphw.c
@@ -0,0 +1,1259 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mx27_prphw.c
+ *
+ * @brief MX27 Video For Linux 2 capture driver
+ *
+ * @ingroup MXC_V4L2_CAPTURE
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/clk.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+
+#include "mx27_prp.h"
+
+#define PRP_MIN_IN_WIDTH	32
+#define PRP_MAX_IN_WIDTH	2044
+#define PRP_MIN_IN_HEIGHT	32
+#define PRP_MAX_IN_HEIGHT	2044
+
+typedef struct _coeff_t {
+	unsigned long coeff[2];
+	unsigned long cntl;
+} coeff_t[2][2];
+
+static coeff_t *PRP_RSZ_COEFF = (coeff_t *) PRP_CH1_RZ_HORI_COEF1;
+
+static unsigned char scale_get(scale_t * t,
+			       unsigned char *i, unsigned char *out);
+static int gcd(int x, int y);
+static int ratio(int x, int y, int *den);
+static int prp_scale_bilinear(scale_t * t, int coeff, int base, int nxt);
+static int prp_scale_ave(scale_t * t, unsigned char base);
+static int ave_scale(scale_t * t, int inv, int outv);
+static int scale(scale_t * t, int inv, int outv);
+
+/*!
+ * @param t	table
+ * @param i	table index
+ * @param out	bilinear	# input pixels to advance
+ *		average		whether result is ready for output
+ * @return	coefficient
+*/
+static unsigned char scale_get(scale_t * t, unsigned char *i,
+			       unsigned char *out)
+{
+	unsigned char c;
+
+	c = t->tbl[*i];
+	(*i)++;
+	*i %= t->len;
+
+	if (out) {
+		if (t->algo == ALGO_BIL) {
+			for ((*out) = 1;
+			     (*i) && ((*i) < t->len) && !t->tbl[(*i)]; (*i)++) {
+				(*out)++;
+			}
+			if ((*i) == t->len)
+				(*i) = 0;
+		} else
+			*out = c >> BC_COEF;
+	}
+
+	c &= SZ_COEF - 1;
+
+	if (c == SZ_COEF - 1)
+		c = SZ_COEF;
+
+	return c;
+}
+
+/*!
+ * @brief Get maximum common divisor.
+ * @param x	First input value
+ * @param y	Second input value
+ * @return	Maximum common divisor of x and y
+ */
+static int gcd(int x, int y)
+{
+	int k;
+
+	if (x < y) {
+		k = x;
+		x = y;
+		y = k;
+	}
+
+	while ((k = x % y)) {
+		x = y;
+		y = k;
+	}
+
+	return y;
+}
+
+/*!
+ * @brief Get ratio.
+ * @param x	First input value
+ * @param y	Second input value
+ * @param den	Denominator of the ratio (corresponding to y)
+ * @return	Numerator of the ratio (corresponding to x)
+ */
+static int ratio(int x, int y, int *den)
+{
+	int g;
+
+	if (!x || !y)
+		return 0;
+
+	g = gcd(x, y);
+	*den = y / g;
+
+	return x / g;
+}
+
+/*!
+ * @brief Build PrP coefficient entry based on bilinear algorithm
+ *
+ * @param t	The pointer to scale_t structure
+ * @param coeff	The weighting coefficient
+ * @param base	The base of the coefficient
+ * @param nxt	Number of pixels to be read
+ *
+ * @return	The length of current coefficient table on success
+ *		-1 on failure
+ */
+static int prp_scale_bilinear(scale_t * t, int coeff, int base, int nxt)
+{
+	int i;
+
+	if (t->len >= sizeof(t->tbl))
+		return -1;
+
+	coeff = ((coeff << BC_COEF) + (base >> 1)) / base;
+	if (coeff >= SZ_COEF - 1)
+		coeff--;
+
+	coeff |= SZ_COEF;
+	t->tbl[(int)t->len++] = (unsigned char)coeff;
+
+	for (i = 1; i < nxt; i++) {
+		if (t->len >= MAX_TBL)
+			return -1;
+
+		t->tbl[(int)t->len++] = 0;
+	}
+
+	return t->len;
+}
+
+static const unsigned char c1[] = {7};
+
+static const unsigned char c2[] = {4, 4};
+
+static const unsigned char c3[] = {2, 4, 2};
+
+static const unsigned char c4[] = {2, 2, 2, 2};
+
+static const unsigned char c5[] = {1, 2, 2, 2, 1};
+
+static const unsigned char c6[] = {1, 1, 2, 2, 1, 1};
+
+static const unsigned char c7[] = {1, 1, 1, 2, 1, 1, 1};
+
+static const unsigned char c8[] = {1, 1, 1, 1, 1, 1, 1, 1};
+
+static const unsigned char c9[] = {1, 1, 1, 1, 1, 1, 1, 1, 0};
+
+static const unsigned char c10[] = {0, 1, 1, 1, 1, 1, 1, 1, 1, 0};
+
+static const unsigned char c11[] = {0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0};
+
+static const unsigned char c12[] = {0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0};
+
+static const unsigned char c13[] = {0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0};
+
+static const unsigned char c14[] = {0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0};
+
+static const unsigned char c15[] = {0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1,
+				    0};
+
+static const unsigned char c16[] = {1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
+				    1, 0};
+
+static const unsigned char c17[] = {0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
+				    0, 1, 0};
+
+static const unsigned char c18[] = {0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0,
+				    1, 0, 1, 0};
+
+static const unsigned char c19[] = {0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0,
+				    1, 0, 0, 1, 0};
+
+static const unsigned char c20[] = {0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1,
+				    0, 1, 0, 0, 1, 0};
+
+static const unsigned char *ave_coeff[] = {
+	c1, c2, c3, c4, c5, c6, c7, c8, c9, c10,
+	c11, c12, c13, c14, c15, c16, c17, c18, c19, c20
+};
+
+static const unsigned char coeftab[] = {
+	1, 1,
+	19, 20,
+	18, 19,
+	17, 18,
+	16, 17,
+	15, 16,
+	14, 15,
+	13, 14,
+	12, 13,
+	11, 12,
+	10, 11,
+	9, 10,
+	17, 19,
+	8, 9,
+	15, 17,
+	7, 8,
+	13, 15,
+	6, 7,
+	17, 20,
+	11, 13,
+	16, 19,
+	5, 6,
+	14, 17,
+	9, 11,
+	13, 16,
+	4, 5,
+	15, 19,
+	11, 14,
+	7, 9,
+	10, 13,
+	13, 17,
+	3, 4,
+	14, 19,
+	11, 15,
+	8, 11,
+	13, 18,
+	5, 7,
+	12, 17,
+	7, 10,
+	9, 13,
+	11, 16,
+	13, 19,
+	2, 3,
+	13, 20,
+	11, 17,
+	9, 14,
+	7, 11,
+	12, 19,
+	5, 8,
+	8, 13,
+	11, 18,
+	3, 5,
+	10, 17,
+	7, 12,
+	11, 19,
+	4, 7,
+	9, 16,
+	5, 9,
+	11, 20,
+	6, 11,
+	7, 13,
+	8, 15,
+	9, 17,
+	10, 19,
+	1, 2,
+	9, 19,
+	8, 17,
+	7, 15,
+	6, 13,
+	5, 11,
+	9, 20,
+	4, 9,
+	7, 16,
+	3, 7,
+	8, 19,
+	5, 12,
+	7, 17,
+	2, 5,
+	7, 18,
+	5, 13,
+	3, 8,
+	7, 19,
+	4, 11,
+	5, 14,
+	6, 17,
+	7, 20,
+	1, 3,
+	6, 19,
+	5, 16,
+	4, 13,
+	3, 10,
+	5, 17,
+	2, 7,
+	5, 18,
+	3, 11,
+	4, 15,
+	5, 19,
+	1, 4,
+	4, 17,
+	3, 13,
+	2, 9,
+	3, 14,
+	4, 19,
+	1, 5,
+	3, 16,
+	2, 11,
+	3, 17,
+	1, 6,
+	3, 19,
+	2, 13,
+	3, 20,
+	1, 7,
+	2, 15,
+	1, 8,
+	2, 17,
+	1, 9,
+	2, 19,
+	1, 10,
+	1, 11,
+	1, 12,
+	1, 13,
+	1, 14,
+	1, 15,
+	1, 16,
+	1, 17,
+	1, 18,
+	1, 19,
+	1, 20
+};
+
+
+/*!
+ * @brief Build PrP coefficient table based on average algorithm
+ *
+ * @param t	The pointer to scale_t structure
+ * @param base	The base of the coefficient
+ *
+ * @return	The length of current coefficient table on success
+ *		-1 on failure
+ */
+static int prp_scale_ave(scale_t * t, unsigned char base)
+{
+	if (t->len + base > sizeof(t->tbl))
+		return -1;
+
+	memcpy(&t->tbl[(int)t->len], ave_coeff[(int)base - 1], base);
+	t->len = (unsigned char)(t->len + base);
+	t->tbl[t->len - 1] |= SZ_COEF;
+
+	return t->len;
+}
+
+/*!
+ * @brief Build PrP coefficient table based on average algorithm
+ *
+ * @param t	The pointer to scale_t structure
+ * @param inv	Input resolution
+ * @param outv	Output resolution
+ *
+ * @return	The length of current coefficient table on success
+ *		-1 on failure
+ */
+static int ave_scale(scale_t * t, int inv, int outv)
+{
+	int ratio_count;
+
+	ratio_count = 0;
+	if (outv != 1) {
+		unsigned char a[20];
+		int v;
+
+		/* split n:m into multiple n[i]:1 */
+		for (v = 0; v < outv; v++)
+			a[v] = (unsigned char)(inv / outv);
+
+		inv %= outv;
+		if (inv) {
+			/* find start of next layer */
+			v = (outv - inv) >> 1;
+			inv += v;
+			for (; v < inv; v++)
+				a[v]++;
+		}
+
+		for (v = 0; v < outv; v++) {
+			if (prp_scale_ave(t, a[v]) < 0)
+				return -1;
+
+			t->ratio[ratio_count] = a[v];
+			ratio_count++;
+		}
+	} else if (prp_scale_ave(t, inv) < 0) {
+		return -1;
+	} else {
+		t->ratio[ratio_count++] = (char)inv;
+		ratio_count++;
+	}
+
+	return t->len;
+}
+
+/*!
+ * @brief Build PrP coefficient table
+ *
+ * @param t	The pointer to scale_t structure
+ * @param inv	input resolution reduced ratio
+ * @param outv	output resolution reduced ratio
+ *
+ * @return	The length of current coefficient table on success
+ *		-1 on failure
+ */
+static int scale(scale_t * t, int inv, int outv)
+{
+	int v;			/* overflow counter */
+	int coeff, nxt;		/* table output */
+
+	t->len = 0;
+	if (t->algo == ALGO_AUTO) {
+		/* automatic choice - bilinear for shrinking less than 2:1 */
+		t->algo = ((outv != inv) && ((2 * outv) > inv)) ?
+		    ALGO_BIL : ALGO_AVG;
+	}
+
+	/* 1:1 resize must use averaging, bilinear will hang */
+	if ((inv == outv) && (t->algo == ALGO_BIL)) {
+		pr_debug("Warning: 1:1 resize must use averaging algo\n");
+		t->algo = ALGO_AVG;
+	}
+
+	memset(t->tbl, 0, sizeof(t->tbl));
+	if (t->algo == ALGO_BIL) {
+		t->ratio[0] = (char)inv;
+		t->ratio[1] = (char)outv;
+	} else
+		memset(t->ratio, 0, sizeof(t->ratio));
+
+	if (inv == outv) {
+		/* force scaling */
+		t->ratio[0] = 1;
+		if (t->algo == ALGO_BIL)
+			t->ratio[1] = 1;
+
+		return prp_scale_ave(t, 1);
+	}
+
+	if (inv < outv) {
+		pr_debug("Upscaling not supported %d:%d\n", inv, outv);
+		return -1;
+	}
+
+	if (t->algo != ALGO_BIL)
+		return ave_scale(t, inv, outv);
+
+	v = 0;
+	if (inv >= 2 * outv) {
+		/* downscale: >=2:1 bilinear approximation */
+		coeff = inv - 2 * outv;
+		v = 0;
+		nxt = 0;
+		do {
+			v += coeff;
+			nxt = 2;
+			while (v >= outv) {
+				v -= outv;
+				nxt++;
+			}
+
+			if (prp_scale_bilinear(t, 1, 2, nxt) < 0)
+				return -1;
+		} while (v);
+	} else {
+		/* downscale: bilinear */
+		int in_pos_inc = 2 * outv;
+		int out_pos = inv;
+		int out_pos_inc = 2 * inv;
+		int init_carry = inv - outv;
+		int carry = init_carry;
+
+		v = outv + in_pos_inc;
+		do {
+			coeff = v - out_pos;
+			out_pos += out_pos_inc;
+			carry += out_pos_inc;
+			for (nxt = 0; v < out_pos; nxt++) {
+				v += in_pos_inc;
+				carry -= in_pos_inc;
+			}
+			if (prp_scale_bilinear(t, coeff, in_pos_inc, nxt) < 0)
+				return -1;
+		} while (carry != init_carry);
+	}
+	return t->len;
+}
+
+/*!
+ * @brief Get approximate ratio
+ *
+ * @param pscale	The pointer to scale_t structure which holdes
+ * 			coefficient tables
+ * @param mt		Scale ratio numerator
+ * @param nt		Scale ratio denominator
+ * @param *n		denominator of approximate ratio
+ * @return		numerator of approximate ratio
+ */
+
+static int approx_ratio(int mt, int nt, int *n)
+{
+	int index = sizeof(coeftab) / sizeof(coeftab[0]) / 2;
+	int left = 0;
+	int right = index - 1;
+	int nom, den;
+	while (index > 0) {
+		nom = coeftab[(((right + left) >> 1) << 1) + 1];
+		den = coeftab[(((right + left) >> 1) << 1)];
+		if ((nom * nt - mt * den) < 0) {
+			left = (right + left) >> 1;
+		} else {
+			right = (right + left) >> 1;
+		}
+		index = index >> 1;
+	}
+	*n = coeftab[left * 2];
+	nom = coeftab[left * 2 + 1];
+	return nom;
+}
+
+/*!
+ * @brief Build PrP coefficient table
+ *
+ * @param pscale	The pointer to scale_t structure which holdes
+ * 			coefficient tables
+ * @param din		Scale ratio numerator
+ * @param dout		Scale ratio denominator
+ * @param inv		Input resolution
+ * @param vout		Output resolution
+ * @param pout		Internal output resolution
+ * @param retry		Retry times (round the output length) when need
+ *
+ * @return		Zero on success, others on failure
+ */
+int prp_scale(scale_t * pscale, int din, int dout, int inv,
+	      unsigned short *vout, unsigned short *pout, int ch)
+{
+	int num, new_num;
+	int den, new_den;
+	unsigned short outv;
+
+	/* auto-generation of values */
+	if (!(dout && din)) {
+		if (!*vout)
+			dout = din = 1;
+		else {
+			din = inv;
+			dout = *vout;
+		}
+	}
+
+	if (din < dout) {
+		pr_debug("Scale err, unsupported ratio %d : %d\n", din, dout);
+		return -1;
+	}
+
+	num = ratio(din, dout, &den);
+	if (!num) {
+		pr_debug("Scale err, unsupported ratio %d : %d\n", din, dout);
+		return -1;
+	}
+
+	if (num > MAX_TBL) {
+		if (num / den <= MAX_TBL) {
+			new_num = approx_ratio(num, den, &new_den);
+			num = new_num;
+			den = new_den;
+		} else if (ch == PRP_CHANNEL_2) {
+			pr_debug("Unsupported ch_2 resize ratio %d : %d\n", num,
+				 den);
+			return -1;
+		} else if (num / den > MAX_TBL * MAX_TBL) {
+			pr_debug("Unsupported ch_1 resize ratio %d : %d\n", num,
+				 den);
+			return -1;
+		}
+	}
+
+	if ((num > MAX_TBL * MAX_TBL) || scale(pscale, num, den) < 0) {
+		pr_debug("Scale err, unsupported ratio %d : %d\n", num, den);
+		return -1;
+	}
+
+	if (pscale->algo == ALGO_BIL) {
+		unsigned char i, j, k;
+
+		outv =
+		    (unsigned short)(inv / pscale->ratio[0] * pscale->ratio[1]);
+		inv %= pscale->ratio[0];
+		for (i = j = 0; inv > 0; j++) {
+			unsigned char nxt;
+
+			k = scale_get(pscale, &i, &nxt);
+			if (inv == 1 && k < SZ_COEF) {
+				/* needs 2 pixels for this output */
+				break;
+			}
+			inv -= nxt;
+		}
+		outv = outv + j;
+	} else {
+		unsigned char i, tot;
+
+		for (tot = i = 0; pscale->ratio[i]; i++)
+			tot = tot + pscale->ratio[i];
+
+		outv = (unsigned short)(inv / tot) * i;
+		inv %= tot;
+		for (i = 0; inv > 0; i++, outv++)
+			inv -= pscale->ratio[i];
+	}
+
+	if (!(*vout) || ((*vout) > outv))
+		*vout = outv;
+
+	if (pout)
+		*pout = outv;
+
+	return 0;
+}
+
+/*!
+ * @brief Reset PrP block
+ */
+int prphw_reset(void)
+{
+	unsigned long val;
+	unsigned long flag;
+	int i;
+
+	flag = PRP_CNTL_RST;
+	val = PRP_CNTL_RSTVAL;
+
+	__raw_writel(flag, PRP_CNTL);
+
+	/* timeout */
+	for (i = 0; i < 1000; i++) {
+		if (!(__raw_readl(PRP_CNTL) & flag)) {
+			pr_debug("PrP reset over\n");
+			break;
+		}
+		msleep(1);
+	}
+
+	/* verify reset value */
+	if (__raw_readl(PRP_CNTL) != val) {
+		pr_info("PrP reset err, val = 0x%08X\n", __raw_readl(PRP_CNTL));
+		return -1;
+	}
+
+	return 0;
+}
+
+/*!
+ * @brief Enable PrP channel.
+ * @param channel	Channel number to be enabled
+ * @return		Zero on success, others on failure
+ */
+int prphw_enable(int channel)
+{
+	unsigned long val;
+
+	val = __raw_readl(PRP_CNTL);
+	if (channel & PRP_CHANNEL_1)
+		val |= PRP_CNTL_CH1EN;
+	if (channel & PRP_CHANNEL_2)
+		val |=
+		    (PRP_CNTL_CH2EN | PRP_CNTL_CH2_FLOWEN | PRP_CNTL_AUTODROP);
+
+	__raw_writel(val, PRP_CNTL);
+
+	return 0;
+}
+
+/*!
+ * @brief Disable PrP channel.
+ * @param channel	Channel number to be disable
+ * @return		Zero on success, others on failure
+ */
+int prphw_disable(int channel)
+{
+	unsigned long val;
+
+	val = __raw_readl(PRP_CNTL);
+	if (channel & PRP_CHANNEL_1)
+		val &= ~PRP_CNTL_CH1EN;
+	if (channel & PRP_CHANNEL_2)
+		val &= ~(PRP_CNTL_CH2EN | PRP_CNTL_CH2_FLOWEN);
+
+	__raw_writel(val, PRP_CNTL);
+
+	return 0;
+}
+
+/*!
+ * @brief Set PrP input buffer address.
+ * @param cfg	Pointer to PrP configuration parameter
+ * @return	Zero on success, others on failure
+ */
+int prphw_inptr(emma_prp_cfg * cfg)
+{
+	if (cfg->in_csi & PRP_CSI_EN)
+		return -1;
+
+	__raw_writel(cfg->in_ptr, PRP_SOURCE_Y_PTR);
+	if (cfg->in_pix == PRP_PIXIN_YUV420) {
+		u32 size;
+
+		size = cfg->in_line_stride * cfg->in_height;
+		__raw_writel(cfg->in_ptr + size, PRP_SOURCE_CB_PTR);
+		__raw_writel(cfg->in_ptr + size + (size >> 2),
+			     PRP_SOURCE_CR_PTR);
+	}
+	return 0;
+}
+
+/*!
+ * @brief Set PrP channel 1 output buffer 1 address.
+ * @param cfg	Pointer to PrP configuration parameter
+ * @return	Zero on success, others on failure
+ */
+int prphw_ch1ptr(emma_prp_cfg * cfg)
+{
+	if (cfg->ch1_pix == PRP_PIX1_UNUSED)
+		return -1;
+
+	__raw_writel(cfg->ch1_ptr, PRP_DEST_RGB1_PTR);
+
+	/* support double buffer in loop mode only */
+	if ((cfg->in_csi & PRP_CSI_LOOP) == PRP_CSI_LOOP) {
+		if (cfg->ch1_ptr2)
+			__raw_writel(cfg->ch1_ptr2, PRP_DEST_RGB2_PTR);
+		else
+			__raw_writel(cfg->ch1_ptr, PRP_DEST_RGB2_PTR);
+	}
+
+	return 0;
+}
+
+/*!
+ * @brief Set PrP channel 1 output buffer 2 address.
+ * @param cfg	Pointer to PrP configuration parameter
+ * @return	Zero on success, others on failure
+ */
+int prphw_ch1ptr2(emma_prp_cfg * cfg)
+{
+	if (cfg->ch1_pix == PRP_PIX1_UNUSED ||
+	    (cfg->in_csi & PRP_CSI_LOOP) != PRP_CSI_LOOP)
+		return -1;
+
+	if (cfg->ch1_ptr2)
+		__raw_writel(cfg->ch1_ptr2, PRP_DEST_RGB2_PTR);
+	else
+		return -1;
+
+	return 0;
+}
+
+/*!
+ * @brief Set PrP channel 2 output buffer 1 address.
+ * @param cfg	Pointer to PrP configuration parameter
+ * @return	Zero on success, others on failure
+ */
+int prphw_ch2ptr(emma_prp_cfg * cfg)
+{
+	u32 size;
+
+	if (cfg->ch2_pix == PRP_PIX2_UNUSED)
+		return -1;
+
+	__raw_writel(cfg->ch2_ptr, PRP_DEST_Y_PTR);
+
+	if (cfg->ch2_pix == PRP_PIX2_YUV420) {
+		size = cfg->ch2_width * cfg->ch2_height;
+		__raw_writel(cfg->ch2_ptr + size, PRP_DEST_CB_PTR);
+		__raw_writel(cfg->ch2_ptr + size + (size >> 2),
+			     PRP_DEST_CR_PTR);
+	}
+
+	__raw_writel(__raw_readl(PRP_CNTL) | PRP_CNTL_CH2B1, PRP_CNTL);
+	return 0;
+}
+
+/*!
+ * @brief Set PrP channel 2 output buffer 2 address.
+ * @param cfg	Pointer to PrP configuration parameter
+ * @return	Zero on success, others on failure
+ */
+int prphw_ch2ptr2(emma_prp_cfg * cfg)
+{
+	u32 size;
+
+	if (cfg->ch2_pix == PRP_PIX2_UNUSED ||
+	    (cfg->in_csi & PRP_CSI_LOOP) != PRP_CSI_LOOP)
+		return -1;
+
+	__raw_writel(cfg->ch2_ptr2, PRP_SOURCE_Y_PTR);
+	if (cfg->ch2_pix == PRP_PIX2_YUV420) {
+		size = cfg->ch2_width * cfg->ch2_height;
+		__raw_writel(cfg->ch2_ptr2 + size, PRP_SOURCE_CB_PTR);
+		__raw_writel(cfg->ch2_ptr2 + size + (size >> 2),
+			     PRP_SOURCE_CR_PTR);
+	}
+
+	__raw_writel(__raw_readl(PRP_CNTL) | PRP_CNTL_CH2B2, PRP_CNTL);
+	return 0;
+}
+
+/*!
+ * @brief Build CSC table
+ * @param csc	CSC table
+ *		in	csc[0]=index		0..3 : A.1 A.0 B.1 B.0
+ *			csc[1]=direction	0 : YUV2RGB  1 : RGB2YUV
+ *		out	csc[0..4] are coefficients c[9] is offset
+ *			csc[0..8] are coefficients c[9] is offset
+ */
+void csc_tbl(short csc[10])
+{
+	static const unsigned short _r2y[][9] = {
+		{0x4D, 0x4B, 0x3A, 0x57, 0x55, 0x40, 0x40, 0x6B, 0x29},
+		{0x42, 0x41, 0x32, 0x4C, 0x4A, 0x38, 0x38, 0x5E, 0x24},
+		{0x36, 0x5C, 0x25, 0x3B, 0x63, 0x40, 0x40, 0x74, 0x18},
+		{0x2F, 0x4F, 0x20, 0x34, 0x57, 0x38, 0x38, 0x66, 0x15},
+	};
+	static const unsigned short _y2r[][5] = {
+		{0x80, 0xb4, 0x2c, 0x5b, 0x0e4},
+		{0x95, 0xcc, 0x32, 0x68, 0x104},
+		{0x80, 0xca, 0x18, 0x3c, 0x0ec},
+		{0x95, 0xe5, 0x1b, 0x44, 0x1e0},
+	};
+	unsigned short *_csc;
+	int _csclen;
+
+	csc[9] = csc[0] & 1;
+	_csclen = csc[0] & 3;
+
+	if (csc[1]) {
+		_csc = (unsigned short *)_r2y[_csclen];
+		_csclen = sizeof(_r2y[0]);
+	} else {
+		_csc = (unsigned short *)_y2r[_csclen];
+		_csclen = sizeof(_y2r[0]);
+		memset(csc + 5, 0, sizeof(short) * 4);
+	}
+	memcpy(csc, _csc, _csclen);
+}
+
+/*!
+ * @brief Setup PrP resize coefficient registers
+ *
+ * @param ch	PrP channel number
+ * @param dir	Direction, 0 - horizontal, 1 - vertical
+ * @param scale	The pointer to scale_t structure
+ */
+static void prp_set_scaler(int ch, int dir, scale_t * scale)
+{
+	int i;
+	unsigned int coeff[2];
+	unsigned int valid;
+
+	for (coeff[0] = coeff[1] = valid = 0, i = 19; i >= 0; i--) {
+		int j;
+
+		j = i > 9 ? 1 : 0;
+		coeff[j] = (coeff[j] << BC_COEF) |
+		    (scale->tbl[i] & (SZ_COEF - 1));
+
+		if (i == 5 || i == 15)
+			coeff[j] <<= 1;
+
+		valid = (valid << 1) | (scale->tbl[i] >> BC_COEF);
+	}
+
+	valid |= (scale->len << 24) | ((2 - scale->algo) << 31);
+
+	for (i = 0; i < 2; i++)
+		(*PRP_RSZ_COEFF)[1 - ch][dir].coeff[i] = coeff[i];
+
+	(*PRP_RSZ_COEFF)[1 - ch][dir].cntl = valid;
+}
+
+/*!
+ * @brief Setup PrP registers relevant to input.
+ * @param cfg		Pointer to PrP configuration parameter
+ * @param prp_cntl	Holds the value for PrP control register
+ * @return		Zero on success, others on failure
+ */
+static int prphw_input_cfg(emma_prp_cfg * cfg, unsigned long *prp_cntl)
+{
+	unsigned long mask;
+
+	switch (cfg->in_pix) {
+	case PRP_PIXIN_YUV420:
+		*prp_cntl |= PRP_CNTL_IN_YUV420;
+		mask = 0x7;
+		break;
+	case PRP_PIXIN_YUYV:
+	case PRP_PIXIN_YVYU:
+	case PRP_PIXIN_UYVY:
+	case PRP_PIXIN_VYUY:
+		*prp_cntl |= PRP_CNTL_IN_YUV422;
+		mask = 0x1;
+		break;
+	case PRP_PIXIN_RGB565:
+		*prp_cntl |= PRP_CNTL_IN_RGB16;
+		mask = 0x1;
+		break;
+	case PRP_PIXIN_RGB888:
+		*prp_cntl |= PRP_CNTL_IN_RGB32;
+		mask = 0;
+		break;
+	default:
+		pr_debug("Unsupported input pix format 0x%08X\n", cfg->in_pix);
+		return -1;
+	}
+
+	/* align the input image width */
+	if (cfg->in_width & mask) {
+		pr_debug("in_width misaligned. in_width=%d\n", cfg->in_width);
+		return -1;
+	}
+
+	if ((cfg->in_width < PRP_MIN_IN_WIDTH)
+	    || (cfg->in_width > PRP_MAX_IN_WIDTH)) {
+		pr_debug("Unsupported input width %d\n", cfg->in_width);
+		return -1;
+	}
+
+	cfg->in_height &= ~1;	/* truncate to make even */
+
+	if ((cfg->in_height < PRP_MIN_IN_HEIGHT)
+	    || (cfg->in_height > PRP_MAX_IN_HEIGHT)) {
+		pr_debug("Unsupported input height %d\n", cfg->in_height);
+		return -1;
+	}
+
+	if (!(cfg->in_csi & PRP_CSI_EN))
+		if (!cfg->in_line_stride)
+			cfg->in_line_stride = cfg->in_width;
+
+	__raw_writel(cfg->in_pix, PRP_SRC_PIXEL_FORMAT_CNTL);
+	__raw_writel((cfg->in_width << 16) | cfg->in_height,
+		     PRP_SOURCE_FRAME_SIZE);
+	__raw_writel((cfg->in_line_skip << 16) | cfg->in_line_stride,
+		     PRP_SOURCE_LINE_STRIDE);
+
+	if (!(cfg->in_csi & PRP_CSI_EN)) {
+		__raw_writel(cfg->in_ptr, PRP_SOURCE_Y_PTR);
+		if (cfg->in_pix == PRP_PIXIN_YUV420) {
+			unsigned int size;
+
+			size = cfg->in_line_stride * cfg->in_height;
+			__raw_writel(cfg->in_ptr + size, PRP_SOURCE_CB_PTR);
+			__raw_writel(cfg->in_ptr + size + (size >> 2),
+				     PRP_SOURCE_CR_PTR);
+		}
+	}
+
+	/* always cropping */
+	*prp_cntl |= PRP_CNTL_WINEN;
+
+	/* color space conversion */
+	if (!cfg->in_csc[1]) {
+		if (cfg->in_csc[0] > 3) {
+			pr_debug("in_csc invalid 0x%X\n", cfg->in_csc[0]);
+			return -1;
+		}
+		if ((cfg->in_pix == PRP_PIXIN_RGB565)
+		    || (cfg->in_pix == PRP_PIXIN_RGB888))
+			cfg->in_csc[1] = 1;
+		else
+			cfg->in_csc[0] = 0;
+		csc_tbl(cfg->in_csc);
+	}
+
+	__raw_writel((cfg->in_csc[0] << 21) | (cfg->in_csc[1] << 11)
+		     | cfg->in_csc[2], PRP_CSC_COEF_012);
+	__raw_writel((cfg->in_csc[3] << 21) | (cfg->in_csc[4] << 11)
+		     | cfg->in_csc[5], PRP_CSC_COEF_345);
+	__raw_writel((cfg->in_csc[6] << 21) | (cfg->in_csc[7] << 11)
+		     | cfg->in_csc[8] | (cfg->in_csc[9] << 31),
+		     PRP_CSC_COEF_678);
+
+	if (cfg->in_csi & PRP_CSI_EN) {
+		*prp_cntl |= PRP_CNTL_CSI;
+
+		/* loop mode enable, ch1 ch2 together */
+		if ((cfg->in_csi & PRP_CSI_LOOP) == PRP_CSI_LOOP)
+			*prp_cntl |= (PRP_CNTL_CH1_LOOP | PRP_CNTL_CH2_LOOP);
+	}
+
+	return 0;
+}
+
+/*!
+ * @brief Setup PrP registers relevant to channel 2.
+ * @param cfg		Pointer to PrP configuration parameter
+ * @param prp_cntl	Holds the value for PrP control register
+ * @return		Zero on success, others on failure
+ */
+static int prphw_ch2_cfg(emma_prp_cfg * cfg, unsigned long *prp_cntl)
+{
+	switch (cfg->ch2_pix) {
+	case PRP_PIX2_YUV420:
+		*prp_cntl |= PRP_CNTL_CH2_YUV420;
+		break;
+	case PRP_PIX2_YUV422:
+		*prp_cntl |= PRP_CNTL_CH2_YUV422;
+		break;
+	case PRP_PIX2_YUV444:
+		*prp_cntl |= PRP_CNTL_CH2_YUV444;
+		break;
+	case PRP_PIX2_UNUSED:
+		return 0;
+	default:
+		pr_debug("Unsupported channel 2 pix format 0x%08X\n",
+			 cfg->ch2_pix);
+		return -1;
+	}
+
+	if (cfg->ch2_pix == PRP_PIX2_YUV420) {
+		cfg->ch2_height &= ~1;	/* ensure U/V presence */
+		cfg->ch2_width &= ~7;	/* ensure U/V word aligned */
+	} else if (cfg->ch2_pix == PRP_PIX2_YUV422) {
+		cfg->ch2_width &= ~1;	/* word aligned */
+	}
+
+	__raw_writel((cfg->ch2_width << 16) | cfg->ch2_height,
+		     PRP_CH2_OUT_IMAGE_SIZE);
+
+	if (cfg->ch2_pix == PRP_PIX2_YUV420) {
+		u32 size;
+
+		/* Luminanance band start address */
+		__raw_writel(cfg->ch2_ptr, PRP_DEST_Y_PTR);
+
+		if ((cfg->in_csi & PRP_CSI_LOOP) == PRP_CSI_LOOP) {
+			if (!cfg->ch2_ptr2)
+				__raw_writel(cfg->ch2_ptr, PRP_SOURCE_Y_PTR);
+			else
+				__raw_writel(cfg->ch2_ptr2, PRP_SOURCE_Y_PTR);
+		}
+
+		/* Cb and Cr band start address */
+		size = cfg->ch2_width * cfg->ch2_height;
+		__raw_writel(cfg->ch2_ptr + size, PRP_DEST_CB_PTR);
+		__raw_writel(cfg->ch2_ptr + size + (size >> 2),
+			     PRP_DEST_CR_PTR);
+
+		if ((cfg->in_csi & PRP_CSI_LOOP) == PRP_CSI_LOOP) {
+			if (!cfg->ch2_ptr2) {
+				__raw_writel(cfg->ch2_ptr + size,
+					     PRP_SOURCE_CB_PTR);
+				__raw_writel(cfg->ch2_ptr + size + (size >> 2),
+					     PRP_SOURCE_CR_PTR);
+			} else {
+				__raw_writel(cfg->ch2_ptr2 + size,
+					     PRP_SOURCE_CB_PTR);
+				__raw_writel(cfg->ch2_ptr2 + size + (size >> 2),
+					     PRP_SOURCE_CR_PTR);
+			}
+		}
+	} else {		/* Pixel interleaved YUV422 or YUV444 */
+		__raw_writel(cfg->ch2_ptr, PRP_DEST_Y_PTR);
+
+		if ((cfg->in_csi & PRP_CSI_LOOP) == PRP_CSI_LOOP) {
+			if (!cfg->ch2_ptr2)
+				__raw_writel(cfg->ch2_ptr, PRP_SOURCE_Y_PTR);
+			else
+				__raw_writel(cfg->ch2_ptr2, PRP_SOURCE_Y_PTR);
+		}
+	}
+	*prp_cntl |= PRP_CNTL_CH2B1 | PRP_CNTL_CH2B2;
+
+	return 0;
+}
+
+/*!
+ * @brief Setup PrP registers relevant to channel 1.
+ * @param cfg		Pointer to PrP configuration parameter
+ * @param prp_cntl	Holds the value for PrP control register
+ * @return		Zero on success, others on failure
+ */
+static int prphw_ch1_cfg(emma_prp_cfg * cfg, unsigned long *prp_cntl)
+{
+	int ch1_bpp = 0;
+
+	switch (cfg->ch1_pix) {
+	case PRP_PIX1_RGB332:
+		*prp_cntl |= PRP_CNTL_CH1_RGB8;
+		ch1_bpp = 1;
+		break;
+	case PRP_PIX1_RGB565:
+		*prp_cntl |= PRP_CNTL_CH1_RGB16;
+		ch1_bpp = 2;
+		break;
+	case PRP_PIX1_RGB888:
+		*prp_cntl |= PRP_CNTL_CH1_RGB32;
+		ch1_bpp = 4;
+		break;
+	case PRP_PIX1_YUYV:
+	case PRP_PIX1_YVYU:
+	case PRP_PIX1_UYVY:
+	case PRP_PIX1_VYUY:
+		*prp_cntl |= PRP_CNTL_CH1_YUV422;
+		ch1_bpp = 2;
+		break;
+	case PRP_PIX1_UNUSED:
+		return 0;
+	default:
+		pr_debug("Unsupported channel 1 pix format 0x%08X\n",
+			 cfg->ch1_pix);
+		return -1;
+	}
+
+	/* parallel or cascade resize */
+	if (cfg->ch1_scale.algo & PRP_ALGO_BYPASS)
+		*prp_cntl |= PRP_CNTL_UNCHAIN;
+
+	/* word align */
+	if (ch1_bpp == 2)
+		cfg->ch1_width &= ~1;
+	else if (ch1_bpp == 1)
+		cfg->ch1_width &= ~3;
+
+	if (!cfg->ch1_stride)
+		cfg->ch1_stride = cfg->ch1_width;
+
+	__raw_writel(cfg->ch1_pix, PRP_CH1_PIXEL_FORMAT_CNTL);
+	__raw_writel((cfg->ch1_width << 16) | cfg->ch1_height,
+		     PRP_CH1_OUT_IMAGE_SIZE);
+	__raw_writel(cfg->ch1_stride * ch1_bpp, PRP_CH1_LINE_STRIDE);
+	__raw_writel(cfg->ch1_ptr, PRP_DEST_RGB1_PTR);
+
+	/* double buffer for loop mode */
+	if ((cfg->in_csi & PRP_CSI_LOOP) == PRP_CSI_LOOP) {
+		if (cfg->ch1_ptr2)
+			__raw_writel(cfg->ch1_ptr2, PRP_DEST_RGB2_PTR);
+		else
+			__raw_writel(cfg->ch1_ptr, PRP_DEST_RGB2_PTR);
+	}
+
+	return 0;
+}
+
+/*!
+ * @brief Setup PrP registers.
+ * @param cfg	Pointer to PrP configuration parameter
+ * @return	Zero on success, others on failure
+ */
+int prphw_cfg(emma_prp_cfg * cfg)
+{
+	unsigned long prp_cntl = 0;
+	unsigned long val;
+
+	/* input pixel format checking */
+	if (prphw_input_cfg(cfg, &prp_cntl))
+		return -1;
+
+	if (prphw_ch2_cfg(cfg, &prp_cntl))
+		return -1;
+
+	if (prphw_ch1_cfg(cfg, &prp_cntl))
+		return -1;
+
+	/* register setting */
+	__raw_writel(prp_cntl, PRP_CNTL);
+
+	/* interrupt configuration */
+	val = PRP_INTRCNTL_RDERR | PRP_INTRCNTL_LBOVF;
+	if (cfg->ch1_pix != PRP_PIX1_UNUSED)
+		val |= PRP_INTRCNTL_CH1FC | PRP_INTRCNTL_CH1WERR;
+	if (cfg->ch2_pix != PRP_PIX2_UNUSED)
+		val |=
+		    PRP_INTRCNTL_CH2FC | PRP_INTRCNTL_CH2WERR |
+		    PRP_INTRCNTL_CH2OVF;
+	__raw_writel(val, PRP_INTRCNTL);
+
+	prp_set_scaler(1, 0, &cfg->scale[0]);	/* Channel 1 width */
+	prp_set_scaler(1, 1, &cfg->scale[1]);	/* Channel 1 height */
+	prp_set_scaler(0, 0, &cfg->scale[2]);	/* Channel 2 width */
+	prp_set_scaler(0, 1, &cfg->scale[3]);	/* Channel 2 height */
+
+	return 0;
+}
+
+/*!
+ * @brief Check PrP interrupt status.
+ * @return	PrP interrupt status
+ */
+int prphw_isr(void)
+{
+	int status;
+
+	status = __raw_readl(PRP_INTRSTATUS) & 0x1FF;
+
+	if (status & (PRP_INTRSTAT_RDERR | PRP_INTRSTAT_CH1WERR |
+		      PRP_INTRSTAT_CH2WERR))
+		pr_debug("isr bus error. status= 0x%08X\n", status);
+	else if (status & PRP_INTRSTAT_CH2OVF)
+		pr_debug("isr ch 2 buffer overflow. status= 0x%08X\n", status);
+	else if (status & PRP_INTRSTAT_LBOVF)
+		pr_debug("isr line buffer overflow. status= 0x%08X\n", status);
+
+	/* silicon bug?? enable bit does not self clear? */
+	if (!(__raw_readl(PRP_CNTL) & PRP_CNTL_CH1_LOOP))
+		__raw_writel(__raw_readl(PRP_CNTL) & (~PRP_CNTL_CH1EN),
+			     PRP_CNTL);
+	if (!(__raw_readl(PRP_CNTL) & PRP_CNTL_CH2_LOOP))
+		__raw_writel(__raw_readl(PRP_CNTL) & (~PRP_CNTL_CH2EN),
+			     PRP_CNTL);
+
+	__raw_writel(status, PRP_INTRSTATUS);	/* clr irq */
+
+	return status;
+}
+
+static struct clk *emma_clk;
+
+/*!
+ * @brief  PrP module clock enable
+ */
+void prphw_init(void)
+{
+	emma_clk = clk_get(NULL, "emma_clk");
+	clk_enable(emma_clk);
+}
+
+/*!
+ * @brief PrP module clock disable
+ */
+void prphw_exit(void)
+{
+	clk_disable(emma_clk);
+	clk_put(emma_clk);
+}
Index: linux-2.6.18/drivers/media/video/mxc/capture/mx27_prpsw.c
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/media/video/mxc/capture/mx27_prpsw.c
@@ -0,0 +1,1051 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mx27_prpsw.c
+ *
+ * @brief MX27 Video For Linux 2 capture driver
+ *
+ * @ingroup MXC_V4L2_CAPTURE
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/fb.h>
+#include <linux/pci.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#include "mxc_v4l2_capture.h"
+#include "mx27_prp.h"
+#include "mx27_csi.h"
+#include "../drivers/video/mxc/mx2fb.h"
+#include "../opl/opl.h"
+
+#define MEAN_COEF	(SZ_COEF >> 1)
+
+static char prp_dev[] = "emma_prp";
+static int g_still_on = 0;
+static emma_prp_cfg g_prp_cfg;
+static int g_vfbuf, g_rotbuf;
+static struct tasklet_struct prp_vf_tasklet;
+
+/*
+ * The following variables represents the virtual address for the cacheable
+ * buffers accessed by SW rotation/mirroring. The rotation/mirroring in
+ * cacheable buffers has significant performance improvement than it in
+ * non-cacheable buffers.
+ */
+static char *g_vaddr_vfbuf[2] = { 0, 0 };
+static char *g_vaddr_rotbuf[2] = { 0, 0 };
+static char *g_vaddr_fb = 0;
+
+static int set_ch1_addr(emma_prp_cfg * cfg, cam_data * cam);
+static int prp_v4l2_cfg(emma_prp_cfg * cfg, cam_data * cam);
+static int prp_vf_mem_alloc(cam_data * cam);
+static void prp_vf_mem_free(cam_data * cam);
+static int prp_rot_mem_alloc(cam_data * cam);
+static void prp_rot_mem_free(cam_data * cam);
+static int prp_enc_update_eba(u32 eba, int *buffer_num);
+static int prp_enc_enable(void *private);
+static int prp_enc_disable(void *private);
+static int prp_vf_start(void *private);
+static int prp_vf_stop(void *private);
+static int prp_still_start(void *private);
+static int prp_still_stop(void *private);
+static irqreturn_t prp_isr(int irq, void *dev_id, struct pt_regs *regs);
+static void rotation(unsigned long private);
+static int prp_resize_check_ch1(emma_prp_cfg * cfg);
+static int prp_resize_check_ch2(emma_prp_cfg * cfg);
+
+#define PRP_DUMP(val)	pr_debug("%s\t = 0x%08X\t%d\n", #val, val, val)
+
+/*!
+ * @brief Dump PrP configuration parameters.
+ * @param cfg	The pointer to PrP configuration parameter
+ */
+static void prp_cfg_dump(emma_prp_cfg * cfg)
+{
+	PRP_DUMP(cfg->in_pix);
+	PRP_DUMP(cfg->in_width);
+	PRP_DUMP(cfg->in_height);
+	PRP_DUMP(cfg->in_csi);
+	PRP_DUMP(cfg->in_line_stride);
+	PRP_DUMP(cfg->in_line_skip);
+	PRP_DUMP(cfg->in_ptr);
+
+	PRP_DUMP(cfg->ch1_pix);
+	PRP_DUMP(cfg->ch1_width);
+	PRP_DUMP(cfg->ch1_height);
+	PRP_DUMP(cfg->ch1_scale.algo);
+	PRP_DUMP(cfg->ch1_scale.width.num);
+	PRP_DUMP(cfg->ch1_scale.width.den);
+	PRP_DUMP(cfg->ch1_scale.height.num);
+	PRP_DUMP(cfg->ch1_scale.height.den);
+	PRP_DUMP(cfg->ch1_stride);
+	PRP_DUMP(cfg->ch1_ptr);
+	PRP_DUMP(cfg->ch1_ptr2);
+	PRP_DUMP(cfg->ch1_csi);
+
+	PRP_DUMP(cfg->ch2_pix);
+	PRP_DUMP(cfg->ch2_width);
+	PRP_DUMP(cfg->ch2_height);
+	PRP_DUMP(cfg->ch2_scale.algo);
+	PRP_DUMP(cfg->ch2_scale.width.num);
+	PRP_DUMP(cfg->ch2_scale.width.den);
+	PRP_DUMP(cfg->ch2_scale.height.num);
+	PRP_DUMP(cfg->ch2_scale.height.den);
+	PRP_DUMP(cfg->ch2_ptr);
+	PRP_DUMP(cfg->ch2_ptr2);
+	PRP_DUMP(cfg->ch2_csi);
+}
+
+/*!
+ * @brief Set PrP channel 1 output address.
+ * @param cfg	Pointer to emma_prp_cfg structure
+ * @param cam	Pointer to cam_data structure
+ * @return	Zero on success, others on failure
+ */
+static int set_ch1_addr(emma_prp_cfg * cfg, cam_data * cam)
+{
+	if (cam->rotation != V4L2_MXC_ROTATE_NONE) {
+		cfg->ch1_ptr = (unsigned int)cam->rot_vf_bufs[0];
+		cfg->ch1_ptr2 = (unsigned int)cam->rot_vf_bufs[1];
+		if ((cam->rotation == V4L2_MXC_ROTATE_90_RIGHT)
+		    || (cam->rotation == V4L2_MXC_ROTATE_90_RIGHT_VFLIP)
+		    || (cam->rotation == V4L2_MXC_ROTATE_90_RIGHT_HFLIP)
+		    || (cam->rotation == V4L2_MXC_ROTATE_90_LEFT))
+			cfg->ch1_stride = cam->win.w.height;
+		else
+			cfg->ch1_stride = cam->win.w.width;
+
+		if (cam->v4l2_fb.flags != V4L2_FBUF_FLAG_OVERLAY) {
+			struct fb_info *fb = cam->overlay_fb;
+			if (!fb)
+				return -1;
+			if (g_vaddr_fb)
+				iounmap(g_vaddr_fb);
+			g_vaddr_fb = ioremap_cached(fb->fix.smem_start,
+						    fb->fix.smem_len);
+			if (!g_vaddr_fb)
+				return -1;
+		}
+	} else if (cam->v4l2_fb.flags == V4L2_FBUF_FLAG_OVERLAY) {
+		cfg->ch1_ptr = (unsigned int)cam->vf_bufs[0];
+		cfg->ch1_ptr2 = (unsigned int)cam->vf_bufs[1];
+		cfg->ch1_stride = cam->win.w.width;
+	} else {
+		struct fb_info *fb = cam->overlay_fb;
+
+		if (!fb)
+			return -1;
+
+		cfg->ch1_ptr = fb->fix.smem_start;
+		cfg->ch1_ptr += cam->win.w.top * fb->var.xres_virtual
+		    * (fb->var.bits_per_pixel >> 3)
+		    + cam->win.w.left * (fb->var.bits_per_pixel >> 3);
+		cfg->ch1_ptr2 = cfg->ch1_ptr;
+		cfg->ch1_stride = fb->var.xres_virtual;
+	}
+
+	return 0;
+}
+
+/*!
+ * @brief Setup PrP configuration parameters.
+ * @param cfg	Pointer to emma_prp_cfg structure
+ * @param cam	Pointer to cam_data structure
+ * @return	Zero on success, others on failure
+ */
+static int prp_v4l2_cfg(emma_prp_cfg * cfg, cam_data * cam)
+{
+	cfg->in_pix = PRP_PIXIN_YUYV;
+	cfg->in_width = cam->crop_current.width;
+	cfg->in_height = cam->crop_current.height;
+	cfg->in_line_stride = cam->crop_current.left;
+	cfg->in_line_skip = cam->crop_current.top;
+	cfg->in_ptr = 0;
+	cfg->in_csi = PRP_CSI_LOOP;
+	memset(cfg->in_csc, 0, sizeof(cfg->in_csc));
+
+	if (cam->overlay_on) {
+		/* Convert V4L2 pixel format to PrP pixel format */
+		switch (cam->v4l2_fb.fmt.pixelformat) {
+		case V4L2_PIX_FMT_RGB332:
+			cfg->ch1_pix = PRP_PIX1_RGB332;
+			break;
+		case V4L2_PIX_FMT_RGB32:
+		case V4L2_PIX_FMT_BGR32:
+			cfg->ch1_pix = PRP_PIX1_RGB888;
+			break;
+		case V4L2_PIX_FMT_YUYV:
+			cfg->ch1_pix = PRP_PIX1_YUYV;
+			break;
+		case V4L2_PIX_FMT_UYVY:
+			cfg->ch1_pix = PRP_PIX1_UYVY;
+			break;
+		case V4L2_PIX_FMT_RGB565:
+		default:
+			cfg->ch1_pix = PRP_PIX1_RGB565;
+			break;
+		}
+		if ((cam->rotation == V4L2_MXC_ROTATE_90_RIGHT)
+		    || (cam->rotation == V4L2_MXC_ROTATE_90_RIGHT_VFLIP)
+		    || (cam->rotation == V4L2_MXC_ROTATE_90_RIGHT_HFLIP)
+		    || (cam->rotation == V4L2_MXC_ROTATE_90_LEFT)) {
+			cfg->ch1_width = cam->win.w.height;
+			cfg->ch1_height = cam->win.w.width;
+		} else {
+			cfg->ch1_width = cam->win.w.width;
+			cfg->ch1_height = cam->win.w.height;
+		}
+
+		if (set_ch1_addr(cfg, cam))
+			return -1;
+	} else {
+		cfg->ch1_pix = PRP_PIX1_UNUSED;
+		cfg->ch1_width = cfg->in_width;
+		cfg->ch1_height = cfg->in_height;
+	}
+	cfg->ch1_scale.algo = 0;
+	cfg->ch1_scale.width.num = cfg->in_width;
+	cfg->ch1_scale.width.den = cfg->ch1_width;
+	cfg->ch1_scale.height.num = cfg->in_height;
+	cfg->ch1_scale.height.den = cfg->ch1_height;
+	cfg->ch1_csi = PRP_CSI_EN;
+
+	if (cam->capture_on || g_still_on) {
+		switch (cam->v2f.fmt.pix.pixelformat) {
+		case V4L2_PIX_FMT_YUYV:
+			cfg->ch2_pix = PRP_PIX2_YUV422;
+			break;
+		case V4L2_PIX_FMT_YUV420:
+			cfg->ch2_pix = PRP_PIX2_YUV420;
+			break;
+			/*
+			 * YUV444 is not defined by V4L2.
+			 * We support it in default case.
+			 */
+		default:
+			cfg->ch2_pix = PRP_PIX2_YUV444;
+			break;
+		}
+		cfg->ch2_width = cam->v2f.fmt.pix.width;
+		cfg->ch2_height = cam->v2f.fmt.pix.height;
+	} else {
+		cfg->ch2_pix = PRP_PIX2_UNUSED;
+		cfg->ch2_width = cfg->in_width;
+		cfg->ch2_height = cfg->in_height;
+	}
+	cfg->ch2_scale.algo = 0;
+	cfg->ch2_scale.width.num = cfg->in_width;
+	cfg->ch2_scale.width.den = cfg->ch2_width;
+	cfg->ch2_scale.height.num = cfg->in_height;
+	cfg->ch2_scale.height.den = cfg->ch2_height;
+	cfg->ch2_csi = PRP_CSI_EN;
+
+	memset(cfg->scale, 0, sizeof(cfg->scale));
+	cfg->scale[0].algo = cfg->ch1_scale.algo & 3;
+	cfg->scale[1].algo = (cfg->ch1_scale.algo >> 2) & 3;
+	cfg->scale[2].algo = cfg->ch2_scale.algo & 3;
+	cfg->scale[3].algo = (cfg->ch2_scale.algo >> 2) & 3;
+
+	prp_cfg_dump(cfg);
+
+	if (prp_resize_check_ch2(cfg))
+		return -1;
+
+	if (prp_resize_check_ch1(cfg))
+		return -1;
+
+	return 0;
+}
+
+/*!
+ * @brief PrP interrupt handler
+ */
+static irqreturn_t prp_isr(int irq, void *dev_id, struct pt_regs *regs)
+{
+	int status;
+	cam_data *cam = (cam_data *) dev_id;
+
+	status = prphw_isr();
+
+	if (g_still_on && (status & PRP_INTRSTAT_CH2BUF1)) {
+		prp_still_stop(cam);
+		cam->still_counter++;
+		wake_up_interruptible(&cam->still_queue);
+		/*
+		 * Still & video capture use the same PrP channel 2.
+		 * They are execlusive.
+		 */
+	} else if (cam->capture_on) {
+		if (status & PRP_INTRSTAT_CH2OVF) {
+			prphw_disable(PRP_CHANNEL_2);
+			prphw_enable(PRP_CHANNEL_2);
+			cam->enc_callback(1, cam);
+		}
+		else if (status &
+	     (PRP_INTRSTAT_CH2BUF1 | PRP_INTRSTAT_CH2BUF2)) 		{
+			cam->enc_callback(0, cam);
+		}
+	}
+	if (cam->overlay_on
+	    && (status & (PRP_INTRSTAT_CH1BUF1 | PRP_INTRSTAT_CH1BUF2))) {
+		if (cam->rotation != V4L2_MXC_ROTATE_NONE) {
+			g_rotbuf = (status & PRP_INTRSTAT_CH1BUF1) ? 0 : 1;
+			tasklet_schedule(&prp_vf_tasklet);
+		} else if (cam->v4l2_fb.flags == V4L2_FBUF_FLAG_OVERLAY) {
+			struct fb_gwinfo gwinfo;
+
+			gwinfo.enabled = 1;
+			gwinfo.alpha_value = 255;
+			gwinfo.ck_enabled = 0;
+			gwinfo.xpos = cam->win.w.left;
+			gwinfo.ypos = cam->win.w.top;
+			gwinfo.xres = cam->win.w.width;
+			gwinfo.yres = cam->win.w.height;
+			gwinfo.xres_virtual = cam->win.w.width;
+			gwinfo.vs_reversed = 0;
+			if (status & PRP_INTRSTAT_CH1BUF1)
+				gwinfo.base = (unsigned long)cam->vf_bufs[0];
+			else
+				gwinfo.base = (unsigned long)cam->vf_bufs[1];
+
+			mx2_gw_set(&gwinfo);
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+/*!
+ * @brief PrP initialization.
+ * @param dev_id	Pointer to cam_data structure
+ * @return		Zero on success, others on failure
+ */
+int prp_init(void *dev_id)
+{
+	enable_irq(MXC_INT_EMMAPRP);
+	if (request_irq(MXC_INT_EMMAPRP, prp_isr, 0, prp_dev, dev_id))
+		return -1;
+	prphw_init();
+
+	return 0;
+}
+
+/*!
+ * @brief PrP initialization.
+ * @param dev_id	Pointer to cam_data structure
+ */
+void prp_exit(void *dev_id)
+{
+	prphw_exit();
+	disable_irq(MXC_INT_EMMAPRP);
+	free_irq(MXC_INT_EMMAPRP, dev_id);
+}
+
+/*!
+ * @brief Update PrP channel 2 output buffer address.
+ * @param eba		Physical address for PrP output buffer
+ * @param buffer_num	The PrP channel 2 buffer number to be updated
+ * @return		Zero on success, others on failure
+ */
+static int prp_enc_update_eba(u32 eba, int *buffer_num)
+{
+	if (*buffer_num) {
+		g_prp_cfg.ch2_ptr2 = eba;
+		prphw_ch2ptr2(&g_prp_cfg);
+		*buffer_num = 0;
+	} else {
+		g_prp_cfg.ch2_ptr = eba;
+		prphw_ch2ptr(&g_prp_cfg);
+		*buffer_num = 1;
+	}
+
+	return 0;
+}
+
+/*!
+ * @brief Enable PrP for encoding.
+ * @param private	Pointer to cam_data structure
+ * @return		Zero on success, others on failure
+ */
+static int prp_enc_enable(void *private)
+{
+	cam_data *cam = (cam_data *) private;
+
+	if (prp_v4l2_cfg(&g_prp_cfg, cam))
+		return -1;
+
+	csi_enable_mclk(CSI_MCLK_ENC, true, true);
+	prphw_reset();
+
+	if (prphw_cfg(&g_prp_cfg))
+		return -1;
+
+	prphw_enable(cam->overlay_on ? (PRP_CHANNEL_1 | PRP_CHANNEL_2)
+		     : PRP_CHANNEL_2);
+
+	return 0;
+}
+
+/*!
+ * @brief Disable PrP for encoding.
+ * @param private	Pointer to cam_data structure
+ * @return		Zero on success, others on failure
+ */
+static int prp_enc_disable(void *private)
+{
+	prphw_disable(PRP_CHANNEL_2);
+	csi_enable_mclk(CSI_MCLK_ENC, false, false);
+
+	return 0;
+}
+
+/*!
+ * @brief Setup encoding functions.
+ * @param private	Pointer to cam_data structure
+ * @return		Zero on success, others on failure
+ */
+int prp_enc_select(void *private)
+{
+	int ret = 0;
+	cam_data *cam = (cam_data *) private;
+
+	if (cam) {
+		cam->enc_update_eba = prp_enc_update_eba;
+		cam->enc_enable = prp_enc_enable;
+		cam->enc_disable = prp_enc_disable;
+	} else
+		ret = -EIO;
+
+	return ret;
+}
+
+/*!
+ * @brief Uninstall encoding functions.
+ * @param private	Pointer to cam_data structure
+ * @return		Zero on success, others on failure
+ */
+int prp_enc_deselect(void *private)
+{
+	int ret = 0;
+	cam_data *cam = (cam_data *) private;
+
+	ret = prp_enc_disable(private);
+
+	if (cam) {
+		cam->enc_update_eba = NULL;
+		cam->enc_enable = NULL;
+		cam->enc_disable = NULL;
+	}
+
+	return ret;
+}
+
+/*!
+ * @brief Allocate memory for overlay.
+ * @param cam	Pointer to cam_data structure
+ * @return	Zero on success, others on failure
+ */
+static int prp_vf_mem_alloc(cam_data * cam)
+{
+	int i;
+
+	for (i = 0; i < 2; i++) {
+		cam->vf_bufs_size[i] = cam->win.w.width * cam->win.w.height * 2;
+		cam->vf_bufs_vaddr[i] = dma_alloc_coherent(0,
+							   cam->vf_bufs_size[i],
+							   &cam->vf_bufs[i],
+							   GFP_DMA |
+							   GFP_KERNEL);
+		if (!cam->vf_bufs_vaddr[i]) {
+			pr_debug("Failed to alloc memory for vf.\n");
+			prp_vf_mem_free(cam);
+			return -1;
+		}
+
+		g_vaddr_vfbuf[i] =
+		    ioremap_cached(cam->vf_bufs[i], cam->vf_bufs_size[i]);
+		if (!g_vaddr_vfbuf[i]) {
+			pr_debug("Failed to ioremap_cached() for vf.\n");
+			prp_vf_mem_free(cam);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+/*!
+ * @brief Free memory for overlay.
+ * @param cam	Pointer to cam_data structure
+ * @return	Zero on success, others on failure
+ */
+static void prp_vf_mem_free(cam_data * cam)
+{
+	int i;
+
+	for (i = 0; i < 2; i++) {
+		if (cam->vf_bufs_vaddr[i]) {
+			dma_free_coherent(0,
+					  cam->vf_bufs_size[i],
+					  cam->vf_bufs_vaddr[i],
+					  cam->vf_bufs[i]);
+		}
+		cam->vf_bufs[i] = 0;
+		cam->vf_bufs_vaddr[i] = 0;
+		cam->vf_bufs_size[i] = 0;
+		if (g_vaddr_vfbuf[i]) {
+			iounmap(g_vaddr_vfbuf[i]);
+			g_vaddr_vfbuf[i] = 0;
+		}
+	}
+}
+
+/*!
+ * @brief Allocate intermediate memory for overlay rotation/mirroring.
+ * @param cam	Pointer to cam_data structure
+ * @return	Zero on success, others on failure
+ */
+static int prp_rot_mem_alloc(cam_data * cam)
+{
+	int i;
+
+	for (i = 0; i < 2; i++) {
+		cam->rot_vf_buf_size[i] =
+		    cam->win.w.width * cam->win.w.height * 2;
+		cam->rot_vf_bufs_vaddr[i] =
+		    dma_alloc_coherent(0, cam->rot_vf_buf_size[i],
+				       &cam->rot_vf_bufs[i],
+				       GFP_DMA | GFP_KERNEL);
+		if (!cam->rot_vf_bufs_vaddr[i]) {
+			pr_debug("Failed to alloc memory for vf rotation.\n");
+			prp_rot_mem_free(cam);
+			return -1;
+		}
+
+		g_vaddr_rotbuf[i] =
+		    ioremap_cached(cam->rot_vf_bufs[i],
+				   cam->rot_vf_buf_size[i]);
+		if (!g_vaddr_rotbuf[i]) {
+			pr_debug
+			    ("Failed to ioremap_cached() for rotation buffer.\n");
+			prp_rot_mem_free(cam);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+/*!
+ * @brief Free intermedaite memory for overlay rotation/mirroring.
+ * @param cam	Pointer to cam_data structure
+ * @return	Zero on success, others on failure
+ */
+static void prp_rot_mem_free(cam_data * cam)
+{
+	int i;
+
+	for (i = 0; i < 2; i++) {
+		if (cam->rot_vf_bufs_vaddr[i]) {
+			dma_free_coherent(0,
+					  cam->rot_vf_buf_size[i],
+					  cam->rot_vf_bufs_vaddr[i],
+					  cam->rot_vf_bufs[i]);
+		}
+		cam->rot_vf_bufs[i] = 0;
+		cam->rot_vf_bufs_vaddr[i] = 0;
+		cam->rot_vf_buf_size[i] = 0;
+		if (g_vaddr_rotbuf[i]) {
+			iounmap(g_vaddr_rotbuf[i]);
+			g_vaddr_rotbuf[i] = 0;
+		}
+	}
+}
+
+/*!
+ * @brief Start overlay (view finder).
+ * @param private	Pointer to cam_data structure
+ * @return		Zero on success, others on failure
+ */
+static int prp_vf_start(void *private)
+{
+	cam_data *cam = (cam_data *) private;
+
+	if (cam->v4l2_fb.flags == V4L2_FBUF_FLAG_OVERLAY) {
+		prp_vf_mem_free(cam);
+		if (prp_vf_mem_alloc(cam)) {
+			pr_info("Error to allocate vf buffer\n");
+			return -ENOMEM;
+		}
+	}
+
+	if (cam->rotation != V4L2_MXC_ROTATE_NONE) {
+		prp_rot_mem_free(cam);
+		if (prp_rot_mem_alloc(cam)) {
+			pr_info("Error to allocate rotation buffer\n");
+			prp_vf_mem_free(cam);
+			return -ENOMEM;
+		}
+	}
+
+	if (prp_v4l2_cfg(&g_prp_cfg, cam)) {
+		prp_vf_mem_free(cam);
+		prp_rot_mem_free(cam);
+		return -1;
+	}
+
+	csi_enable_mclk(CSI_MCLK_VF, true, true);
+	prphw_reset();
+
+	if (prphw_cfg(&g_prp_cfg)) {
+		prp_vf_mem_free(cam);
+		prp_rot_mem_free(cam);
+		return -1;
+	}
+	g_vfbuf = g_rotbuf = 0;
+	tasklet_init(&prp_vf_tasklet, rotation, (unsigned long)private);
+
+	prphw_enable(cam->capture_on ? (PRP_CHANNEL_1 | PRP_CHANNEL_2)
+		     : PRP_CHANNEL_1);
+
+	return 0;
+}
+
+/*!
+ * @brief Stop overlay (view finder).
+ * @param private	Pointer to cam_data structure
+ * @return		Zero on success, others on failure
+ */
+static int prp_vf_stop(void *private)
+{
+	cam_data *cam = (cam_data *) private;
+
+	prphw_disable(PRP_CHANNEL_1);
+
+	csi_enable_mclk(CSI_MCLK_VF, false, false);
+	tasklet_kill(&prp_vf_tasklet);
+
+	if (cam->v4l2_fb.flags == V4L2_FBUF_FLAG_OVERLAY) {
+		struct fb_gwinfo gwinfo;
+
+		/* Disable graphic window */
+		gwinfo.enabled = 0;
+		mx2_gw_set(&gwinfo);
+
+		prp_vf_mem_free(cam);
+	}
+	prp_rot_mem_free(cam);
+	if (g_vaddr_fb) {
+		iounmap(g_vaddr_fb);
+		g_vaddr_fb = 0;
+	}
+
+	return 0;
+}
+
+/*!
+ * @brief Setup overlay functions.
+ * @param private	Pointer to cam_data structure
+ * @return		Zero on success, others on failure
+ */
+int prp_vf_select(void *private)
+{
+	int ret = 0;
+	cam_data *cam = (cam_data *) private;
+
+	if (cam) {
+		cam->vf_start_sdc = prp_vf_start;
+		cam->vf_stop_sdc = prp_vf_stop;
+		cam->overlay_active = false;
+	} else
+		ret = -EIO;
+
+	return ret;
+}
+
+/*!
+ * @brief Uninstall overlay functions.
+ * @param private	Pointer to cam_data structure
+ * @return		Zero on success, others on failure
+ */
+int prp_vf_deselect(void *private)
+{
+	int ret = 0;
+	cam_data *cam = (cam_data *) private;
+
+	ret = prp_vf_stop(private);
+
+	if (cam) {
+		cam->vf_start_sdc = NULL;
+		cam->vf_stop_sdc = NULL;
+	}
+
+	return ret;
+}
+
+/*!
+ * @brief Start still picture capture.
+ * @param private	Pointer to cam_data structure
+ * @return		Zero on success, others on failure
+ */
+static int prp_still_start(void *private)
+{
+	cam_data *cam = (cam_data *) private;
+
+	g_still_on = 1;
+	g_prp_cfg.ch2_ptr = (unsigned int)cam->still_buf;
+	g_prp_cfg.ch2_ptr2 = 0;
+
+	if (prp_v4l2_cfg(&g_prp_cfg, cam))
+		return -1;
+
+	csi_enable_mclk(CSI_MCLK_RAW, true, true);
+	prphw_reset();
+
+	if (prphw_cfg(&g_prp_cfg)) {
+		g_still_on = 0;
+		return -1;
+	}
+
+	prphw_enable(cam->overlay_on ? (PRP_CHANNEL_1 | PRP_CHANNEL_2)
+		     : PRP_CHANNEL_2);
+
+	return 0;
+}
+
+/*!
+ * @brief Stop still picture capture.
+ * @param private	Pointer to cam_data structure
+ * @return		Zero on success, others on failure
+ */
+static int prp_still_stop(void *private)
+{
+	prphw_disable(PRP_CHANNEL_2);
+
+	csi_enable_mclk(CSI_MCLK_RAW, false, false);
+
+	g_still_on = 0;
+
+	return 0;
+}
+
+/*!
+ * @brief Setup functions for still picture capture.
+ * @param private	Pointer to cam_data structure
+ * @return		Zero on success, others on failure
+ */
+int prp_still_select(void *private)
+{
+	cam_data *cam = (cam_data *) private;
+
+	if (cam) {
+		cam->csi_start = prp_still_start;
+		cam->csi_stop = prp_still_stop;
+	}
+
+	return 0;
+}
+
+/*!
+ * @brief Uninstall functions for still picture capture.
+ * @param private	Pointer to cam_data structure
+ * @return		Zero on success, others on failure
+ */
+int prp_still_deselect(void *private)
+{
+	cam_data *cam = (cam_data *) private;
+	int err = 0;
+
+	err = prp_still_stop(cam);
+
+	if (cam) {
+		cam->csi_start = NULL;
+		cam->csi_stop = NULL;
+	}
+
+	return err;
+}
+
+/*!
+ * @brief Perform software rotation or mirroring
+ * @param private	Argument passed to the tasklet
+ */
+static void rotation(unsigned long private)
+{
+	char *src, *dst;
+	int width, height, s_stride, d_stride;
+	int size;
+	cam_data *cam = (cam_data *) private;
+
+	src = g_vaddr_rotbuf[g_rotbuf];
+	size = cam->rot_vf_buf_size[g_rotbuf];
+
+	if ((cam->rotation == V4L2_MXC_ROTATE_90_RIGHT)
+	    || (cam->rotation == V4L2_MXC_ROTATE_90_RIGHT_VFLIP)
+	    || (cam->rotation == V4L2_MXC_ROTATE_90_RIGHT_HFLIP)
+	    || (cam->rotation == V4L2_MXC_ROTATE_90_LEFT)) {
+		width = cam->win.w.height;
+		height = cam->win.w.width;
+		s_stride = cam->win.w.height << 1;
+	} else {
+		width = cam->win.w.width;
+		height = cam->win.w.height;
+		s_stride = cam->win.w.width << 1;
+	}
+
+	if (cam->v4l2_fb.flags == V4L2_FBUF_FLAG_OVERLAY) {
+		dst = g_vaddr_vfbuf[g_vfbuf];
+		d_stride = cam->win.w.width << 1;
+	} else {		/* The destination is the framebuffer */
+		struct fb_info *fb = cam->overlay_fb;
+		if (!fb)
+			return;
+		dst = g_vaddr_fb;
+		dst += cam->win.w.top * fb->var.xres_virtual
+		    * (fb->var.bits_per_pixel >> 3)
+		    + cam->win.w.left * (fb->var.bits_per_pixel >> 3);
+		d_stride = fb->var.xres_virtual << 1;
+	}
+
+	/*
+	 * Invalidate the data in cache before performing the SW rotaion
+	 * or mirroring in case the image size is less than QVGA. For image
+	 * larger than QVGA it is not invalidated becase the invalidation
+	 * will consume much time while we don't see any artifacts on the
+	 * output if we don't perform invalidation for them.
+	 * Similarly we don't flush the data after SW rotation/mirroring.
+	 */
+	if (size < 320 * 240 * 2)
+		consistent_sync(src, size, DMA_FROM_DEVICE);
+	switch (cam->rotation) {
+	case V4L2_MXC_ROTATE_VERT_FLIP:
+		opl_vmirror_u16(src, s_stride, width, height, dst, d_stride);
+		break;
+	case V4L2_MXC_ROTATE_HORIZ_FLIP:
+		opl_hmirror_u16(src, s_stride, width, height, dst, d_stride);
+		break;
+	case V4L2_MXC_ROTATE_180:
+		opl_rotate180_u16(src, s_stride, width, height, dst, d_stride);
+		break;
+	case V4L2_MXC_ROTATE_90_RIGHT:
+		opl_rotate90_u16(src, s_stride, width, height, dst, d_stride);
+		break;
+	case V4L2_MXC_ROTATE_90_RIGHT_VFLIP:
+		opl_rotate90_vmirror_u16(src, s_stride, width, height, dst,
+					 d_stride);
+		break;
+	case V4L2_MXC_ROTATE_90_RIGHT_HFLIP:
+		/* ROTATE_90_RIGHT_HFLIP = ROTATE_270_RIGHT_VFLIP */
+		opl_rotate270_vmirror_u16(src, s_stride, width, height, dst,
+					  d_stride);
+		break;
+	case V4L2_MXC_ROTATE_90_LEFT:
+		opl_rotate270_u16(src, s_stride, width, height, dst, d_stride);
+		break;
+	default:
+		return;
+	}
+
+	/* Config and display the graphic window */
+	if (cam->v4l2_fb.flags == V4L2_FBUF_FLAG_OVERLAY) {
+		struct fb_gwinfo gwinfo;
+
+		gwinfo.enabled = 1;
+		gwinfo.alpha_value = 255;
+		gwinfo.ck_enabled = 0;
+		gwinfo.xpos = cam->win.w.left;
+		gwinfo.ypos = cam->win.w.top;
+		gwinfo.xres = cam->win.w.width;
+		gwinfo.yres = cam->win.w.height;
+		gwinfo.xres_virtual = cam->win.w.width;
+		gwinfo.vs_reversed = 0;
+		gwinfo.base = (unsigned long)cam->vf_bufs[g_vfbuf];
+		mx2_gw_set(&gwinfo);
+
+		g_vfbuf = g_vfbuf ? 0 : 1;
+	}
+}
+
+/*
+ * @brief Check if the resize ratio is supported based on the input and output
+ *        dimension
+ * @param	input	input dimension
+ * @param	output	output dimension
+ * @return	output dimension (should equal the parameter *output*)
+ * 		-1 on failure
+ */
+static int check_simple(scale_t * scale, int input, int output, int ch)
+{
+	unsigned short int_out;	/* PrP internel width or height */
+	unsigned short orig_out = output;
+
+	if (prp_scale(scale, input, output, input, &orig_out, &int_out, ch))
+		return -1;	/* resize failed */
+	else
+		return int_out;
+}
+
+/*!
+ * @brief Check if the resize ratio is supported by PrP channel 1
+ * @param cfg	Pointer to emma_prp_cfg structure
+ * @return	Zero on success, others on failure
+ */
+static int prp_resize_check_ch1(emma_prp_cfg * cfg)
+{
+	int in_w, in_h, ch1_w, ch1_h, ch2_w, ch2_h, w, h;
+	scale_t *pscale = &cfg->scale[0];	/* Ch1 width resize coeff */
+
+	if (cfg->ch1_pix == PRP_PIX1_UNUSED)
+		return 0;
+
+	in_w = cfg->in_width;
+	in_h = cfg->in_height;
+	ch1_w = cfg->ch1_width;
+	ch1_h = cfg->ch1_height;
+	ch2_w = cfg->ch2_width;
+	ch2_h = cfg->ch2_height;
+
+	/*
+	 * For channel 1, try parallel resize first. If the resize
+	 * ratio is not exactly supported, try cascade resize. If it
+	 * still fails, use parallel resize but with rounded value.
+	 */
+	w = check_simple(pscale, in_w, ch1_w, PRP_CHANNEL_1);
+	h = check_simple(pscale + 1, in_h, ch1_h, PRP_CHANNEL_1);
+
+	if ((in_w <= ch1_w * MAX_TBL) && (in_h <= MAX_TBL * ch1_h))
+		goto exit_parallel;
+
+	if (cfg->ch2_pix != PRP_PIX2_UNUSED) {
+		/*
+		 * Channel 2 is already used. The pscale is still pointing
+		 * to ch1 resize coeff for temporary use.
+		 */
+		if ((ch2_w * MAX_TBL <= ch1_w) && (ch2_h * MAX_TBL <= ch1_h)) {
+			w = check_simple(pscale, ch2_w, ch1_w, PRP_CHANNEL_1);
+			h = check_simple(pscale + 1, ch2_h, ch1_h,
+					 PRP_CHANNEL_1);
+			goto exit_cascade;
+		}
+	} else {
+		/*
+		 * Try cascade resize for width, width is multiple of 2.
+		 * Channel 2 is not used. So we have more values to pick
+		 * for channel 2 resize.
+		 */
+		if (in_w * MAX_TBL > ch1_w) {
+			for (w = in_w / 2; w > ch1_w; w /= 2) {
+				/* Ch1 width resize */
+				if (check_simple
+				    (pscale, w, ch1_w, PRP_CHANNEL_1) < 0)
+					continue;
+				/* Ch2 width resize */
+				ch2_w =
+				    check_simple(pscale + 2, in_w, w,
+						 PRP_CHANNEL_1);
+				if (ch2_w < 0) {
+					w = in_w / MAX_TBL;
+					continue;
+				}
+				check_simple(pscale, ch2_w, ch1_w,
+					     PRP_CHANNEL_1);
+				break;
+			}
+		} else {
+			w = check_simple(pscale, in_w, ch1_w, PRP_CHANNEL_1);
+			ch2_w = check_simple(pscale + 2, w, w, PRP_CHANNEL_1);
+		}
+		if (ch2_w >= ch1_w) {
+			if (in_h * MAX_TBL > ch1_h) {
+				/* try cascade resize for height */
+				for (h = in_h / 2; h > ch1_h; h /= 2) {
+					/* Ch2 height resize */
+					if (check_simple
+					    (pscale + 1, h, ch1_h,
+					     PRP_CHANNEL_1) < 0)
+						continue;
+					/* Ch1 height resize */
+					ch2_h =
+					    check_simple(pscale + 3, in_h, h,
+							 PRP_CHANNEL_1);
+					if (ch2_w < 0) {
+						h = in_h / MAX_TBL;
+						continue;
+					}
+					check_simple(pscale + 1, ch2_h, ch1_h,
+						     PRP_CHANNEL_1);
+					break;
+				}
+			} else {
+				h = check_simple(pscale + 1, in_h, ch1_h,
+						 PRP_CHANNEL_1);
+				ch2_h =
+				    check_simple(pscale + 3, h, h,
+						 PRP_CHANNEL_1);
+			}
+
+			goto exit_cascade;
+		}
+	}
+
+
+	pr_debug("Ch1 resize error.\n");
+	return -1;
+
+      exit_parallel:
+	cfg->ch1_scale.algo |= PRP_ALGO_BYPASS;
+	pr_debug("ch1 parallel resize.\n");
+	pr_debug("original width = %d internel width = %d\n", ch1_w, w);
+	pr_debug("original height = %d internel height = %d\n", ch1_h, h);
+	return 0;
+
+      exit_cascade:
+	cfg->ch1_scale.algo &= ~PRP_ALGO_BYPASS;
+	pr_debug("ch1 cascade resize.\n");
+	pr_debug("[width] in : ch2 : ch1=%d : %d : %d\n", in_w, ch2_w, ch1_w);
+	pr_debug("[height] in : ch2 : ch1=%d : %d : %d\n", in_h, ch2_h, ch1_h);
+	return 0;
+}
+
+/*!
+ * @brief Check if the resize ratio is supported by PrP channel 2
+ * @param cfg	Pointer to emma_prp_cfg structure
+ * @return	Zero on success, others on failure
+ */
+static int prp_resize_check_ch2(emma_prp_cfg * cfg)
+{
+	int w, h;
+	scale_t *pscale = &cfg->scale[2];	/* Ch2 width resize coeff */
+
+	if (cfg->ch2_pix == PRP_PIX2_UNUSED)
+		return 0;
+
+	w = check_simple(pscale, cfg->in_width, cfg->ch2_width, PRP_CHANNEL_2);
+	h = check_simple(pscale + 1, cfg->in_height, cfg->ch2_height,
+			 PRP_CHANNEL_2);
+	if ((w != -1) && (h != -1)) {
+		pr_debug("Ch2 resize.\n");
+		pr_debug("Original width = %d internel width = %d\n",
+			 cfg->ch2_width, w);
+		pr_debug("Original height = %d internel height = %d\n",
+			 cfg->ch2_height, h);
+		return 0;
+	} else {
+		pr_debug("Ch2 resize error.\n");
+		return -1;
+	}
+}
Index: linux-2.6.18/drivers/media/video/mxc/capture/mx27_v4l2_capture.c
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/media/video/mxc/capture/mx27_v4l2_capture.c
@@ -0,0 +1,2215 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mx27_v4l2_capture.c
+ *
+ * @brief MX27 Video For Linux 2 driver
+ *
+ * @ingroup MXC_V4L2_CAPTURE
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/ctype.h>
+#include <linux/pagemap.h>
+#include <linux/vmalloc.h>
+#include <linux/types.h>
+#include <linux/fb.h>
+#include <linux/pci.h>
+#include <linux/platform_device.h>
+#include <linux/version.h>
+#include <media/v4l2-dev.h>
+#include <asm/io.h>
+#include <asm/semaphore.h>
+
+#include "mxc_v4l2_capture.h"
+#include "mx27_prp.h"
+#include "mx27_csi.h"
+
+static int csi_mclk_flag_backup;
+static int video_nr = -1;
+static cam_data *g_cam;
+
+static int dq_intr_cnt=0;
+static int dq_timeout_cnt=0;
+static int empty_wq_cnt=0;
+
+/*!
+ * Free frame buffers
+ *
+ * @param cam      Structure cam_data *
+ *
+ * @return status  0 success.
+ */
+static int mxc_free_frame_buf(cam_data * cam)
+{
+	int i;
+
+	for (i = 0; i < FRAME_NUM; i++) {
+		if (cam->frame[i].vaddress != 0) {
+			dma_free_coherent(0,
+					  cam->frame[i].buffer.length,
+					  cam->frame[i].vaddress,
+					  cam->frame[i].paddress);
+			cam->frame[i].vaddress = 0;
+		}
+	}
+
+	return 0;
+}
+
+/*!
+ * Allocate frame buffers
+ *
+ * @param cam      Structure cam_data *
+ *
+ * @param count    int number of buffer need to allocated
+ *
+ * @return status  -0 Successfully allocated a buffer, -ENOBUFS	failed.
+ */
+static int mxc_allocate_frame_buf(cam_data * cam, int count)
+{
+	int i;
+
+	for (i = 0; i < count; i++) {
+		cam->frame[i].vaddress = dma_alloc_coherent(0,
+							    PAGE_ALIGN(cam->v2f.
+								       fmt.pix.
+								       sizeimage),
+							    &cam->frame[i].
+							    paddress,
+							    GFP_DMA |
+							    GFP_KERNEL);
+		if (cam->frame[i].vaddress == 0) {
+			pr_debug("mxc_allocate_frame_buf failed.\n");
+			mxc_free_frame_buf(cam);
+			return -ENOBUFS;
+		}
+		cam->frame[i].buffer.index = i;
+		cam->frame[i].buffer.flags = V4L2_BUF_FLAG_MAPPED;
+		cam->frame[i].buffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		cam->frame[i].buffer.length =
+		    PAGE_ALIGN(cam->v2f.fmt.pix.sizeimage);
+		cam->frame[i].buffer.memory = V4L2_MEMORY_MMAP;
+		cam->frame[i].buffer.m.offset = cam->frame[i].paddress;
+		cam->frame[i].index = i;
+	}
+
+	return 0;
+}
+
+/*!
+ * Free frame buffers status
+ *
+ * @param cam    Structure cam_data *
+ *
+ * @return none
+ */
+static void mxc_free_frames(cam_data * cam)
+{
+	int i;
+
+	for (i = 0; i < FRAME_NUM; i++) {
+		cam->frame[i].buffer.flags = V4L2_BUF_FLAG_MAPPED;
+	}
+
+	cam->enc_counter = 0;
+	cam->skip_frame = 0;
+	INIT_LIST_HEAD(&cam->ready_q);
+	INIT_LIST_HEAD(&cam->working_q);
+	INIT_LIST_HEAD(&cam->done_q);
+}
+
+/*!
+ * Return the buffer status
+ *
+ * @param cam 	   Structure cam_data *
+ * @param buf      Structure v4l2_buffer *
+ *
+ * @return status  0 success, EINVAL failed.
+ */
+static int mxc_v4l2_buffer_status(cam_data * cam, struct v4l2_buffer *buf)
+{
+	/* check range */
+	if (buf->index < 0 || buf->index >= FRAME_NUM) {
+		pr_debug("mxc_v4l2_buffer_status buffers not allocated\n");
+		return -EINVAL;
+	}
+
+	memcpy(buf, &(cam->frame[buf->index].buffer), sizeof(*buf));
+	return 0;
+}
+
+/*!
+ * start the encoder job
+ *
+ * @param cam      structure cam_data *
+ *
+ * @return status  0 Success
+ */
+static int mxc_streamon(cam_data * cam)
+{
+	struct mxc_v4l_frame *frame;
+	int err = 0;
+
+	if (!cam)
+		return -EIO;
+
+	if (list_empty(&cam->ready_q)) {
+		printk(KERN_ERR "mxc_streamon buffer not been queued yet\n");
+		return -EINVAL;
+	}
+
+	cam->capture_pid = current->pid;
+
+	if (cam->enc_enable) {
+		err = cam->enc_enable(cam);
+		if (err != 0) {
+			return err;
+		}
+	}
+
+	cam->ping_pong_csi = 0;
+	if (cam->enc_update_eba) {
+		frame =
+		    list_entry(cam->ready_q.next, struct mxc_v4l_frame, queue);
+		list_del(cam->ready_q.next);
+		list_add_tail(&frame->queue, &cam->working_q);
+		err = cam->enc_update_eba(frame->paddress, &cam->ping_pong_csi);
+
+		frame =
+		    list_entry(cam->ready_q.next, struct mxc_v4l_frame, queue);
+		list_del(cam->ready_q.next);
+		list_add_tail(&frame->queue, &cam->working_q);
+		err |=
+		    cam->enc_update_eba(frame->paddress, &cam->ping_pong_csi);
+	} else {
+		return -EINVAL;
+	}
+
+	return err;
+}
+
+/*!
+ * Shut down the encoder job
+ *
+ * @param cam      structure cam_data *
+ *
+ * @return status  0 Success
+ */
+static int mxc_streamoff(cam_data * cam)
+{
+	int err = 0;
+
+	if (!cam)
+		return -EIO;
+
+	if (cam->enc_disable) {
+		err = cam->enc_disable(cam);
+	}
+	mxc_free_frames(cam);
+	return err;
+}
+
+/*!
+ * Valid whether the palette is supported
+ *
+ * @param palette pixel format
+ *
+ * @return 0 if failed
+ */
+static inline int valid_mode(u32 palette)
+{
+	/*
+	 * MX27 PrP channel 2 supports YUV444, but YUV444 is not
+	 * defined by V4L2 :(
+	 */
+	return ((palette == V4L2_PIX_FMT_YUYV) ||
+		(palette == V4L2_PIX_FMT_YUV420));
+}
+
+/*!
+ * Valid and adjust the overlay window size, position
+ *
+ * @param cam      structure cam_data *
+ * @param win      struct v4l2_window  *
+ *
+ * @return 0
+ */
+static int verify_preview(cam_data * cam, struct v4l2_window *win)
+{
+	if (cam->output >= num_registered_fb) {
+		pr_debug("verify_preview No matched.\n");
+		return -1;
+	}
+	cam->overlay_fb = (struct fb_info *)registered_fb[cam->output];
+
+	/* TODO: suppose 16bpp, 4 bytes alignment */
+	win->w.left &= ~0x1;
+
+	if (win->w.width + win->w.left > cam->overlay_fb->var.xres)
+		win->w.width = cam->overlay_fb->var.xres - win->w.left;
+	if (win->w.height + win->w.top > cam->overlay_fb->var.yres)
+		win->w.height = cam->overlay_fb->var.yres - win->w.top;
+
+	/*
+	 * TODO: suppose 16bpp. Rounded down to a multiple of 2 pixels for
+	 * width according to PrP limitations.
+	 */
+	if ((cam->rotation == V4L2_MXC_ROTATE_90_RIGHT)
+	    || (cam->rotation == V4L2_MXC_ROTATE_90_RIGHT_VFLIP)
+	    || (cam->rotation == V4L2_MXC_ROTATE_90_RIGHT_HFLIP)
+	    || (cam->rotation == V4L2_MXC_ROTATE_90_LEFT))
+		win->w.height &= ~0x1;
+	else
+		win->w.width &= ~0x1;
+
+	return 0;
+}
+
+/*!
+ * start the viewfinder job
+ *
+ * @param cam      structure cam_data *
+ *
+ * @return status  0 Success
+ */
+static int start_preview(cam_data * cam)
+{
+	int err = 0;
+
+	err = prp_vf_select(cam);
+	if (err != 0)
+		return err;
+
+	cam->overlay_pid = current->pid;
+	err = cam->vf_start_sdc(cam);
+
+	return err;
+}
+
+/*!
+ * shut down the viewfinder job
+ *
+ * @param cam      structure cam_data *
+ *
+ * @return status  0 Success
+ */
+static int stop_preview(cam_data * cam)
+{
+	int err = 0;
+
+	err = prp_vf_deselect(cam);
+	return err;
+}
+
+/*!
+ * V4L2 - mxc_v4l2_g_fmt function
+ *
+ * @param cam         structure cam_data *
+ *
+ * @param f           structure v4l2_format *
+ *
+ * @return  status    0 success, EINVAL failed
+ */
+static int mxc_v4l2_g_fmt(cam_data * cam, struct v4l2_format *f)
+{
+	int retval = 0;
+
+	switch (f->type) {
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		f->fmt.pix.width = cam->v2f.fmt.pix.width;
+		f->fmt.pix.height = cam->v2f.fmt.pix.height;
+		f->fmt.pix.sizeimage = cam->v2f.fmt.pix.sizeimage;
+		f->fmt.pix.pixelformat = cam->v2f.fmt.pix.pixelformat;
+		f->fmt.pix.bytesperline = cam->v2f.fmt.pix.bytesperline;
+		f->fmt.pix.colorspace = V4L2_COLORSPACE_JPEG;
+		retval = 0;
+		break;
+	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
+		f->fmt.win = cam->win;
+		break;
+	default:
+		retval = -EINVAL;
+	}
+	return retval;
+}
+
+/*!
+ * V4L2 - mxc_v4l2_s_fmt function
+ *
+ * @param cam         structure cam_data *
+ *
+ * @param f           structure v4l2_format *
+ *
+ * @return  status    0 success, EINVAL failed
+ */
+static int mxc_v4l2_s_fmt(cam_data * cam, struct v4l2_format *f)
+{
+	int retval = 0;
+	int size = 0;
+	int bytesperline = 0;
+
+	switch (f->type) {
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		if (!valid_mode(f->fmt.pix.pixelformat)) {
+			pr_debug("mxc_v4l2_s_fmt: format not supported\n");
+			retval = -EINVAL;
+		}
+
+		if (cam->rotation != V4L2_MXC_ROTATE_NONE)
+			pr_debug("mxc_v4l2_s_fmt: capture rotation ignored\n");
+
+		switch (f->fmt.pix.pixelformat) {
+		case V4L2_PIX_FMT_YUYV:
+			f->fmt.pix.width &= ~0x1;	/* Multiple of 2 */
+			size = f->fmt.pix.width * f->fmt.pix.height * 2;
+			bytesperline = f->fmt.pix.width * 2;
+			break;
+		case V4L2_PIX_FMT_YUV420:
+			f->fmt.pix.width &= ~0x7;	/* Multiple of 8 */
+			f->fmt.pix.height &= ~0x1;	/* Multiple of 2 */
+			size = f->fmt.pix.width * f->fmt.pix.height * 3 / 2;
+			bytesperline = f->fmt.pix.width * 3 / 2;
+			break;
+		default:
+			/* Suppose it's YUV444 or 32bpp */
+			size = f->fmt.pix.width * f->fmt.pix.height * 4;
+			bytesperline = f->fmt.pix.width * 4;
+			pr_info("mxc_v4l2_s_fmt: default assume"
+				" to be YUV444 interleaved.\n");
+			break;
+		}
+
+		if (f->fmt.pix.bytesperline < bytesperline) {
+			f->fmt.pix.bytesperline = bytesperline;
+		} else {
+			bytesperline = f->fmt.pix.bytesperline;
+		}
+
+		if (f->fmt.pix.sizeimage > size) {
+			pr_debug("mxc_v4l2_s_fmt: sizeimage bigger than"
+				 " needed.\n");
+			size = f->fmt.pix.sizeimage;
+		}
+		f->fmt.pix.sizeimage = size;
+
+		cam->v2f.fmt.pix.sizeimage = size;
+		cam->v2f.fmt.pix.bytesperline = bytesperline;
+		cam->v2f.fmt.pix.width = f->fmt.pix.width;
+		cam->v2f.fmt.pix.height = f->fmt.pix.height;
+		cam->v2f.fmt.pix.pixelformat = f->fmt.pix.pixelformat;
+		retval = 0;
+		break;
+	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
+		retval = verify_preview(cam, &f->fmt.win);
+		cam->win = f->fmt.win;
+		break;
+	default:
+		retval = -EINVAL;
+	}
+	return retval;
+}
+
+/*!
+ * get control param
+ *
+ * @param cam         structure cam_data *
+ *
+ * @param c           structure v4l2_control *
+ *
+ * @return  status    0 success, EINVAL failed
+ */
+static int mxc_get_v42l_control(cam_data * cam, struct v4l2_control *c)
+{
+	int status = 0;
+
+	switch (c->id) {
+	case V4L2_CID_HFLIP:
+		c->value = cam->rotation;
+		break;
+	case V4L2_CID_VFLIP:
+		c->value = cam->rotation;
+		break;
+	case V4L2_CID_MXC_ROT:
+		c->value = cam->rotation;
+		break;
+	case V4L2_CID_BRIGHTNESS:
+		c->value = cam->bright;
+		break;
+	case V4L2_CID_HUE:
+		c->value = cam->hue;
+		break;
+	case V4L2_CID_CONTRAST:
+		c->value = cam->contrast;
+		break;
+	case V4L2_CID_SATURATION:
+		c->value = cam->saturation;
+		break;
+	case V4L2_CID_RED_BALANCE:
+		c->value = cam->red;
+		break;
+	case V4L2_CID_BLUE_BALANCE:
+		c->value = cam->blue;
+		break;
+	case V4L2_CID_BLACK_LEVEL:
+		c->value = cam->ae_mode;
+		break;
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		c->value = cam->awb_enable;
+		break;
+	case V4L2_CID_AUTOGAIN:
+		c->value = cam->ae_enable;
+		break;
+	case V4L2_CID_MXC_FLICKER:
+		c->value = cam->flicker_ctrl;
+		break;
+	default:
+		status = -EINVAL;
+	}
+	return status;
+}
+
+/*!
+ * V4L2 - set_control function
+ * V4L2_CID_MXC_ROT is the extention for rotation/mirroring.
+ *
+ * @param cam         structure cam_data *
+ *
+ * @param c           structure v4l2_control *
+ *
+ * @return  status    0 success, EINVAL failed
+ */
+static int mxc_set_v42l_control(cam_data * cam, struct v4l2_control *c)
+{
+	switch (c->id) {
+	case V4L2_CID_HFLIP:
+		if (c->value == 1) {
+			if ((cam->rotation != V4L2_MXC_ROTATE_VERT_FLIP) &&
+			    (cam->rotation != V4L2_MXC_ROTATE_180))
+				cam->rotation = V4L2_MXC_ROTATE_HORIZ_FLIP;
+			else
+				cam->rotation = V4L2_MXC_ROTATE_180;
+		} else {
+			if (cam->rotation == V4L2_MXC_ROTATE_HORIZ_FLIP)
+				cam->rotation = V4L2_MXC_ROTATE_NONE;
+			else if (cam->rotation == V4L2_MXC_ROTATE_180)
+				cam->rotation = V4L2_MXC_ROTATE_VERT_FLIP;
+		}
+		break;
+	case V4L2_CID_VFLIP:
+		if (c->value == 1) {
+			if ((cam->rotation != V4L2_MXC_ROTATE_HORIZ_FLIP) &&
+			    (cam->rotation != V4L2_MXC_ROTATE_180))
+				cam->rotation = V4L2_MXC_ROTATE_VERT_FLIP;
+			else
+				cam->rotation = V4L2_MXC_ROTATE_180;
+		} else {
+			if (cam->rotation == V4L2_MXC_ROTATE_VERT_FLIP)
+				cam->rotation = V4L2_MXC_ROTATE_NONE;
+			if (cam->rotation == V4L2_MXC_ROTATE_180)
+				cam->rotation = V4L2_MXC_ROTATE_HORIZ_FLIP;
+		}
+		break;
+	case V4L2_CID_MXC_ROT:
+		switch (c->value) {
+		case V4L2_MXC_ROTATE_NONE:
+		case V4L2_MXC_ROTATE_VERT_FLIP:
+		case V4L2_MXC_ROTATE_HORIZ_FLIP:
+		case V4L2_MXC_ROTATE_180:
+		case V4L2_MXC_ROTATE_90_RIGHT:
+		case V4L2_MXC_ROTATE_90_RIGHT_VFLIP:
+		case V4L2_MXC_ROTATE_90_RIGHT_HFLIP:
+		case V4L2_MXC_ROTATE_90_LEFT:
+			cam->rotation = c->value;
+			break;
+		default:
+			return -EINVAL;
+		}
+		break;
+	case V4L2_CID_HUE:
+		cam->hue = c->value;
+		break;
+	case V4L2_CID_CONTRAST:
+		cam->contrast = c->value;
+		break;
+	case V4L2_CID_BRIGHTNESS:
+		cam->bright = c->value;
+	case V4L2_CID_SATURATION:
+		cam->saturation = c->value;
+	case V4L2_CID_RED_BALANCE:
+		cam->red = c->value;
+	case V4L2_CID_BLUE_BALANCE:
+		cam->blue = c->value;
+		csi_enable_mclk(CSI_MCLK_I2C, true, true);
+		cam->cam_sensor->set_color(cam->bright, cam->saturation,
+					   cam->red, cam->green, cam->blue);
+		csi_enable_mclk(CSI_MCLK_I2C, false, false);
+		break;
+	case V4L2_CID_BLACK_LEVEL:
+		cam->ae_mode = c->value & 0x03;
+		csi_enable_mclk(CSI_MCLK_I2C, true, true);
+		if (cam->cam_sensor->set_ae_mode)
+			cam->cam_sensor->set_ae_mode(cam->ae_mode);
+		csi_enable_mclk(CSI_MCLK_I2C, false, false);
+		break;
+	case V4L2_CID_MXC_FLASH:
+		break;
+	case V4L2_CID_AUTOGAIN:
+		cam->ae_enable = c->value;
+		csi_enable_mclk(CSI_MCLK_I2C, true, true);
+		if (cam->cam_sensor->set_ae)
+			cam->cam_sensor->set_ae(cam->ae_enable);
+		csi_enable_mclk(CSI_MCLK_I2C, false, false);
+		break;
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		cam->awb_enable = c->value;
+		csi_enable_mclk(CSI_MCLK_I2C, true, true);
+		if (cam->cam_sensor->set_awb)
+			cam->cam_sensor->set_awb(cam->awb_enable);
+		csi_enable_mclk(CSI_MCLK_I2C, false, false);
+		break;
+	case V4L2_CID_MXC_FLICKER:
+		cam->flicker_ctrl = c->value;
+		csi_enable_mclk(CSI_MCLK_I2C, true, true);
+		if (cam->cam_sensor->flicker_control)
+			cam->cam_sensor->flicker_control(cam->flicker_ctrl);
+		csi_enable_mclk(CSI_MCLK_I2C, false, false);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/*!
+ * V4L2 - mxc_v4l2_s_param function
+ *
+ * @param cam         structure cam_data *
+ *
+ * @param parm        structure v4l2_streamparm *
+ *
+ * @return  status    0 success, EINVAL failed
+ */
+static int mxc_v4l2_s_param(cam_data * cam, struct v4l2_streamparm *parm)
+{
+	sensor_interface *param;
+	csi_signal_cfg_t csi_param;
+
+	if (parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		pr_debug("mxc_v4l2_s_param invalid type\n");
+		return -EINVAL;
+	}
+
+	if (parm->parm.capture.timeperframe.denominator >
+	    cam->standard.frameperiod.denominator) {
+		pr_debug("mxc_v4l2_s_param frame rate %d larger "
+			 "than standard supported %d\n",
+			 parm->parm.capture.timeperframe.denominator,
+			 cam->standard.frameperiod.denominator);
+		return -EINVAL;
+	}
+
+	cam->streamparm.parm.capture.capability = V4L2_CAP_TIMEPERFRAME;
+
+	csi_enable_mclk(CSI_MCLK_I2C, true, true);
+	param = cam->cam_sensor->config
+	    (&parm->parm.capture.timeperframe.denominator,
+	     parm->parm.capture.capturemode);
+	csi_enable_mclk(CSI_MCLK_I2C, false, false);
+
+	cam->streamparm.parm.capture.timeperframe =
+	    parm->parm.capture.timeperframe;
+
+	if ((parm->parm.capture.capturemode != 0) &&
+	    (parm->parm.capture.capturemode != V4L2_MODE_HIGHQUALITY)) {
+		pr_debug("mxc_v4l2_s_param frame un-supported capture mode\n");
+		return -EINVAL;
+	}
+
+	if (parm->parm.capture.capturemode ==
+	    cam->streamparm.parm.capture.capturemode) {
+		return 0;
+	}
+
+	/* resolution changed, so need to re-program the CSI */
+	csi_param.sens_clksrc = 0;
+	csi_param.clk_mode = param->clk_mode;
+	csi_param.pixclk_pol = param->pixclk_pol;
+	csi_param.data_width = param->data_width;
+	csi_param.data_pol = param->data_pol;
+	csi_param.ext_vsync = param->ext_vsync;
+	csi_param.Vsync_pol = param->Vsync_pol;
+	csi_param.Hsync_pol = param->Hsync_pol;
+	csi_init_interface(param->width, param->height, param->pixel_fmt,
+			   csi_param);
+
+	if (parm->parm.capture.capturemode != V4L2_MODE_HIGHQUALITY) {
+		cam->streamparm.parm.capture.capturemode = 0;
+	} else {
+		cam->streamparm.parm.capture.capturemode =
+		    V4L2_MODE_HIGHQUALITY;
+		cam->streamparm.parm.capture.extendedmode =
+		    parm->parm.capture.extendedmode;
+		cam->streamparm.parm.capture.readbuffers = 1;
+	}
+	return 0;
+}
+
+/*!
+ * Dequeue one V4L capture buffer
+ *
+ * @param cam         structure cam_data *
+ * @param buf         structure v4l2_buffer *
+ *
+ * @return  status    0 success, EINVAL invalid frame number,
+ *                    ETIME timeout, ERESTARTSYS interrupted by user
+ */
+static int mxc_v4l_dqueue(cam_data * cam, struct v4l2_buffer *buf)
+{
+	int retval = 0;
+	struct mxc_v4l_frame *frame;
+
+    cont:
+	if (!wait_event_interruptible_timeout(cam->enc_queue,
+					      cam->enc_counter != 0, 10 * HZ)) {
+		if( (dq_timeout_cnt & 0x1f) == 0)
+			printk(KERN_ERR "mxc_v4l_dqueue timeout enc_counter %x\n",
+			       cam->enc_counter);
+		dq_timeout_cnt++;
+		if (cam->overflow == 1) {
+			cam->enc_enable(cam);
+		    cam->overflow = 0;
+		    if (!list_empty(&cam->ready_q)) {
+			    frame =
+				list_entry(cam->ready_q.next,
+					   struct mxc_v4l_frame, queue);
+			    list_del(cam->ready_q.next);
+			    list_add_tail(&frame->queue, &cam->working_q);
+			    cam->enc_update_eba(frame->paddress,
+					    &cam->ping_pong_csi);
+		    }
+		    goto cont;
+		}
+		return -ETIME;
+	} else if (signal_pending(current)) {
+		if(dq_intr_cnt == 0)
+			printk(KERN_ERR "mxc_v4l_dqueue() interrupt received %d\n",dq_intr_cnt);
+		dq_intr_cnt++;
+		if (cam->overflow == 1) {
+			cam->enc_enable(cam);
+			cam->overflow = 0;
+			if (!list_empty(&cam->ready_q)) {
+				frame =
+				    list_entry(cam->ready_q.next,
+					       struct mxc_v4l_frame, queue);
+				list_del(cam->ready_q.next);
+				list_add_tail(&frame->queue, &cam->working_q);
+				cam->enc_update_eba(frame->paddress,
+						    &cam->ping_pong_csi);
+			}
+			goto cont;
+		}
+		return -ERESTARTSYS;
+	}
+
+	if (cam->overflow == 1) {
+		cam->enc_enable(cam);
+		cam->overflow = 0;
+		if (!list_empty(&cam->ready_q)) {
+			frame =
+			    list_entry(cam->ready_q.next, struct mxc_v4l_frame,
+				       queue);
+			list_del(cam->ready_q.next);
+			list_add_tail(&frame->queue, &cam->working_q);
+			cam->enc_update_eba(frame->paddress,
+					    &cam->ping_pong_csi);
+		}
+		printk(KERN_INFO "mxc_v4l_dqueue - overflow\n");
+
+	}
+
+
+	cam->enc_counter--;
+
+	frame = list_entry(cam->done_q.next, struct mxc_v4l_frame, queue);
+	list_del(cam->done_q.next);
+	if (frame->buffer.flags & V4L2_BUF_FLAG_DONE) {
+		frame->buffer.flags &= ~V4L2_BUF_FLAG_DONE;
+	} else if (frame->buffer.flags & V4L2_BUF_FLAG_QUEUED) {
+		printk(KERN_ERR "VIDIOC_DQBUF: Buffer not filled.\n");
+		frame->buffer.flags &= ~V4L2_BUF_FLAG_QUEUED;
+		retval = -EINVAL;
+	} else if ((frame->buffer.flags & 0x7) == V4L2_BUF_FLAG_MAPPED) {
+		printk(KERN_ERR "VIDIOC_DQBUF: Buffer not queued.\n");
+		retval = -EINVAL;
+	}
+
+	buf->bytesused = cam->v2f.fmt.pix.sizeimage;
+	buf->index = frame->index;
+	buf->flags = frame->buffer.flags;
+	return retval;
+}
+
+/*!
+ * Get the current attached camera device
+ *
+ * @param inode      struct i2c_client *
+ *
+ * @param int       int * p_input_index
+ *
+ * @return           0 success, ENODEV for invalid device instance,
+ *                   -1 for other errors.
+ */
+static int mxc_get_video_input(cam_data * cam)
+{
+	int retval = 0;
+	csi_enable_mclk(CSI_MCLK_I2C, true, true);
+	retval = cam->cam_sensor->get_status();
+	csi_enable_mclk(CSI_MCLK_I2C, false, false);
+	return retval;
+}
+
+/*!
+ * V4L interface - open function
+ *
+ * @param inode        structure inode *
+ * @param file         structure file *
+ *
+ * @return  status    0 success, ENODEV invalid device instance,
+ *                    ENODEV timeout, ERESTARTSYS interrupted by user
+ */
+static int mxc_v4l_open(struct inode *inode, struct file *file)
+{
+	sensor_interface *param;
+	csi_signal_cfg_t csi_param;
+	struct video_device *dev = video_devdata(file);
+	cam_data *cam = dev->priv;
+	int err = 0;
+
+	dq_intr_cnt    = 0;
+	dq_timeout_cnt = 0;
+	empty_wq_cnt   = 0;
+	if (!cam) {
+		pr_info("Internal error, cam_data not found!\n");
+		return -ENODEV;
+	}
+
+	err = mxc_get_video_input(cam);
+	if (0 != err)
+		return -ENODEV;
+
+	if (down_interruptible(&cam->busy_lock))
+		return -EINTR;
+
+	if (signal_pending(current))
+		goto oops;
+
+	if (cam->open_count++ == 0) {
+		wait_event_interruptible(cam->power_queue,
+					 cam->low_power == false);
+
+		err = prp_enc_select(cam);
+
+		cam->enc_counter = 0;
+		cam->skip_frame = 0;
+		INIT_LIST_HEAD(&cam->ready_q);
+		INIT_LIST_HEAD(&cam->working_q);
+		INIT_LIST_HEAD(&cam->done_q);
+
+		csi_enable_mclk(CSI_MCLK_I2C, true, true);
+		param = cam->cam_sensor->reset();
+		csi_param.sens_clksrc = 0;
+		csi_param.clk_mode = param->clk_mode;
+		csi_param.pixclk_pol = param->pixclk_pol;
+		csi_param.data_width = param->data_width;
+		csi_param.data_pol = param->data_pol;
+		csi_param.ext_vsync = param->ext_vsync;
+		csi_param.Vsync_pol = param->Vsync_pol;
+		csi_param.Hsync_pol = param->Hsync_pol;
+		csi_init_interface(param->width, param->height,
+				   param->pixel_fmt, csi_param);
+		cam->cam_sensor->get_color(&cam->bright, &cam->saturation,
+					   &cam->red, &cam->green, &cam->blue);
+		cam->cam_sensor->get_ae_mode(&cam->ae_mode);
+		cam->cam_sensor->get_control_params(&cam->ae_enable,
+						    &cam->awb_enable,
+						    &cam->flicker_ctrl);
+		csi_enable_mclk(CSI_MCLK_I2C, false, false);
+		prp_init(cam);
+
+	}
+
+	file->private_data = dev;
+      oops:
+	up(&cam->busy_lock);
+	return err;
+}
+
+/*!
+ * V4L interface - close function
+ *
+ * @param inode    struct inode *
+ * @param file     struct file *
+ *
+ * @return         0 success
+ */
+static int mxc_v4l_close(struct inode *inode, struct file *file)
+{
+	struct video_device *dev = video_devdata(file);
+	int err = 0;
+	cam_data *cam = dev->priv;
+
+	/* for the case somebody hit the ctrl C */
+	if (cam->overlay_pid == current->pid) {
+		err = stop_preview(cam);
+		cam->overlay_on = false;
+	}
+	if (cam->capture_pid == current->pid) {
+		err |= mxc_streamoff(cam);
+		cam->capture_on = false;
+		wake_up_interruptible(&cam->enc_queue);
+	}
+
+	if (--cam->open_count == 0) {
+		wait_event_interruptible(cam->power_queue,
+					 cam->low_power == false);
+		pr_debug("mxc_v4l_close: release resource\n");
+
+		err |= prp_enc_deselect(cam);
+
+		mxc_free_frame_buf(cam);
+		file->private_data = NULL;
+
+		/* capture off */
+		wake_up_interruptible(&cam->enc_queue);
+		mxc_free_frames(cam);
+		cam->enc_counter++;
+		prp_exit(cam);
+	}
+
+	return err;
+}
+
+#ifdef CONFIG_VIDEO_MXC_CSI_DMA
+#include <asm/arch/dma.h>
+
+#define CSI_DMA_STATUS_IDLE	0	/* DMA is not started */
+#define CSI_DMA_STATUS_WORKING	1	/* DMA is transfering the data */
+#define CSI_DMA_STATUS_DONE	2	/* One frame completes successfully */
+#define CSI_DMA_STATUS_ERROR	3	/* Error occurs during the DMA */
+
+/*
+ * Sometimes the start of the DMA is not synchronized with the CSI
+ * SOF (Start of Frame) interrupt which will lead to incorrect
+ * captured image. In this case the driver will re-try capturing
+ * another frame. The following macro defines the maximum re-try
+ * times.
+ */
+#define CSI_DMA_RETRY		8
+
+/*
+ * Size of the physical contiguous memory area used to hold image data
+ * transfered by DMA. It can be less than the size of the image data.
+ */
+#define CSI_MEM_SIZE		(1024 * 600)
+
+/* Number of bytes for one DMA transfer */
+#define CSI_DMA_LENGTH		(1024 * 200)
+
+static int g_dma_channel = 0;
+static int g_dma_status = CSI_DMA_STATUS_DONE;
+static volatile int g_dma_completed;	/* number of completed DMA transfers */
+static volatile int g_dma_copied;	/* number of copied DMA transfers */
+static struct tasklet_struct g_dma_tasklet;
+static char *g_user_buf;	/* represents the buf passed by read() */
+static int g_user_count;	/* represents the count passed by read() */
+
+/*!
+ * @brief setup the DMA to transfer data
+ *	  There may be more than one DMA to transfer the whole image. Those
+ *	  DMAs work like chain. This function is used to setup the DMA in
+ *	  case there is enough space to hold the data.
+ * @param	data	pointer to the cam structure
+ */
+static void mxc_csi_dma_chaining(void *data)
+{
+	cam_data *cam = (cam_data *) data;
+	int count, chained = 0;
+	int max_dma = CSI_MEM_SIZE / CSI_DMA_LENGTH;
+	mxc_dma_requestbuf_t dma_request;
+
+	while (chained * CSI_DMA_LENGTH < g_user_count) {
+		/*
+		 * Calculate how many bytes the DMA should transfer. It may
+		 * be less than CSI_DMA_LENGTH if the DMA is the last one.
+		 */
+		if ((chained + 1) * CSI_DMA_LENGTH > g_user_count)
+			count = g_user_count - chained * CSI_DMA_LENGTH;
+		else
+			count = CSI_DMA_LENGTH;
+		pr_debug("%s() DMA chained count = %d\n", __FUNCTION__, count);
+
+		/* Config DMA */
+		memset(&dma_request, 0, sizeof(mxc_dma_requestbuf_t));
+		dma_request.dst_addr = cam->still_buf
+		    + (chained % max_dma) * CSI_DMA_LENGTH;
+		dma_request.src_addr = (dma_addr_t) CSI_CSIRXFIFO_PHYADDR;
+		dma_request.num_of_bytes = count;
+		mxc_dma_config(g_dma_channel, &dma_request, 1,
+			       MXC_DMA_MODE_READ);
+
+		chained++;
+	}
+}
+
+/*!
+ * @brief Copy image data from physical contiguous memory to user space buffer
+ *	  Once the data are copied, there will be more spare space in the
+ *	  physical contiguous memory to receive data from DMA.
+ * @param	data	pointer to the cam structure
+ */
+static void mxc_csi_dma_task(unsigned long data)
+{
+	cam_data *cam = (cam_data *) data;
+	int count;
+	int max_dma = CSI_MEM_SIZE / CSI_DMA_LENGTH;
+
+	while (g_dma_copied < g_dma_completed) {
+		/*
+		 * Calculate how many bytes the DMA has transfered. It may
+		 * be less than CSI_DMA_LENGTH if the DMA is the last one.
+		 */
+		if ((g_dma_copied + 1) * CSI_DMA_LENGTH > g_user_count)
+			count = g_user_count - g_dma_copied * CSI_DMA_LENGTH;
+		else
+			count = CSI_DMA_LENGTH;
+		if (copy_to_user(g_user_buf + g_dma_copied * CSI_DMA_LENGTH,
+				 cam->still_buf_vaddr + (g_dma_copied % max_dma)
+				 * CSI_DMA_LENGTH, count))
+			pr_debug("Warning: some bytes not copied\n");
+
+		g_dma_copied++;
+	}
+
+	/* If the whole image has been captured */
+	if (g_dma_copied * CSI_DMA_LENGTH >= g_user_count) {
+		cam->still_counter++;
+		wake_up_interruptible(&cam->still_queue);
+	}
+
+	pr_debug("%s() DMA completed = %d copied = %d\n",
+		 __FUNCTION__, g_dma_completed, g_dma_copied);
+}
+
+/*!
+ * @brief DMA interrupt callback function
+ * @param	data	pointer to the cam structure
+ * @param	error	DMA error flag
+ * @param	count	number of bytes transfered by the DMA
+ */
+static void mxc_csi_dma_callback(void *data, int error, unsigned int count)
+{
+	cam_data *cam = (cam_data *) data;
+	int max_dma = CSI_MEM_SIZE / CSI_DMA_LENGTH;
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&cam->int_lock, lock_flags);
+
+	g_dma_completed++;
+
+	if (error != MXC_DMA_DONE) {
+		g_dma_status = CSI_DMA_STATUS_ERROR;
+		pr_debug("%s() DMA error\n", __FUNCTION__);
+	}
+
+	/* If the whole image has been captured */
+	if ((g_dma_status != CSI_DMA_STATUS_ERROR)
+	    && (g_dma_completed * CSI_DMA_LENGTH >= g_user_count))
+		g_dma_status = CSI_DMA_STATUS_DONE;
+
+	if ((g_dma_status == CSI_DMA_STATUS_WORKING) &&
+	    (g_dma_completed >= g_dma_copied + max_dma)) {
+		g_dma_status = CSI_DMA_STATUS_ERROR;
+		pr_debug("%s() Previous buffer over written\n", __FUNCTION__);
+	}
+
+	/* Schedule the tasklet */
+	tasklet_schedule(&g_dma_tasklet);
+
+	spin_unlock_irqrestore(&cam->int_lock, lock_flags);
+
+	pr_debug("%s() count = %d bytes\n", __FUNCTION__, count);
+}
+
+/*!
+ * @brief CSI interrupt callback function
+ * @param	data	pointer to the cam structure
+ * @param	status	CSI interrupt status
+ */
+static void mxc_csi_irq_callback(void *data, unsigned long status)
+{
+	cam_data *cam = (cam_data *) data;
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&cam->int_lock, lock_flags);
+
+	/* Wait for SOF (Start of Frame) interrupt to sync the image */
+	if (status & BIT_SOF_INT) {
+		if (g_dma_status == CSI_DMA_STATUS_IDLE) {
+			/* Start DMA transfer to capture image */
+			mxc_dma_enable(g_dma_channel);
+			g_dma_status = CSI_DMA_STATUS_WORKING;
+			pr_debug("%s() DMA started.\n", __FUNCTION__);
+		} else if (g_dma_status == CSI_DMA_STATUS_WORKING) {
+			/*
+			 * Another SOF occurs during DMA transfer. In this
+			 * case the image is not synchronized so need to
+			 * report error and probably try again.
+			 */
+			g_dma_status = CSI_DMA_STATUS_ERROR;
+			pr_debug("%s() Image is not synchronized with DMA - "
+				 "SOF before DMA completes\n", __FUNCTION__);
+		}
+	}
+
+	spin_unlock_irqrestore(&cam->int_lock, lock_flags);
+
+	pr_debug("%s() g_dma_status = %d\n", __FUNCTION__, g_dma_status);
+}
+
+/*!
+ * V4L interface - read function
+ *
+ * @param file       struct file *
+ * @param read buf   char *
+ * @param count      size_t
+ * @param ppos       structure loff_t *
+ *
+ * @return           bytes read
+ */
+static ssize_t
+mxc_v4l_read(struct file *file, char *buf, size_t count, loff_t * ppos)
+{
+	int err = 0;
+	struct video_device *dev = video_devdata(file);
+	cam_data *cam = dev->priv;
+	int retry = CSI_DMA_RETRY;
+
+	g_user_buf = buf;
+
+	if (down_interruptible(&cam->busy_lock))
+		return -EINTR;
+
+	/* Video capture and still image capture are exclusive */
+	if (cam->capture_on == true) {
+		err = -EBUSY;
+		goto exit0;
+	}
+
+	/* The CSI-DMA can not do CSC */
+	if (cam->v2f.fmt.pix.pixelformat != V4L2_PIX_FMT_YUYV) {
+		pr_info("mxc_v4l_read support YUYV pixel format only\n");
+		err = -EINVAL;
+		goto exit0;
+	}
+
+	/* The CSI-DMA can not do resize or crop */
+	if ((cam->v2f.fmt.pix.width != cam->crop_bounds.width)
+	    || (cam->v2f.fmt.pix.height != cam->crop_bounds.height)) {
+		pr_info("mxc_v4l_read resize is not supported\n");
+		pr_info("supported image size width = %d height = %d\n",
+			cam->crop_bounds.width, cam->crop_bounds.height);
+		err = -EINVAL;
+		goto exit0;
+	}
+	if ((cam->crop_current.left != cam->crop_bounds.left)
+	    || (cam->crop_current.width != cam->crop_bounds.width)
+	    || (cam->crop_current.top != cam->crop_bounds.top)
+	    || (cam->crop_current.height != cam->crop_bounds.height)) {
+		pr_info("mxc_v4l_read cropping is not supported\n");
+		err = -EINVAL;
+		goto exit0;
+	}
+
+	cam->still_buf_vaddr = dma_alloc_coherent(0,
+						  PAGE_ALIGN(CSI_MEM_SIZE),
+						  &cam->still_buf,
+						  GFP_DMA | GFP_KERNEL);
+
+	if (!cam->still_buf_vaddr) {
+		pr_info("mxc_v4l_read failed at allocate still_buf\n");
+		err = -ENOBUFS;
+		goto exit0;
+	}
+
+	/* Initialize DMA */
+	g_dma_channel = mxc_dma_request(MXC_DMA_CSI_RX, "CSI RX DMA");
+	if (g_dma_channel < 0) {
+		pr_debug("mxc_v4l_read failed to request DMA channel\n");
+		err = -EIO;
+		goto exit1;
+	}
+
+	err = mxc_dma_callback_set(g_dma_channel,
+				   (mxc_dma_callback_t) mxc_csi_dma_callback,
+				   (void *)cam);
+	if (err != 0) {
+		pr_debug("mxc_v4l_read failed to set DMA callback\n");
+		err = -EIO;
+		goto exit2;
+	}
+
+	g_user_buf = buf;
+	if (cam->v2f.fmt.pix.sizeimage < count)
+		g_user_count = cam->v2f.fmt.pix.sizeimage;
+	else
+		g_user_count = count & ~0x3;
+
+	tasklet_init(&g_dma_tasklet, mxc_csi_dma_task, (unsigned long)cam);
+	g_dma_status = CSI_DMA_STATUS_DONE;
+	csi_set_callback(mxc_csi_irq_callback, cam);
+	csi_enable_prpif(0);
+
+	/* clear current SOF first */
+	csi_clear_status(BIT_SOF_INT);
+	csi_enable_mclk(CSI_MCLK_RAW, true, true);
+
+	do {
+		g_dma_completed = g_dma_copied = 0;
+		mxc_csi_dma_chaining(cam);
+		cam->still_counter = 0;
+		g_dma_status = CSI_DMA_STATUS_IDLE;
+
+		if (!wait_event_interruptible_timeout(cam->still_queue,
+						      cam->still_counter != 0,
+						      10 * HZ)) {
+			pr_info("mxc_v4l_read timeout counter %x\n",
+				cam->still_counter);
+			err = -ETIME;
+			goto exit3;
+		}
+
+		if (g_dma_status == CSI_DMA_STATUS_DONE)
+			break;
+
+		pr_debug("Now retry image capture\n");
+	} while (retry--);
+
+	if (g_dma_status != CSI_DMA_STATUS_DONE)
+		err = -EIO;
+
+      exit3:
+	csi_enable_prpif(1);
+	g_dma_status = CSI_DMA_STATUS_DONE;
+	csi_set_callback(0, 0);
+	csi_enable_mclk(CSI_MCLK_RAW, false, false);
+	tasklet_kill(&g_dma_tasklet);
+
+      exit2:
+	mxc_dma_free(g_dma_channel);
+
+      exit1:
+	dma_free_coherent(0, PAGE_ALIGN(CSI_MEM_SIZE),
+			  cam->still_buf_vaddr, cam->still_buf);
+	cam->still_buf = 0;
+
+      exit0:
+	up(&cam->busy_lock);
+	if (err < 0)
+		return err;
+	else
+		return g_user_count;
+}
+#else
+/*!
+ * V4L interface - read function
+ *
+ * @param file       struct file *
+ * @param read buf   char *
+ * @param count      size_t
+ * @param ppos       structure loff_t *
+ *
+ * @return           bytes read
+ */
+static ssize_t
+mxc_v4l_read(struct file *file, char *buf, size_t count, loff_t * ppos)
+{
+	int err = 0;
+	u8 *v_address;
+	struct video_device *dev = video_devdata(file);
+	cam_data *cam = dev->priv;
+
+	if (down_interruptible(&cam->busy_lock))
+		return -EINTR;
+
+	/* Video capture and still image capture are exclusive */
+	if (cam->capture_on == true) {
+		err = -EBUSY;
+		goto exit0;
+	}
+
+	v_address = dma_alloc_coherent(0,
+				       PAGE_ALIGN(cam->v2f.fmt.pix.sizeimage),
+				       &cam->still_buf, GFP_DMA | GFP_KERNEL);
+
+	if (!v_address) {
+		pr_info("mxc_v4l_read failed at allocate still_buf\n");
+		err = -ENOBUFS;
+		goto exit0;
+	}
+
+	if (prp_still_select(cam)) {
+		err = -EIO;
+		goto exit1;
+	}
+
+	cam->still_counter = 0;
+	if (cam->csi_start(cam)) {
+		err = -EIO;
+		goto exit2;
+	}
+
+	if (!wait_event_interruptible_timeout(cam->still_queue,
+					      cam->still_counter != 0,
+					      10 * HZ)) {
+		pr_info("mxc_v4l_read timeout counter %x\n",
+			cam->still_counter);
+		err = -ETIME;
+		goto exit2;
+	}
+	err = copy_to_user(buf, v_address, cam->v2f.fmt.pix.sizeimage);
+
+      exit2:
+	prp_still_deselect(cam);
+
+      exit1:
+	dma_free_coherent(0, cam->v2f.fmt.pix.sizeimage, v_address,
+			  cam->still_buf);
+	cam->still_buf = 0;
+
+      exit0:
+	up(&cam->busy_lock);
+	if (err < 0)
+		return err;
+	else
+		return (cam->v2f.fmt.pix.sizeimage - err);
+}
+#endif				/* CONFIG_VIDEO_MXC_CSI_DMA */
+
+/*!
+ * V4L interface - ioctl function
+ *
+ * @param inode      struct inode *
+ *
+ * @param file       struct file *
+ *
+ * @param ioctlnr    unsigned int
+ *
+ * @param arg        void *
+ *
+ * @return           0 success, ENODEV for invalid device instance,
+ *                   -1 for other errors.
+ */
+static int
+mxc_v4l_do_ioctl(struct inode *inode, struct file *file,
+		 unsigned int ioctlnr, void *arg)
+{
+	struct video_device *dev = video_devdata(file);
+	cam_data *cam = dev->priv;
+	int retval = 0;
+	unsigned long lock_flags;
+
+	if (!cam)
+		return -EBADF;
+
+	wait_event_interruptible(cam->power_queue, cam->low_power == false);
+	/* make this _really_ smp-safe */
+	if (down_interruptible(&cam->busy_lock))
+		return -EBUSY;
+
+	switch (ioctlnr) {
+		/*!
+		 * V4l2 VIDIOC_QUERYCAP ioctl
+		 */
+	case VIDIOC_QUERYCAP:{
+			struct v4l2_capability *cap = arg;
+			strcpy(cap->driver, "mxc_v4l2");
+			cap->version = KERNEL_VERSION(0, 1, 11);
+			cap->capabilities = V4L2_CAP_VIDEO_CAPTURE |
+			    V4L2_CAP_VIDEO_OVERLAY | V4L2_CAP_STREAMING
+			    | V4L2_CAP_READWRITE;
+			cap->card[0] = '\0';
+			cap->bus_info[0] = '\0';
+			retval = 0;
+			break;
+		}
+
+		/*!
+		 * V4l2 VIDIOC_G_FMT ioctl
+		 */
+	case VIDIOC_G_FMT:{
+			struct v4l2_format *gf = arg;
+			retval = mxc_v4l2_g_fmt(cam, gf);
+			break;
+		}
+
+		/*!
+		 * V4l2 VIDIOC_S_FMT ioctl
+		 */
+	case VIDIOC_S_FMT:{
+			struct v4l2_format *sf = arg;
+			retval = mxc_v4l2_s_fmt(cam, sf);
+			break;
+		}
+
+		/*!
+		 * V4l2 VIDIOC_REQBUFS ioctl
+		 */
+	case VIDIOC_REQBUFS:{
+			struct v4l2_requestbuffers *req = arg;
+			if (req->count > FRAME_NUM) {
+				pr_info("VIDIOC_REQBUFS: not enough buffer\n");
+				req->count = FRAME_NUM;
+			}
+
+			if ((req->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) ||
+			    (req->memory != V4L2_MEMORY_MMAP)) {
+				pr_debug("VIDIOC_REQBUFS: wrong buffer type\n");
+				retval = -EINVAL;
+				break;
+			}
+
+			mxc_streamoff(cam);
+			mxc_free_frame_buf(cam);
+
+			retval = mxc_allocate_frame_buf(cam, req->count);
+			break;
+		}
+
+		/*!
+		 * V4l2 VIDIOC_QUERYBUF ioctl
+		 */
+	case VIDIOC_QUERYBUF:{
+			struct v4l2_buffer *buf = arg;
+			int index = buf->index;
+
+			if (buf->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+				pr_debug
+				    ("VIDIOC_QUERYBUFS: wrong buffer type\n");
+				retval = -EINVAL;
+				break;
+			}
+
+			memset(buf, 0, sizeof(buf));
+			buf->index = index;
+
+			down(&cam->param_lock);
+			retval = mxc_v4l2_buffer_status(cam, buf);
+			up(&cam->param_lock);
+			break;
+		}
+
+		/*!
+		 * V4l2 VIDIOC_QBUF ioctl
+		 */
+	case VIDIOC_QBUF:{
+			struct v4l2_buffer *buf = arg;
+			int index = buf->index;
+			int overflow = 0;
+
+			pr_debug("VIDIOC_QBUF: %d\n", buf->index);
+			if (cam->overflow == 1) {
+				cam->enc_enable(cam);
+				cam->overflow = 0;
+				overflow = 1;
+				printk(KERN_INFO "VIDIOC_QBUF - overflow\n");
+			}
+
+			spin_lock_irqsave(&cam->int_lock, lock_flags);
+			if ((cam->frame[index].buffer.flags & 0x7) ==
+			    V4L2_BUF_FLAG_MAPPED) {
+				cam->frame[index].buffer.flags |=
+				    V4L2_BUF_FLAG_QUEUED;
+				if ((cam->skip_frame > 0) || (overflow == 1)) {
+					list_add_tail(&cam->frame[index].queue,
+						      &cam->working_q);
+					retval =
+					    cam->enc_update_eba(cam->
+								frame[index].
+								paddress,
+								&cam->
+								ping_pong_csi);
+					cam->skip_frame = 0;
+				} else {
+					list_add_tail(&cam->frame[index].queue,
+						      &cam->ready_q);
+				}
+			} else if (cam->frame[index].buffer.flags &
+				   V4L2_BUF_FLAG_QUEUED) {
+				pr_debug
+				    ("VIDIOC_QBUF: buffer already queued\n");
+			} else if (cam->frame[index].buffer.
+				   flags & V4L2_BUF_FLAG_DONE) {
+				pr_debug
+				    ("VIDIOC_QBUF: overwrite done buffer.\n");
+				cam->frame[index].buffer.flags &=
+				    ~V4L2_BUF_FLAG_DONE;
+				cam->frame[index].buffer.flags |=
+				    V4L2_BUF_FLAG_QUEUED;
+			}
+			buf->flags = cam->frame[index].buffer.flags;
+			spin_unlock_irqrestore(&cam->int_lock, lock_flags);
+			break;
+		}
+
+		/*!
+		 * V4l2 VIDIOC_DQBUF ioctl
+		 */
+	case VIDIOC_DQBUF:{
+			struct v4l2_buffer *buf = arg;
+
+			retval = mxc_v4l_dqueue(cam, buf);
+
+			break;
+		}
+
+		/*!
+		 * V4l2 VIDIOC_STREAMON ioctl
+		 */
+	case VIDIOC_STREAMON:{
+			cam->capture_on = true;
+			retval = mxc_streamon(cam);
+			break;
+		}
+
+		/*!
+		 * V4l2 VIDIOC_STREAMOFF ioctl
+		 */
+	case VIDIOC_STREAMOFF:{
+			retval = mxc_streamoff(cam);
+			cam->capture_on = false;
+			break;
+		}
+
+		/*!
+		 * V4l2 VIDIOC_G_CTRL ioctl
+		 */
+	case VIDIOC_G_CTRL:{
+			retval = mxc_get_v42l_control(cam, arg);
+			break;
+		}
+
+		/*!
+		 * V4l2 VIDIOC_S_CTRL ioctl
+		 */
+	case VIDIOC_S_CTRL:{
+			retval = mxc_set_v42l_control(cam, arg);
+			break;
+		}
+
+		/*!
+		 * V4l2 VIDIOC_CROPCAP ioctl
+		 */
+	case VIDIOC_CROPCAP:{
+			struct v4l2_cropcap *cap = arg;
+
+			if (cap->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&
+			    cap->type != V4L2_BUF_TYPE_VIDEO_OVERLAY) {
+				retval = -EINVAL;
+				break;
+			}
+			cap->bounds = cam->crop_bounds;
+			cap->defrect = cam->crop_defrect;
+			break;
+		}
+
+		/*!
+		 * V4l2 VIDIOC_G_CROP ioctl
+		 */
+	case VIDIOC_G_CROP:{
+			struct v4l2_crop *crop = arg;
+
+			if (crop->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&
+			    crop->type != V4L2_BUF_TYPE_VIDEO_OVERLAY) {
+				retval = -EINVAL;
+				break;
+			}
+			crop->c = cam->crop_current;
+			break;
+		}
+
+		/*!
+		 * V4l2 VIDIOC_S_CROP ioctl
+		 */
+	case VIDIOC_S_CROP:{
+			struct v4l2_crop *crop = arg;
+			struct v4l2_rect *b = &cam->crop_bounds;
+			int i;
+
+			if (crop->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&
+			    crop->type != V4L2_BUF_TYPE_VIDEO_OVERLAY) {
+				retval = -EINVAL;
+				break;
+			}
+
+			crop->c.top = (crop->c.top < b->top) ? b->top
+			    : crop->c.top;
+			if (crop->c.top > b->top + b->height)
+				crop->c.top = b->top + b->height - 1;
+			if (crop->c.height > b->top + b->height - crop->c.top)
+				crop->c.height =
+				    b->top + b->height - crop->c.top;
+
+			crop->c.left = (crop->c.left < b->left) ? b->left
+			    : crop->c.left;
+			if (crop->c.left > b->left + b->width)
+				crop->c.left = b->left + b->width - 1;
+			if (crop->c.width > b->left - crop->c.left + b->width)
+				crop->c.width =
+				    b->left - crop->c.left + b->width;
+
+			crop->c.width &= ~0x1;
+
+			/*
+			 * MX27 PrP limitation:
+			 * The right spare space (CSI_FRAME_X_SIZE
+			 *  - SOURCE_LINE_STRIDE - PICTURE_X_SIZE)) must be
+			 * multiple of 32.
+			 * So we tune the crop->c.left value to the closest
+			 * desired cropping value and meet the PrP requirement.
+			 */
+			i = ((b->left + b->width)
+			     - (crop->c.left + crop->c.width)) % 32;
+			if (i <= 16) {
+				if (crop->c.left + crop->c.width + i
+				    <= b->left + b->width)
+					crop->c.left += i;
+				else if (crop->c.left - (32 - i) >= b->left)
+					crop->c.left -= 32 - i;
+				else {
+					retval = -EINVAL;
+					break;
+				}
+			} else {
+				if (crop->c.left - (32 - i) >= b->left)
+					crop->c.left -= 32 - i;
+				else if (crop->c.left + crop->c.width + i
+					 <= b->left + b->width)
+					crop->c.left += i;
+				else {
+					retval = -EINVAL;
+					break;
+				}
+			}
+
+			cam->crop_current = crop->c;
+
+			break;
+		}
+
+		/*!
+		 * V4l2 VIDIOC_OVERLAY ioctl
+		 */
+	case VIDIOC_OVERLAY:{
+			int *on = arg;
+			if (*on) {
+				cam->overlay_on = true;
+				retval = start_preview(cam);
+			}
+			if (!*on) {
+				retval = stop_preview(cam);
+				cam->overlay_on = false;
+			}
+			break;
+		}
+
+		/*!
+		 * V4l2 VIDIOC_G_FBUF ioctl
+		 */
+	case VIDIOC_G_FBUF:{
+			struct v4l2_framebuffer *fb = arg;
+			struct fb_var_screeninfo *var;
+
+			if (cam->output >= num_registered_fb) {
+				retval = -EINVAL;
+				break;
+			}
+
+			var = &registered_fb[cam->output]->var;
+			cam->v4l2_fb.fmt.width = var->xres;
+			cam->v4l2_fb.fmt.height = var->yres;
+			cam->v4l2_fb.fmt.bytesperline =
+			    var->xres_virtual * var->bits_per_pixel;
+			cam->v4l2_fb.fmt.colorspace = V4L2_COLORSPACE_SRGB;
+			*fb = cam->v4l2_fb;
+			break;
+		}
+
+		/*!
+		 * V4l2 VIDIOC_S_FBUF ioctl
+		 */
+	case VIDIOC_S_FBUF:{
+			struct v4l2_framebuffer *fb = arg;
+			cam->v4l2_fb.flags = fb->flags;
+			cam->v4l2_fb.fmt.pixelformat = fb->fmt.pixelformat;
+			break;
+		}
+
+	case VIDIOC_G_PARM:{
+			struct v4l2_streamparm *parm = arg;
+			if (parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+				pr_debug("VIDIOC_G_PARM invalid type\n");
+				retval = -EINVAL;
+				break;
+			}
+			parm->parm.capture = cam->streamparm.parm.capture;
+			break;
+		}
+	case VIDIOC_S_PARM:{
+			struct v4l2_streamparm *parm = arg;
+			retval = mxc_v4l2_s_param(cam, parm);
+			break;
+		}
+
+		/* linux v4l2 bug, kernel c0485619 user c0405619 */
+	case VIDIOC_ENUMSTD:{
+			struct v4l2_standard *e = arg;
+			*e = cam->standard;
+			pr_debug("VIDIOC_ENUMSTD call\n");
+			retval = 0;
+			break;
+		}
+
+	case VIDIOC_G_STD:{
+			v4l2_std_id *e = arg;
+			*e = cam->standard.id;
+			break;
+		}
+
+	case VIDIOC_S_STD:{
+			break;
+		}
+
+	case VIDIOC_ENUMOUTPUT:
+		{
+			struct v4l2_output *output = arg;
+
+			if (output->index >= num_registered_fb) {
+				retval = -EINVAL;
+				break;
+			}
+
+			strncpy(output->name,
+				registered_fb[output->index]->fix.id, 31);
+			output->type = V4L2_OUTPUT_TYPE_ANALOG;
+			output->audioset = 0;
+			output->modulator = 0;
+			output->std = V4L2_STD_UNKNOWN;
+
+			break;
+		}
+	case VIDIOC_G_OUTPUT:
+		{
+			int *p_output_num = arg;
+
+			*p_output_num = cam->output;
+			break;
+		}
+	case VIDIOC_S_OUTPUT:
+		{
+			int *p_output_num = arg;
+
+			if (*p_output_num >= num_registered_fb) {
+				retval = -EINVAL;
+				break;
+			}
+
+			cam->output = *p_output_num;
+			break;
+		}
+
+	case VIDIOC_G_INPUT:
+		{
+			int *p_input_index = arg;
+
+			retval = mxc_get_video_input(cam);
+			if (0 == retval)
+				*p_input_index = 1;
+			else
+				*p_input_index = -ENODEV;
+
+			break;
+		}
+
+	case VIDIOC_ENUM_FMT:
+	case VIDIOC_TRY_FMT:
+	case VIDIOC_QUERYCTRL:
+	case VIDIOC_ENUMINPUT:
+	case VIDIOC_S_INPUT:
+	case VIDIOC_G_TUNER:
+	case VIDIOC_S_TUNER:
+	case VIDIOC_G_FREQUENCY:
+	case VIDIOC_S_FREQUENCY:
+	default:
+		retval = -EINVAL;
+		break;
+	}
+
+	up(&cam->busy_lock);
+	return retval;
+}
+
+/*
+ * V4L interface - ioctl function
+ *
+ * @return  None
+ */
+static int
+mxc_v4l_ioctl(struct inode *inode, struct file *file,
+	      unsigned int cmd, unsigned long arg)
+{
+	return video_usercopy(inode, file, cmd, arg, mxc_v4l_do_ioctl);
+}
+
+/*!
+ * V4L interface - mmap function
+ *
+ * @param file        structure file *
+ *
+ * @param vma         structure vm_area_struct *
+ *
+ * @return status     0 Success, EINTR busy lock error, ENOBUFS remap_page error
+ */
+static int mxc_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct video_device *dev = video_devdata(file);
+	unsigned long size;
+	int res = 0;
+	cam_data *cam = dev->priv;
+
+	pr_debug("pgoff=0x%lx, start=0x%lx, end=0x%lx\n",
+		 vma->vm_pgoff, vma->vm_start, vma->vm_end);
+
+	/* make this _really_ smp-safe */
+	if (down_interruptible(&cam->busy_lock))
+		return -EINTR;
+
+	size = vma->vm_end - vma->vm_start;
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+
+	if (remap_pfn_range(vma, vma->vm_start,
+			    vma->vm_pgoff, size, vma->vm_page_prot)) {
+		pr_debug("mxc_mmap: remap_pfn_range failed\n");
+		res = -ENOBUFS;
+		goto mxc_mmap_exit;
+	}
+
+	vma->vm_flags &= ~VM_IO;	/* using shared anonymous pages */
+
+      mxc_mmap_exit:
+	up(&cam->busy_lock);
+	return res;
+}
+
+/*!
+ * V4L interface - poll function
+ *
+ * @param file       structure file *
+ *
+ * @param wait       structure poll_table *
+ *
+ * @return  status   POLLIN | POLLRDNORM
+ */
+static unsigned int mxc_poll(struct file *file, poll_table * wait)
+{
+	struct video_device *dev = video_devdata(file);
+	cam_data *cam = dev->priv;
+	wait_queue_head_t *queue = NULL;
+	int res = POLLIN | POLLRDNORM;
+
+	if (down_interruptible(&cam->busy_lock))
+		return -EINTR;
+
+	queue = &cam->enc_queue;
+	poll_wait(file, queue, wait);
+
+	up(&cam->busy_lock);
+	return res;
+}
+
+static struct
+file_operations mxc_v4l_fops = {
+	.owner = THIS_MODULE,
+	.open = mxc_v4l_open,
+	.release = mxc_v4l_close,
+	.read = mxc_v4l_read,
+	.ioctl = mxc_v4l_ioctl,
+	.mmap = mxc_mmap,
+	.poll = mxc_poll,
+};
+
+static struct video_device mxc_v4l_template = {
+	.owner = THIS_MODULE,
+	.name = "Mxc Camera",
+	.type = 0,
+	.type2 = VID_TYPE_CAPTURE,
+	.hardware = 0,
+	.fops = &mxc_v4l_fops,
+	.release = video_device_release,
+};
+
+static void camera_platform_release(struct device *device)
+{
+}
+
+/*! Device Definition for Mt9v111 devices */
+static struct platform_device mxc_v4l2_devices = {
+	.name = "mxc_v4l2",
+	.dev = {
+		.release = camera_platform_release,
+		},
+	.id = 0,
+};
+
+extern struct camera_sensor camera_sensor_if;
+
+/*!
+* Camera V4l2 callback function.
+*
+* @return status
+*/
+static void camera_callback(u32 mask, void *dev)
+{
+	struct mxc_v4l_frame *done_frame;
+	struct mxc_v4l_frame *ready_frame;
+
+	cam_data *cam = (cam_data *) dev;
+	if (cam == NULL)
+		return;
+
+	if (mask == 1) {
+		cam->overflow = 1;
+	}
+
+	if (list_empty(&cam->working_q)) {
+		if (empty_wq_cnt == 0) {
+			printk(KERN_ERR "camera_callback: working queue empty %d\n",empty_wq_cnt);
+		}
+		empty_wq_cnt++;
+	    if (list_empty(&cam->ready_q)) {
+			cam->skip_frame++;
+		} else {
+			ready_frame =
+			    list_entry(cam->ready_q.next, struct mxc_v4l_frame,
+				       queue);
+			list_del(cam->ready_q.next);
+			list_add_tail(&ready_frame->queue, &cam->working_q);
+			cam->enc_update_eba(ready_frame->paddress,
+					    &cam->ping_pong_csi);
+		}
+		return;
+	}
+
+	done_frame =
+	    list_entry(cam->working_q.next, struct mxc_v4l_frame, queue);
+	if (done_frame->buffer.flags & V4L2_BUF_FLAG_QUEUED) {
+		done_frame->buffer.flags |= V4L2_BUF_FLAG_DONE;
+		done_frame->buffer.flags &= ~V4L2_BUF_FLAG_QUEUED;
+
+		if (list_empty(&cam->ready_q)) {
+			cam->skip_frame++;
+		} else {
+			ready_frame =
+			    list_entry(cam->ready_q.next, struct mxc_v4l_frame,
+				       queue);
+			list_del(cam->ready_q.next);
+			list_add_tail(&ready_frame->queue, &cam->working_q);
+			cam->enc_update_eba(ready_frame->paddress,
+					    &cam->ping_pong_csi);
+		}
+
+		/* Added to the done queue */
+		list_del(cam->working_q.next);
+		list_add_tail(&done_frame->queue, &cam->done_q);
+
+		/* Wake up the queue */
+		cam->enc_counter++;
+		wake_up_interruptible(&cam->enc_queue);
+	} else {
+		printk(KERN_ERR "camera_callback :buffer not queued\n");
+	}
+}
+
+/*!
+ * initialize cam_data structure
+ *
+ * @param cam      structure cam_data *
+ *
+ * @return status  0 Success
+ */
+static void init_camera_struct(cam_data * cam)
+{
+	int i;
+
+	/* Default everything to 0 */
+	memset(cam, 0, sizeof(cam_data));
+
+	init_MUTEX(&cam->param_lock);
+	init_MUTEX(&cam->busy_lock);
+
+	cam->video_dev = video_device_alloc();
+	if (cam->video_dev == NULL)
+		return;
+
+	*(cam->video_dev) = mxc_v4l_template;
+
+	video_set_drvdata(cam->video_dev, cam);
+	dev_set_drvdata(&mxc_v4l2_devices.dev, (void *)cam);
+	cam->video_dev->minor = -1;
+
+	for (i = 0; i < FRAME_NUM; i++) {
+		cam->frame[i].width = 0;
+		cam->frame[i].height = 0;
+		cam->frame[i].paddress = 0;
+	}
+
+	init_waitqueue_head(&cam->enc_queue);
+	init_waitqueue_head(&cam->still_queue);
+
+	/* setup cropping */
+	cam->crop_bounds.left = 0;
+	cam->crop_bounds.width = 640;
+	cam->crop_bounds.top = 0;
+	cam->crop_bounds.height = 480;
+	cam->crop_current = cam->crop_defrect = cam->crop_bounds;
+	cam->streamparm.parm.capture.capturemode = 0;
+
+	cam->standard.index = 0;
+	cam->standard.id = V4L2_STD_UNKNOWN;
+	cam->standard.frameperiod.denominator = 30;
+	cam->standard.frameperiod.numerator = 1;
+	cam->standard.framelines = 480;
+	cam->streamparm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	cam->streamparm.parm.capture.timeperframe = cam->standard.frameperiod;
+	cam->streamparm.parm.capture.capability = V4L2_CAP_TIMEPERFRAME;
+	cam->overlay_on = false;
+	cam->capture_on = false;
+	cam->skip_frame = 0;
+	cam->v4l2_fb.capability = V4L2_FBUF_CAP_EXTERNOVERLAY;
+	cam->v4l2_fb.flags = V4L2_FBUF_FLAG_PRIMARY;
+
+	cam->v2f.fmt.pix.sizeimage = 352 * 288 * 3 / 2;
+	cam->v2f.fmt.pix.bytesperline = 288 * 3 / 2;
+	cam->v2f.fmt.pix.width = 288;
+	cam->v2f.fmt.pix.height = 352;
+	cam->v2f.fmt.pix.pixelformat = V4L2_PIX_FMT_YUV420;
+	cam->win.w.width = 160;
+	cam->win.w.height = 160;
+	cam->win.w.left = 0;
+	cam->win.w.top = 0;
+
+	cam->cam_sensor = &camera_sensor_if;
+	cam->enc_callback = camera_callback;
+
+	init_waitqueue_head(&cam->power_queue);
+	spin_lock_init(&cam->int_lock);
+}
+
+extern void gpio_sensor_active(void);
+extern void gpio_sensor_inactive(void);
+
+/*!
+ * camera_power function
+ *    Turn Sensor power On/Off
+ *
+ * @param       cameraOn      true to turn camera on, otherwise shut down
+ *
+ * @return status
+ */
+static u8 camera_power(bool cameraOn)
+{
+	if (cameraOn == true) {
+		gpio_sensor_active();
+		csi_enable_mclk(csi_mclk_flag_backup, true, true);
+	} else {
+		csi_mclk_flag_backup = csi_read_mclk_flag();
+		csi_enable_mclk(csi_mclk_flag_backup, false, false);
+		gpio_sensor_inactive();
+	}
+	return 0;
+}
+
+/*!
+ * This function is called to put the sensor in a low power state. Refer to the
+ * document driver-model/driver.txt in the kernel source tree for more
+ * information.
+ *
+ * @param   pdev  the device structure used to give information on which I2C
+ *                to suspend
+ * @param   state the power state the device is entering
+ *
+ * @return  The function returns 0 on success and -1 on failure.
+ */
+static int mxc_v4l2_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	cam_data *cam = platform_get_drvdata(pdev);
+
+	if (cam == NULL) {
+		return -1;
+	}
+
+	cam->low_power = true;
+
+	if (cam->overlay_on == true)
+		stop_preview(cam);
+	if ((cam->capture_on == true) && cam->enc_disable) {
+		cam->enc_disable(cam);
+	}
+	camera_power(false);
+
+	return 0;
+}
+
+/*!
+ * This function is called to bring the sensor back from a low power state.Refer
+ * to the document driver-model/driver.txt in the kernel source tree for more
+ * information.
+ *
+ * @param   pdev  the device structure
+ *
+ * @return  The function returns 0 on success and -1 on failure
+ */
+static int mxc_v4l2_resume(struct platform_device *pdev)
+{
+	cam_data *cam = platform_get_drvdata(pdev);
+
+	if (cam == NULL) {
+		return -1;
+	}
+
+	cam->low_power = false;
+	wake_up_interruptible(&cam->power_queue);
+
+	if (cam->overlay_on == true)
+		start_preview(cam);
+	if (cam->capture_on == true)
+		mxc_streamon(cam);
+	camera_power(true);
+
+	return 0;
+}
+
+/*!
+ * This structure contains pointers to the power management callback functions.
+ */
+static struct platform_driver mxc_v4l2_driver = {
+	.driver = {
+		   .name = "mxc_v4l2",
+		   .owner = THIS_MODULE,
+		   .bus = &platform_bus_type,
+		   },
+	.probe = NULL,
+	.remove = NULL,
+	.suspend = mxc_v4l2_suspend,
+	.resume = mxc_v4l2_resume,
+	.shutdown = NULL,
+};
+
+/*!
+ * Entry point for the V4L2
+ *
+ * @return  Error code indicating success or failure
+ */
+static __init int camera_init(void)
+{
+	u8 err = 0;
+	cam_data *cam;
+
+	if ((g_cam = cam = kmalloc(sizeof(cam_data), GFP_KERNEL)) == NULL) {
+		pr_debug("failed to mxc_v4l_register_camera\n");
+		return -1;
+	}
+
+	init_camera_struct(cam);
+
+	/* Register the I2C device */
+	err = platform_device_register(&mxc_v4l2_devices);
+	if (err != 0) {
+		pr_debug("camera_init: platform_device_register failed.\n");
+		video_device_release(cam->video_dev);
+		kfree(cam);
+		g_cam = NULL;
+	}
+
+	/* Register the device driver structure. */
+	err = platform_driver_register(&mxc_v4l2_driver);
+	if (err != 0) {
+		platform_device_unregister(&mxc_v4l2_devices);
+		pr_debug("camera_init: driver_register failed.\n");
+		video_device_release(cam->video_dev);
+		kfree(cam);
+		g_cam = NULL;
+		return err;
+	}
+
+	/* register v4l device */
+	if (video_register_device(cam->video_dev, VFL_TYPE_GRABBER, video_nr)
+	    == -1) {
+		platform_driver_unregister(&mxc_v4l2_driver);
+		platform_device_unregister(&mxc_v4l2_devices);
+		video_device_release(cam->video_dev);
+		kfree(cam);
+		g_cam = NULL;
+		pr_debug("video_register_device failed\n");
+		return -1;
+	}
+
+	return err;
+}
+
+/*!
+ * Exit and cleanup for the V4L2
+ *
+ */
+static void __exit camera_exit(void)
+{
+	pr_debug("unregistering video\n");
+
+	video_unregister_device(g_cam->video_dev);
+
+	platform_driver_unregister(&mxc_v4l2_driver);
+	platform_device_unregister(&mxc_v4l2_devices);
+
+	if (g_cam->open_count) {
+		pr_debug("camera open -- setting ops to NULL\n");
+	} else {
+		pr_debug("freeing camera\n");
+		mxc_free_frame_buf(g_cam);
+		kfree(g_cam);
+		g_cam = NULL;
+	}
+}
+
+module_init(camera_init);
+module_exit(camera_exit);
+
+module_param(video_nr, int, -1);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("V4L2 capture driver for Mxc based cameras");
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("video");
Index: linux-2.6.18/drivers/media/video/mxc/capture/mxc_v4l2_capture.h
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/media/video/mxc/capture/mxc_v4l2_capture.h
@@ -0,0 +1,186 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup MXC_V4L2_CAPTURE MXC V4L2 Video Capture Driver
+ */
+/*!
+ * @file mxc_v4l2_capture.h
+ *
+ * @brief mxc V4L2 capture device API  Header file
+ *
+ * It include all the defines for frame operations, also three structure defines
+ * use case ops structure, common v4l2 driver structure and frame structure.
+ *
+ * @ingroup MXC_V4L2_CAPTURE
+ */
+#ifndef __MXC_V4L2_CAPTURE_H__
+#define __MXC_V4L2_CAPTURE_H__
+
+#include <asm/uaccess.h>
+#include <linux/list.h>
+#include <linux/smp_lock.h>
+
+#include <media/v4l2-dev.h>
+#include <asm/arch/ipu.h>
+#include <asm/arch/mxc_v4l2.h>
+
+#define FRAME_NUM 3
+
+/*!
+ * v4l2 frame structure.
+ */
+struct mxc_v4l_frame {
+	u32 paddress;
+	void *vaddress;
+	int count;
+	int width;
+	int height;
+
+	struct v4l2_buffer buffer;
+	struct list_head queue;
+	int index;
+};
+
+typedef struct {
+	u8 clk_mode;
+	u8 ext_vsync;
+	u8 Vsync_pol;
+	u8 Hsync_pol;
+	u8 pixclk_pol;
+	u8 data_pol;
+	u8 data_width;
+	u16 width;
+	u16 height;
+	u32 pixel_fmt;
+	u32 mclk;
+} sensor_interface;
+
+/* Sensor control function */
+struct camera_sensor {
+	void (*set_color) (int bright, int saturation, int red, int green,
+			   int blue);
+	void (*get_color) (int *bright, int *saturation, int *red, int *green,
+			   int *blue);
+	void (*set_ae_mode) (int ae_mode);
+	void (*get_ae_mode) (int *ae_mode);
+	void (*set_ae) (int active);
+	void (*set_awb) (int active);
+	void (*flicker_control) (int control);
+	void (*get_control_params) (int *ae, int *awb, int *flicker);
+	sensor_interface *(*config) (int *frame_rate, int high_quality);
+	sensor_interface *(*reset) (void);
+	int (*get_status) (void);
+};
+
+/*!
+ * common v4l2 driver structure.
+ */
+typedef struct _cam_data {
+	struct video_device *video_dev;
+
+	/* semaphore guard against SMP multithreading */
+	struct semaphore busy_lock;
+
+	int open_count;
+
+	/* params lock for this camera */
+	struct semaphore param_lock;
+
+	/* Encorder */
+	struct list_head ready_q;
+	struct list_head done_q;
+	struct list_head working_q;
+	int ping_pong_csi;
+	spinlock_t int_lock;
+	struct mxc_v4l_frame frame[FRAME_NUM];
+	int skip_frame;
+    int overflow;
+	wait_queue_head_t enc_queue;
+	int enc_counter;
+	dma_addr_t rot_enc_bufs[2];
+	void *rot_enc_bufs_vaddr[2];
+	int rot_enc_buf_size[2];
+	enum v4l2_buf_type type;
+
+	/* still image capture */
+	wait_queue_head_t still_queue;
+	int still_counter;
+	dma_addr_t still_buf;
+	void *still_buf_vaddr;
+
+	/* overlay */
+	struct v4l2_window win;
+	struct v4l2_framebuffer v4l2_fb;
+	dma_addr_t vf_bufs[2];
+	void *vf_bufs_vaddr[2];
+	int vf_bufs_size[2];
+	dma_addr_t rot_vf_bufs[2];
+	void *rot_vf_bufs_vaddr[2];
+	int rot_vf_buf_size[2];
+	bool overlay_active;
+	int output;
+	struct fb_info *overlay_fb;
+
+	/* v4l2 format */
+	struct v4l2_format v2f;
+	int rotation;
+	struct v4l2_mxc_offset offset;
+
+	/* V4l2 control bit */
+	int bright;
+	int hue;
+	int contrast;
+	int saturation;
+	int red;
+	int green;
+	int blue;
+	int ae_mode;
+	int ae_enable;
+	int awb_enable;
+	int flicker_ctrl;
+
+	/* standart */
+	struct v4l2_streamparm streamparm;
+	struct v4l2_standard standard;
+
+	/* crop */
+	struct v4l2_rect crop_bounds;
+	struct v4l2_rect crop_defrect;
+	struct v4l2_rect crop_current;
+
+	int (*enc_update_eba) (dma_addr_t eba, int *bufferNum);
+	int (*enc_enable) (void *private);
+	int (*enc_disable) (void *private);
+	void (*enc_callback) (u32 mask, void *dev);
+	int (*vf_start_adc) (void *private);
+	int (*vf_stop_adc) (void *private);
+	int (*vf_start_sdc) (void *private);
+	int (*vf_stop_sdc) (void *private);
+	int (*csi_start) (void *private);
+	int (*csi_stop) (void *private);
+
+	/* misc status flag */
+	bool overlay_on;
+	bool capture_on;
+	int overlay_pid;
+	int capture_pid;
+	bool low_power;
+	wait_queue_head_t power_queue;
+
+	/* camera sensor interface */
+	struct camera_sensor *cam_sensor;
+} cam_data;
+
+void set_mclk_rate(uint32_t * p_mclk_freq);
+#endif				/* __MXC_V4L2_CAPTURE_H__ */
Index: linux-2.6.18/drivers/media/video/mxc/capture/sensor_clock.c
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/media/video/mxc/capture/sensor_clock.c
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file sensor_clock.c
+ *
+ * @brief camera clock function
+ *
+ * @ingroup Camera
+ */
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/clk.h>
+
+/*
+ * set_mclk_rate
+ *
+ * @param       p_mclk_freq  mclk frequence
+ *
+ */
+void set_mclk_rate(uint32_t * p_mclk_freq)
+{
+	struct clk *clk;
+	int i;
+	uint32_t freq = 0;
+	uint32_t step = *p_mclk_freq / 8;
+
+	clk = clk_get(NULL, "csi_clk");
+
+	for (i = 0; i <= 8; i++) {
+		freq = clk_round_rate(clk, *p_mclk_freq - (i * step));
+		if (freq <= *p_mclk_freq)
+			break;
+	}
+	clk_set_rate(clk, freq);
+
+	*p_mclk_freq = freq;
+
+	clk_put(clk);
+	pr_debug("mclk frequency = %d\n", *p_mclk_freq);
+}
+
+/* Exported symbols for modules. */
+EXPORT_SYMBOL(set_mclk_rate);
Index: linux-2.6.18/drivers/media/video/mxc/opl/Makefile
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/media/video/mxc/opl/Makefile
@@ -0,0 +1,5 @@
+opl-objs	:= opl_mod.o rotate90_u16.o rotate270_u16.o	\
+		   rotate90_u16_qcif.o rotate270_u16_qcif.o	\
+		   vmirror_u16.o hmirror_rotate180_u16.o
+
+obj-$(CONFIG_VIDEO_MXC_OPL)	+= opl.o
Index: linux-2.6.18/drivers/media/video/mxc/opl/hmirror_rotate180_u16.c
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/media/video/mxc/opl/hmirror_rotate180_u16.c
@@ -0,0 +1,259 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include "opl.h"
+
+static inline u32 rot_left_u16(u16 x, unsigned int n)
+{
+	return (x << n) | (x >> (16 - n));
+}
+
+static inline u32 rot_left_u32(u32 x, unsigned int n)
+{
+	return (x << n) | (x >> (32 - n));
+}
+
+static inline u32 byte_swap_u32(u32 x)
+{
+	u32 t1, t2, t3;
+
+	t1 = x ^ ((x << 16) | x >> 16);
+	t2 = t1 & 0xff00ffff;
+	t3 = (x >> 8) | (x << 24);
+	return t3 ^ (t2 >> 8);
+}
+
+static int opl_hmirror_u16_by1(const u8 * src, int src_line_stride, int width,
+			       int height, u8 * dst, int dst_line_stride,
+			       int vmirror);
+static int opl_hmirror_u16_by2(const u8 * src, int src_line_stride, int width,
+			       int height, u8 * dst, int dst_line_stride,
+			       int vmirror);
+static int opl_hmirror_u16_by4(const u8 * src, int src_line_stride, int width,
+			       int height, u8 * dst, int dst_line_stride,
+			       int vmirror);
+static int opl_hmirror_u16_by8(const u8 * src, int src_line_stride, int width,
+			       int height, u8 * dst, int dst_line_stride,
+			       int vmirror);
+
+int opl_hmirror_u16(const u8 * src, int src_line_stride, int width, int height,
+		    u8 * dst, int dst_line_stride)
+{
+	if (!src || !dst)
+		return OPLERR_NULL_PTR;
+
+	if (width == 0 || height == 0 || src_line_stride == 0
+	    || dst_line_stride == 0)
+		return OPLERR_BAD_ARG;
+
+	if (width % 8 == 0)
+		return opl_hmirror_u16_by8(src, src_line_stride, width, height,
+					   dst, dst_line_stride, 0);
+	else if (width % 4 == 0)
+		return opl_hmirror_u16_by4(src, src_line_stride, width, height,
+					   dst, dst_line_stride, 0);
+	else if (width % 2 == 0)
+		return opl_hmirror_u16_by2(src, src_line_stride, width, height,
+					   dst, dst_line_stride, 0);
+	else			/* (width % 1) */
+		return opl_hmirror_u16_by1(src, src_line_stride, width, height,
+					   dst, dst_line_stride, 0);
+}
+
+int opl_rotate180_u16(const u8 * src, int src_line_stride, int width,
+		      int height, u8 * dst, int dst_line_stride)
+{
+	if (!src || !dst)
+		return OPLERR_NULL_PTR;
+
+	if (width == 0 || height == 0 || src_line_stride == 0
+	    || dst_line_stride == 0)
+		return OPLERR_BAD_ARG;
+
+	if (width % 8 == 0)
+		return opl_hmirror_u16_by8(src, src_line_stride, width, height,
+					   dst, dst_line_stride, 1);
+	else if (width % 4 == 0)
+		return opl_hmirror_u16_by4(src, src_line_stride, width, height,
+					   dst, dst_line_stride, 1);
+	else if (width % 2 == 0)
+		return opl_hmirror_u16_by2(src, src_line_stride, width, height,
+					   dst, dst_line_stride, 1);
+	else			/* (width % 1) */
+		return opl_hmirror_u16_by1(src, src_line_stride, width, height,
+					   dst, dst_line_stride, 1);
+}
+
+static int opl_hmirror_u16_by1(const u8 * src, int src_line_stride, int width,
+			       int height, u8 * dst, int dst_line_stride,
+			       int vmirror)
+{
+	const u8 *src_row_addr;
+	const u8 *psrc;
+	u8 *dst_row_addr, *pdst;
+	int i, j;
+	u16 pixel;
+
+	src_row_addr = src;
+	if (vmirror) {
+		dst_row_addr = dst + dst_line_stride * (height - 1);
+		dst_line_stride = -dst_line_stride;
+	} else
+		dst_row_addr = dst;
+
+	/* Loop over all rows */
+	for (i = 0; i < height; i++) {
+		/* Loop over each pixel */
+		psrc = src_row_addr;
+		pdst = dst_row_addr + (width - 1) * BYTES_PER_PIXEL
+		    - (BYTES_PER_PIXEL - BYTES_PER_PIXEL);
+		for (j = 0; j < width; j++) {
+			pixel = *(u16 *) psrc;
+			*(u16 *) pdst = pixel;
+			psrc += BYTES_PER_PIXEL;
+			pdst -= BYTES_PER_PIXEL;
+		}
+		src_row_addr += src_line_stride;
+		dst_row_addr += dst_line_stride;
+	}
+
+	return OPLERR_SUCCESS;
+}
+
+static int opl_hmirror_u16_by2(const u8 * src, int src_line_stride, int width,
+			       int height, u8 * dst, int dst_line_stride,
+			       int vmirror)
+{
+	const u8 *src_row_addr;
+	const u8 *psrc;
+	u8 *dst_row_addr, *pdst;
+	int i, j;
+	u32 pixelsin, pixelsout;
+
+	src_row_addr = src;
+	if (vmirror) {
+		dst_row_addr = dst + dst_line_stride * (height - 1);
+		dst_line_stride = -dst_line_stride;
+	} else
+		dst_row_addr = dst;
+
+	/* Loop over all rows */
+	for (i = 0; i < height; i++) {
+		/* Loop over each pixel */
+		psrc = src_row_addr;
+		pdst = dst_row_addr + (width - 2) * BYTES_PER_PIXEL;
+		for (j = 0; j < (width >> 1); j++) {
+			pixelsin = *(u32 *) psrc;
+			pixelsout = rot_left_u32(pixelsin, 16);
+			*(u32 *) pdst = pixelsout;
+			psrc += BYTES_PER_2PIXEL;
+			pdst -= BYTES_PER_2PIXEL;
+		}
+		src_row_addr += src_line_stride;
+		dst_row_addr += dst_line_stride;
+	}
+
+	return OPLERR_SUCCESS;
+}
+
+static int opl_hmirror_u16_by4(const u8 * src, int src_line_stride, int width,
+			       int height, u8 * dst, int dst_line_stride,
+			       int vmirror)
+{
+	const u8 *src_row_addr;
+	const u8 *psrc;
+	u8 *dst_row_addr, *pdst;
+	int i, j;
+
+	union doubleword {
+		u64 dw;
+		u32 w[2];
+	};
+
+	union doubleword inbuf;
+	union doubleword outbuf;
+
+	src_row_addr = src;
+	if (vmirror) {
+		dst_row_addr = dst + dst_line_stride * (height - 1);
+		dst_line_stride = -dst_line_stride;
+	} else
+		dst_row_addr = dst;
+
+	/* Loop over all rows */
+	for (i = 0; i < height; i++) {
+		/* Loop over each pixel */
+		psrc = src_row_addr;
+		pdst = dst_row_addr + (width - 4) * BYTES_PER_PIXEL;
+		for (j = 0; j < (width >> 2); j++) {
+			inbuf.dw = *(u64 *) psrc;
+			outbuf.w[0] = rot_left_u32(inbuf.w[1], 16);
+			outbuf.w[1] = rot_left_u32(inbuf.w[0], 16);
+			*(u64 *) pdst = outbuf.dw;
+			psrc += BYTES_PER_4PIXEL;
+			pdst -= BYTES_PER_4PIXEL;
+		}
+		src_row_addr += src_line_stride;
+		dst_row_addr += dst_line_stride;
+	}
+	return OPLERR_SUCCESS;
+}
+
+static int opl_hmirror_u16_by8(const u8 * src, int src_line_stride, int width,
+			       int height, u8 * dst, int dst_line_stride,
+			       int vmirror)
+{
+	const u8 *src_row_addr;
+	const u8 *psrc;
+	u8 *dst_row_addr, *pdst;
+	int i, j;
+
+	src_row_addr = src;
+	if (vmirror) {
+		dst_row_addr = dst + dst_line_stride * (height - 1);
+		dst_line_stride = -dst_line_stride;
+	} else
+		dst_row_addr = dst;
+
+	/* Loop over all rows */
+	for (i = 0; i < height; i++) {
+		/* Loop over each pixel */
+		psrc = src_row_addr;
+		pdst = dst_row_addr + (width - 1) * BYTES_PER_PIXEL - 2;
+		for (j = (width >> 3); j > 0; j--) {
+			__asm__ volatile (
+				"ldmia	%0!,{r2-r5}\n\t"
+				"mov	r6, r2\n\t"
+				"mov	r7, r3\n\t"
+				"mov	r2, r5, ROR #16\n\t"
+				"mov	r3, r4, ROR #16\n\t"
+				"mov	r4, r7, ROR #16\n\t"
+				"mov	r5, r6, ROR #16\n\t"
+				"stmda	%1!,{r2-r5}\n\t"
+
+				:"+r"(psrc), "+r"(pdst)
+				:"0"(psrc), "1"(pdst)
+				:"r2", "r3", "r4", "r5", "r6", "r7",
+				"memory"
+			);
+		}
+		src_row_addr += src_line_stride;
+		dst_row_addr += dst_line_stride;
+	}
+
+	return OPLERR_SUCCESS;
+}
+
+EXPORT_SYMBOL(opl_hmirror_u16);
+EXPORT_SYMBOL(opl_rotate180_u16);
Index: linux-2.6.18/drivers/media/video/mxc/opl/opl.h
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/media/video/mxc/opl/opl.h
@@ -0,0 +1,162 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup OPLIP OPL Image Processing
+ */
+/*!
+ * @file opl.h
+ *
+ * @brief The OPL (Open Primitives Library) Image Processing library defines
+ * efficient functions for rotation and mirroring.
+ *
+ * It includes ARM9-optimized rotation and mirroring functions. It is derived
+ * from the original OPL project which is found at sourceforge.freescale.net.
+ *
+ * @ingroup OPLIP
+ */
+#ifndef __OPL_H__
+#define __OPL_H__
+
+#include <linux/types.h>
+
+#define BYTES_PER_PIXEL			2
+#define CACHE_LINE_WORDS		8
+#define BYTES_PER_WORD			4
+
+#define BYTES_PER_2PIXEL		(BYTES_PER_PIXEL * 2)
+#define BYTES_PER_4PIXEL		(BYTES_PER_PIXEL * 4)
+#define BYTES_PER_8PIXEL		(BYTES_PER_PIXEL * 8)
+
+#define QCIF_Y_WIDTH			176
+#define QCIF_Y_HEIGHT			144
+
+/*! Enumerations of opl error code */
+enum opl_error {
+	OPLERR_SUCCESS = 0,
+	OPLERR_NULL_PTR,
+	OPLERR_BAD_ARG,
+	OPLERR_DIV_BY_ZERO,
+	OPLERR_OVER_FLOW,
+	OPLERR_UNDER_FLOW,
+	OPLERR_MISALIGNED,
+};
+
+/*!
+ * @brief Rotate a 16bbp buffer 90 degrees clockwise.
+ *
+ * @param src             Pointer to the input buffer
+ * @param src_line_stride Length in bytes of a raster line of the input buffer
+ * @param width           Width in pixels of the region in the input buffer
+ * @param height          Height in pixels of the region in the input buffer
+ * @param dst             Pointer to the output buffer
+ * @param dst_line_stride Length in bytes of a raster line of the output buffer
+ *
+ * @return Standard OPL error code. See enumeration for possible result codes.
+ */
+int opl_rotate90_u16(const u8 * src, int src_line_stride, int width, int height,
+		     u8 * dst, int dst_line_stride);
+
+/*!
+ * @brief Rotate a 16bbp buffer 180 degrees clockwise.
+ *
+ * @param src             Pointer to the input buffer
+ * @param src_line_stride Length in bytes of a raster line of the input buffer
+ * @param width           Width in pixels of the region in the input buffer
+ * @param height          Height in pixels of the region in the input buffer
+ * @param dst             Pointer to the output buffer
+ * @param dst_line_stride Length in bytes of a raster line of the output buffer
+ *
+ * @return Standard OPL error code. See enumeration for possible result codes.
+ */
+int opl_rotate180_u16(const u8 * src, int src_line_stride, int width,
+		      int height, u8 * dst, int dst_line_stride);
+
+/*!
+ * @brief Rotate a 16bbp buffer 270 degrees clockwise
+ *
+ * @param src             Pointer to the input buffer
+ * @param src_line_stride Length in bytes of a raster line of the input buffer
+ * @param width           Width in pixels of the region in the input buffer
+ * @param height          Height in pixels of the region in the input buffer
+ * @param dst             Pointer to the output buffer
+ * @param dst_line_stride Length in bytes of a raster line of the output buffer
+ *
+ * @return Standard OPL error code. See enumeration for possible result codes.
+ */
+int opl_rotate270_u16(const u8 * src, int src_line_stride, int width,
+		      int height, u8 * dst, int dst_line_stride);
+
+/*!
+ * @brief Mirror a 16bpp buffer horizontally
+ *
+ * @param src             Pointer to the input buffer
+ * @param src_line_stride Length in bytes of a raster line of the input buffer
+ * @param width           Width in pixels of the region in the input buffer
+ * @param height          Height in pixels of the region in the input buffer
+ * @param dst             Pointer to the output buffer
+ * @param dst_line_stride Length in bytes of a raster line of the output buffer
+ *
+ * @return Standard OPL error code. See enumeration for possible result codes.
+ */
+int opl_hmirror_u16(const u8 * src, int src_line_stride, int width, int height,
+		    u8 * dst, int dst_line_stride);
+
+/*!
+ * @brief Mirror a 16bpp buffer vertically
+ *
+ * @param src             Pointer to the input buffer
+ * @param src_line_stride Length in bytes of a raster line of the input buffer
+ * @param width           Width in pixels of the region in the input buffer
+ * @param height          Height in pixels of the region in the input buffer
+ * @param dst             Pointer to the output buffer
+ * @param dst_line_stride Length in bytes of a raster line of the output buffer
+ *
+ * @return Standard OPL error code. See enumeration for possible result codes.
+ */
+int opl_vmirror_u16(const u8 * src, int src_line_stride, int width, int height,
+		    u8 * dst, int dst_line_stride);
+
+/*!
+ * @brief Rotate a 16bbp buffer 90 degrees clockwise and mirror vertically
+ *	  It is equivalent to rotate 270 degree and mirror horizontally
+ *
+ * @param src             Pointer to the input buffer
+ * @param src_line_stride Length in bytes of a raster line of the input buffer
+ * @param width           Width in pixels of the region in the input buffer
+ * @param height          Height in pixels of the region in the input buffer
+ * @param dst             Pointer to the output buffer
+ * @param dst_line_stride Length in bytes of a raster line of the output buffer
+ *
+ * @return Standard OPL error code. See enumeration for possible result codes.
+ */
+int opl_rotate90_vmirror_u16(const u8 * src, int src_line_stride, int width,
+			     int height, u8 * dst, int dst_line_stride);
+
+/*!
+ * @brief Rotate a 16bbp buffer 270 degrees clockwise and mirror vertically
+ *	  It is equivalent to rotate 90 degree and mirror horizontally
+ *
+ * @param src             Pointer to the input buffer
+ * @param src_line_stride Length in bytes of a raster line of the input buffer
+ * @param width           Width in pixels of the region in the input buffer
+ * @param height          Height in pixels of the region in the input buffer
+ * @param dst             Pointer to the output buffer
+ * @param dst_line_stride Length in bytes of a raster line of the output buffer
+ *
+ * @return Standard OPL error code. See enumeration for possible result codes.
+ */
+int opl_rotate270_vmirror_u16(const u8 * src, int src_line_stride, int width,
+			      int height, u8 * dst, int dst_line_stride);
+
+#endif				/* __OPL_H__ */
Index: linux-2.6.18/drivers/media/video/mxc/opl/opl_mod.c
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/media/video/mxc/opl/opl_mod.c
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+
+static __init int opl_init(void)
+{
+	return 0;
+}
+
+static void __exit opl_exit(void)
+{
+}
+
+module_init(opl_init);
+module_exit(opl_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("OPL Software Rotation/Mirroring");
+MODULE_LICENSE("GPL");
Index: linux-2.6.18/drivers/media/video/mxc/opl/rotate270_u16.c
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/media/video/mxc/opl/rotate270_u16.c
@@ -0,0 +1,285 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include "opl.h"
+
+static int opl_rotate270_u16_by16(const u8 * src, int src_line_stride,
+				  int width, int height, u8 * dst,
+				  int dst_line_stride, int vmirror);
+static int opl_rotate270_u16_by4(const u8 * src, int src_line_stride, int width,
+				 int height, u8 * dst, int dst_line_stride,
+				 int vmirror);
+static int opl_rotate270_vmirror_u16_both(const u8 * src, int src_line_stride,
+					  int width, int height, u8 * dst,
+					  int dst_line_stride, int vmirror);
+int opl_rotate270_u16_qcif(const u8 * src, u8 * dst);
+
+int opl_rotate270_u16(const u8 * src, int src_line_stride, int width,
+		      int height, u8 * dst, int dst_line_stride)
+{
+	return opl_rotate270_vmirror_u16_both(src, src_line_stride, width,
+					      height, dst, dst_line_stride, 0);
+}
+
+int opl_rotate270_vmirror_u16(const u8 * src, int src_line_stride, int width,
+			      int height, u8 * dst, int dst_line_stride)
+{
+	return opl_rotate270_vmirror_u16_both(src, src_line_stride, width,
+					      height, dst, dst_line_stride, 1);
+}
+
+static int opl_rotate270_vmirror_u16_both(const u8 * src, int src_line_stride,
+					  int width, int height, u8 * dst,
+					  int dst_line_stride, int vmirror)
+{
+	const int BLOCK_SIZE_PIXELS = CACHE_LINE_WORDS * BYTES_PER_WORD
+	    / BYTES_PER_PIXEL;
+	const int BLOCK_SIZE_PIXELS_BY4 = CACHE_LINE_WORDS * BYTES_PER_WORD
+	    / BYTES_PER_PIXEL / 4;
+
+	if (!src || !dst)
+		return OPLERR_NULL_PTR;
+
+	if (width == 0 || height == 0 || src_line_stride == 0
+	    || dst_line_stride == 0)
+		return OPLERR_BAD_ARG;
+
+	/* The QCIF algorithm doesn't support vertical mirroring */
+	if (vmirror == 0 && width == QCIF_Y_WIDTH && height == QCIF_Y_HEIGHT
+	    && src_line_stride == QCIF_Y_WIDTH * 2
+	    && src_line_stride == QCIF_Y_HEIGHT * 2)
+		return opl_rotate270_u16_qcif(src, dst);
+	else if (width % BLOCK_SIZE_PIXELS == 0
+		 && height % BLOCK_SIZE_PIXELS == 0)
+		return opl_rotate270_u16_by16(src, src_line_stride, width,
+					      height, dst, dst_line_stride,
+					      vmirror);
+	else if (width % BLOCK_SIZE_PIXELS_BY4 == 0
+		 && height % BLOCK_SIZE_PIXELS_BY4 == 0)
+		return opl_rotate270_u16_by4(src, src_line_stride, width,
+					     height, dst, dst_line_stride,
+					     vmirror);
+	else
+		return OPLERR_BAD_ARG;
+}
+
+/*
+ * Rotate Counter Clockwise, divide RGB component into 16 row strips, read
+ * non sequentially and write sequentially. This is done in 16 line strips
+ * so that the cache is used better. Cachelines are 8 words = 32 bytes. Pixels
+ * are 2 bytes. The 16 reads will be cache misses, but the next 240 should
+ * be from cache. The writes to the output buffer will be sequential for 16
+ * writes.
+ *
+ * Example:
+ * Input data matrix:	    output matrix
+ *
+ * 0 | 1 | 2 | 3 | 4 |      4 | 0 | 0 | 3 |
+ * 4 | 3 | 2 | 1 | 0 |      3 | 1 | 9 | 6 |
+ * 6 | 7 | 8 | 9 | 0 |      2 | 2 | 8 | 2 |
+ * 5 | 3 | 2 | 6 | 3 |      1 | 3 | 7 | 3 |
+ * ^			    0 | 4 | 6 | 5 | < Write the input data sequentially
+ * Read first column
+ * Start at the bottom
+ * Move to next column and repeat
+ *
+ * Loop over k decreasing (blocks)
+ * in_block_ptr = src + (((RGB_HEIGHT_PIXELS / BLOCK_SIZE_PIXELS) - k)
+ *                * BLOCK_SIZE_PIXELS) * (RGB_WIDTH_BYTES)
+ * out_block_ptr = dst + (((RGB_HEIGHT_PIXELS / BLOCK_SIZE_PIXELS) - k)
+ *                * BLOCK_SIZE_BYTES) + (RGB_WIDTH_PIXELS - 1)
+ *                * RGB_HEIGHT_PIXELS * BYTES_PER_PIXEL
+ *
+ * Loop over i decreasing (width)
+ * Each pix:
+ * in_block_ptr += RGB_WIDTH_BYTES
+ * out_block_ptr += 4
+ *
+ * Each row of block:
+ * in_block_ptr -= RGB_WIDTH_BYTES * BLOCK_SIZE_PIXELS - 2
+ * out_block_ptr -= RGB_HEIGHT_PIXELS * BYTES_PER_PIXEL + 2 * BLOCK_SIZE_PIXELS;
+ *
+ * It may perform vertical mirroring too depending on the vmirror flag.
+ */
+static int opl_rotate270_u16_by16(const u8 * src, int src_line_stride,
+				  int width, int height, u8 * dst,
+				  int dst_line_stride, int vmirror)
+{
+	const int BLOCK_SIZE_PIXELS = CACHE_LINE_WORDS * BYTES_PER_WORD
+	    / BYTES_PER_PIXEL;
+	const int IN_INDEX = src_line_stride * BLOCK_SIZE_PIXELS
+	    - BYTES_PER_PIXEL;
+	const int OUT_INDEX = vmirror ?
+	    -dst_line_stride + BYTES_PER_PIXEL * BLOCK_SIZE_PIXELS
+	    : dst_line_stride + BYTES_PER_PIXEL * BLOCK_SIZE_PIXELS;
+	const u8 *in_block_ptr;
+	u8 *out_block_ptr;
+	int i, k;
+
+	for (k = height / BLOCK_SIZE_PIXELS; k > 0; k--) {
+		in_block_ptr = src + (((height / BLOCK_SIZE_PIXELS) - k)
+				      * BLOCK_SIZE_PIXELS) * src_line_stride;
+		out_block_ptr = dst + (((height / BLOCK_SIZE_PIXELS) - k)
+				       * BLOCK_SIZE_PIXELS * BYTES_PER_PIXEL) +
+		    (width - 1) * dst_line_stride;
+
+		/*
+		* For vertical mirroring the writing starts from the
+		* first line
+		*/
+		if (vmirror)
+			out_block_ptr -= dst_line_stride * (width - 1);
+
+		for (i = width; i > 0; i--) {
+			__asm__ volatile (
+				"ldrh	r2, [%0], %4\n\t"
+				"ldrh	r3, [%0], %4\n\t"
+				"ldrh	r4, [%0], %4\n\t"
+				"ldrh	r5, [%0], %4\n\t"
+				"orr	r2, r2, r3, lsl #16\n\t"
+				"orr	r4, r4, r5, lsl #16\n\t"
+				"str	r2, [%1], #4\n\t"
+				"str	r4, [%1], #4\n\t"
+
+				"ldrh	r2, [%0], %4\n\t"
+				"ldrh	r3, [%0], %4\n\t"
+				"ldrh	r4, [%0], %4\n\t"
+				"ldrh	r5, [%0], %4\n\t"
+				"orr	r2, r2, r3, lsl #16\n\t"
+				"orr	r4, r4, r5, lsl #16\n\t"
+				"str	r2, [%1], #4\n\t"
+				"str	r4, [%1], #4\n\t"
+
+				"ldrh	r2, [%0], %4\n\t"
+				"ldrh	r3, [%0], %4\n\t"
+				"ldrh	r4, [%0], %4\n\t"
+				"ldrh	r5, [%0], %4\n\t"
+				"orr	r2, r2, r3, lsl #16\n\t"
+				"orr	r4, r4, r5, lsl #16\n\t"
+				"str	r2, [%1], #4\n\t"
+				"str	r4, [%1], #4\n\t"
+
+				"ldrh	r2, [%0], %4\n\t"
+				"ldrh	r3, [%0], %4\n\t"
+				"ldrh	r4, [%0], %4\n\t"
+				"ldrh	r5, [%0], %4\n\t"
+				"orr	r2, r2, r3, lsl #16\n\t"
+				"orr	r4, r4, r5, lsl #16\n\t"
+				"str	r2, [%1], #4\n\t"
+				"str	r4, [%1], #4\n\t"
+
+				:"+r" (in_block_ptr), "+r"(out_block_ptr)	/* output */
+				:"0"(in_block_ptr), "1"(out_block_ptr), "r"(src_line_stride)	/* input  */
+				:"r2", "r3", "r4", "r5", "memory"	/* modify */
+			);
+			in_block_ptr -= IN_INDEX;
+			out_block_ptr -= OUT_INDEX;
+		}
+	}
+
+	return OPLERR_SUCCESS;
+}
+
+/*
+ * Rotate Counter Clockwise, divide RGB component into 4 row strips, read
+ * non sequentially and write sequentially. This is done in 4 line strips
+ * so that the cache is used better. Cachelines are 8 words = 32 bytes. Pixels
+ * are 2 bytes. The 4 reads will be cache misses, but the next 60 should
+ * be from cache. The writes to the output buffer will be sequential for 4
+ * writes.
+ *
+ * Example:
+ * Input data matrix:	    output matrix
+ *
+ * 0 | 1 | 2 | 3 | 4 |      4 | 0 | 0 | 3 |
+ * 4 | 3 | 2 | 1 | 0 |      3 | 1 | 9 | 6 |
+ * 6 | 7 | 8 | 9 | 0 |      2 | 2 | 8 | 2 |
+ * 5 | 3 | 2 | 6 | 3 |      1 | 3 | 7 | 3 |
+ * ^			    0 | 4 | 6 | 5 | < Write the input data sequentially
+ * Read first column
+ * Start at the bottom
+ * Move to next column and repeat
+ *
+ * Loop over k decreasing (blocks)
+ * in_block_ptr = src + (((RGB_HEIGHT_PIXELS / BLOCK_SIZE_PIXELS) - k)
+ *                * BLOCK_SIZE_PIXELS) * (RGB_WIDTH_BYTES)
+ * out_block_ptr = dst + (((RGB_HEIGHT_PIXELS / BLOCK_SIZE_PIXELS) - k)
+ *                * BLOCK_SIZE_BYTES) + (RGB_WIDTH_PIXELS - 1)
+ *                * RGB_HEIGHT_PIXELS * BYTES_PER_PIXEL
+ *
+ * Loop over i decreasing (width)
+ * Each pix:
+ * in_block_ptr += RGB_WIDTH_BYTES
+ * out_block_ptr += 4
+ *
+ * Each row of block:
+ * in_block_ptr -= RGB_WIDTH_BYTES * BLOCK_SIZE_PIXELS - 2
+ * out_block_ptr -= RGB_HEIGHT_PIXELS * BYTES_PER_PIXEL + 2 * BLOCK_SIZE_PIXELS;
+ *
+ * It may perform vertical mirroring too depending on the vmirror flag.
+ */
+static int opl_rotate270_u16_by4(const u8 * src, int src_line_stride, int width,
+				 int height, u8 * dst, int dst_line_stride,
+				 int vmirror)
+{
+	const int BLOCK_SIZE_PIXELS = CACHE_LINE_WORDS * BYTES_PER_WORD
+	    / BYTES_PER_PIXEL / 4;
+	const int IN_INDEX = src_line_stride * BLOCK_SIZE_PIXELS
+	    - BYTES_PER_PIXEL;
+	const int OUT_INDEX = vmirror ?
+	    -dst_line_stride + BYTES_PER_PIXEL * BLOCK_SIZE_PIXELS
+	    : dst_line_stride + BYTES_PER_PIXEL * BLOCK_SIZE_PIXELS;
+	const u8 *in_block_ptr;
+	u8 *out_block_ptr;
+	int i, k;
+
+	for (k = height / BLOCK_SIZE_PIXELS; k > 0; k--) {
+		in_block_ptr = src + (((height / BLOCK_SIZE_PIXELS) - k)
+				      * BLOCK_SIZE_PIXELS) * src_line_stride;
+		out_block_ptr = dst + (((height / BLOCK_SIZE_PIXELS) - k)
+				       * BLOCK_SIZE_PIXELS * BYTES_PER_PIXEL)
+		    + (width - 1) * dst_line_stride;
+
+		/*
+		* For vertical mirroring the writing starts from the
+		* first line
+		*/
+		if (vmirror)
+			out_block_ptr -= dst_line_stride * (width - 1);
+
+		for (i = width; i > 0; i--) {
+			__asm__ volatile (
+				"ldrh	r2, [%0], %4\n\t"
+				"ldrh	r3, [%0], %4\n\t"
+				"ldrh	r4, [%0], %4\n\t"
+				"ldrh	r5, [%0], %4\n\t"
+				"orr	r2, r2, r3, lsl #16\n\t"
+				"orr	r4, r4, r5, lsl #16\n\t"
+				"str	r2, [%1], #4\n\t"
+				"str	r4, [%1], #4\n\t"
+
+				:"+r" (in_block_ptr), "+r"(out_block_ptr)	/* output */
+				:"0"(in_block_ptr), "1"(out_block_ptr), "r"(src_line_stride)	/* input  */
+				:"r2", "r3", "r4", "r5", "memory"	/* modify */
+			);
+			in_block_ptr -= IN_INDEX;
+			out_block_ptr -= OUT_INDEX;
+		}
+	}
+
+	return OPLERR_SUCCESS;
+}
+
+EXPORT_SYMBOL(opl_rotate270_u16);
+EXPORT_SYMBOL(opl_rotate270_vmirror_u16);
Index: linux-2.6.18/drivers/media/video/mxc/opl/rotate270_u16_qcif.S
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/media/video/mxc/opl/rotate270_u16_qcif.S
@@ -0,0 +1,70 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#include <linux/linkage.h>
+
+	.text
+	.align	2
+ENTRY(opl_rotate270_u16_qcif)
+	STMFD    sp!,{r4-r10}
+        MOV      r12,#0x160
+        MOV      r10,#0x90
+        MOV      r3,r10,LSR #4
+.L1.16:
+        RSB      r2,r3,r10,LSR #4
+        MOV      r5,r2,LSL #5
+        MOV      r4,r12,LSR #1
+        SMULBB   r4,r5,r4
+        ADD      r2,r1,r2,LSL #5
+        ADD      r5,r2,#0xc000
+        ADD      r5,r5,#0x4e0
+        MOV      r2,r12,LSR #1
+        ADD      r4,r0,r4
+.L1.52:
+        LDRH     r6,[r4],r12
+        LDRH     r7,[r4],r12
+        LDRH     r8,[r4],r12
+        LDRH     r9,[r4],r12
+        ORR      r6,r6,r7,LSL #16
+        ORR      r7,r8,r9,LSL #16
+        STMIA    r5!,{r6,r7}
+        SUBS     r2,r2,#1
+        LDRH     r6,[r4],r12
+        LDRH     r7,[r4],r12
+        LDRH     r8,[r4],r12
+        LDRH     r9,[r4],r12
+        ORR      r6,r6,r7,LSL #16
+        ORR      r7,r8,r9,LSL #16
+        STMIA    r5!,{r6,r7}
+        LDRH     r6,[r4],r12
+        LDRH     r7,[r4],r12
+        LDRH     r8,[r4],r12
+        LDRH     r9,[r4],r12
+        ORR      r6,r6,r7,LSL #16
+        ORR      r7,r8,r9,LSL #16
+        STMIA    r5!,{r6,r7}
+        LDRH     r6,[r4],r12
+        LDRH     r7,[r4],r12
+        LDRH     r8,[r4],r12
+        LDRH     r9,[r4],r12
+        ORR      r6,r6,r7,LSL #16
+        ORR      r7,r8,r9,LSL #16
+        SUB      r4,r4,#0x1500
+        STMIA    r5,{r6,r7}
+        SUB      r5,r5,#0x138
+        SUB      r4,r4,#0xfe
+        BGT      .L1.52
+        SUBS     r3,r3,#1
+        BGT      .L1.16
+        LDMFD    sp!,{r4-r10}
+        BX       lr
+	.size	opl_rotate270_u16_qcif, . - opl_rotate270_u16_qcif
Index: linux-2.6.18/drivers/media/video/mxc/opl/rotate90_u16.c
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/media/video/mxc/opl/rotate90_u16.c
@@ -0,0 +1,220 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include "opl.h"
+
+static int opl_rotate90_u16_by16(const u8 * src, int src_line_stride, int width,
+				 int height, u8 * dst, int dst_line_stride,
+				 int vmirror);
+static int opl_rotate90_u16_by4(const u8 * src, int src_line_stride, int width,
+				int height, u8 * dst, int dst_line_stride,
+				int vmirror);
+static int opl_rotate90_vmirror_u16_both(const u8 * src, int src_line_stride,
+					 int width, int height, u8 * dst,
+					 int dst_line_stride, int vmirror);
+int opl_rotate90_u16_qcif(const u8 * src, u8 * dst);
+
+int opl_rotate90_u16(const u8 * src, int src_line_stride, int width, int height,
+		     u8 * dst, int dst_line_stride)
+{
+	return opl_rotate90_vmirror_u16_both(src, src_line_stride, width,
+					    height, dst, dst_line_stride, 0);
+}
+
+int opl_rotate90_vmirror_u16(const u8 * src, int src_line_stride, int width,
+			    int height, u8 * dst, int dst_line_stride)
+{
+	return opl_rotate90_vmirror_u16_both(src, src_line_stride, width,
+					    height, dst, dst_line_stride, 1);
+}
+
+static int opl_rotate90_vmirror_u16_both(const u8 * src, int src_line_stride,
+					 int width, int height, u8 * dst,
+					 int dst_line_stride, int vmirror)
+{
+	const int BLOCK_SIZE_PIXELS = CACHE_LINE_WORDS * BYTES_PER_WORD
+	    / BYTES_PER_PIXEL;
+	const int BLOCK_SIZE_PIXELS_BY4 = CACHE_LINE_WORDS * BYTES_PER_WORD
+	    / BYTES_PER_PIXEL / 4;
+
+	if (!src || !dst)
+		return OPLERR_NULL_PTR;
+
+	if (width == 0 || height == 0 || src_line_stride == 0
+	    || dst_line_stride == 0)
+		return OPLERR_BAD_ARG;
+
+	/* The QCIF algorithm doesn't support vertical mirroring */
+	if (vmirror == 0 && width == QCIF_Y_WIDTH && height == QCIF_Y_HEIGHT
+	    && src_line_stride == QCIF_Y_WIDTH * 2
+	    && src_line_stride == QCIF_Y_HEIGHT * 2)
+		return opl_rotate90_u16_qcif(src, dst);
+	else if (width % BLOCK_SIZE_PIXELS == 0
+		 && height % BLOCK_SIZE_PIXELS == 0)
+		return opl_rotate90_u16_by16(src, src_line_stride, width,
+					     height, dst, dst_line_stride,
+					     vmirror);
+	else if (width % BLOCK_SIZE_PIXELS_BY4 == 0
+		 && height % BLOCK_SIZE_PIXELS_BY4 == 0)
+		return opl_rotate90_u16_by4(src, src_line_stride, width, height,
+					    dst, dst_line_stride, vmirror);
+	else
+		return OPLERR_BAD_ARG;
+}
+
+/*
+ * Performs clockwise rotation (and possibly vertical mirroring depending
+ * on the vmirror flag) using block sizes of 16x16
+ * The algorithm is similar to 270 degree clockwise rotation algorithm
+ */
+static int opl_rotate90_u16_by16(const u8 * src, int src_line_stride, int width,
+				 int height, u8 * dst, int dst_line_stride,
+				 int vmirror)
+{
+	const int BLOCK_SIZE_PIXELS = CACHE_LINE_WORDS * BYTES_PER_WORD
+	    / BYTES_PER_PIXEL;
+	const int BLOCK_SIZE_BYTES = BYTES_PER_PIXEL * BLOCK_SIZE_PIXELS;
+	const int IN_INDEX = src_line_stride * BLOCK_SIZE_PIXELS
+	    + BYTES_PER_PIXEL;
+	const int OUT_INDEX = vmirror ?
+	    -dst_line_stride - BLOCK_SIZE_BYTES
+	    : dst_line_stride - BLOCK_SIZE_BYTES;
+	const u8 *in_block_ptr;
+	u8 *out_block_ptr;
+	int i, k;
+
+	for (k = height / BLOCK_SIZE_PIXELS; k > 0; k--) {
+		in_block_ptr = src + src_line_stride * (height - 1)
+		    - (src_line_stride * BLOCK_SIZE_PIXELS *
+		       (height / BLOCK_SIZE_PIXELS - k));
+		out_block_ptr = dst + BYTES_PER_PIXEL * BLOCK_SIZE_PIXELS *
+		    ((height / BLOCK_SIZE_PIXELS) - k);
+
+		/*
+		 * For vertical mirroring the writing starts from the
+		 * bottom line
+		 */
+		if (vmirror)
+			out_block_ptr += dst_line_stride * (width - 1);
+
+		for (i = width; i > 0; i--) {
+			__asm__ volatile (
+				"ldrh	r2, [%0], -%4\n\t"
+				"ldrh	r3, [%0], -%4\n\t"
+				"ldrh	r4, [%0], -%4\n\t"
+				"ldrh	r5, [%0], -%4\n\t"
+				"orr	r2, r2, r3, lsl #16\n\t"
+				"orr	r4, r4, r5, lsl #16\n\t"
+				"str	r2, [%1], #4\n\t"
+				"str	r4, [%1], #4\n\t"
+
+				"ldrh	r2, [%0], -%4\n\t"
+				"ldrh	r3, [%0], -%4\n\t"
+				"ldrh	r4, [%0], -%4\n\t"
+				"ldrh	r5, [%0], -%4\n\t"
+				"orr	r2, r2, r3, lsl #16\n\t"
+				"orr	r4, r4, r5, lsl #16\n\t"
+				"str	r2, [%1], #4\n\t"
+				"str	r4, [%1], #4\n\t"
+
+				"ldrh	r2, [%0], -%4\n\t"
+				"ldrh	r3, [%0], -%4\n\t"
+				"ldrh	r4, [%0], -%4\n\t"
+				"ldrh	r5, [%0], -%4\n\t"
+				"orr	r2, r2, r3, lsl #16\n\t"
+				"orr	r4, r4, r5, lsl #16\n\t"
+				"str	r2, [%1], #4\n\t"
+				"str	r4, [%1], #4\n\t"
+
+				"ldrh	r2, [%0], -%4\n\t"
+				"ldrh	r3, [%0], -%4\n\t"
+				"ldrh	r4, [%0], -%4\n\t"
+				"ldrh	r5, [%0], -%4\n\t"
+				"orr	r2, r2, r3, lsl #16\n\t"
+				"orr	r4, r4, r5, lsl #16\n\t"
+				"str	r2, [%1], #4\n\t"
+				"str	r4, [%1], #4\n\t"
+
+				:"+r" (in_block_ptr), "+r"(out_block_ptr)	/* output */
+				:"0"(in_block_ptr), "1"(out_block_ptr), "r"(src_line_stride)	/* input  */
+				:"r2", "r3", "r4", "r5", "memory"	/* modify */
+			);
+			in_block_ptr += IN_INDEX;
+			out_block_ptr += OUT_INDEX;
+		}
+	}
+
+	return OPLERR_SUCCESS;
+}
+
+/*
+ * Performs clockwise rotation (and possibly vertical mirroring depending
+ * on the vmirror flag) using block sizes of 4x4
+ * The algorithm is similar to 270 degree clockwise rotation algorithm
+ */
+static int opl_rotate90_u16_by4(const u8 * src, int src_line_stride, int width,
+				int height, u8 * dst, int dst_line_stride,
+				int vmirror)
+{
+	const int BLOCK_SIZE_PIXELS = CACHE_LINE_WORDS * BYTES_PER_WORD
+	    / BYTES_PER_PIXEL / 4;
+	const int BLOCK_SIZE_BYTES = BYTES_PER_PIXEL * BLOCK_SIZE_PIXELS;
+	const int IN_INDEX = src_line_stride * BLOCK_SIZE_PIXELS
+	    + BYTES_PER_PIXEL;
+	const int OUT_INDEX = vmirror ?
+	    -dst_line_stride - BLOCK_SIZE_BYTES
+	    : dst_line_stride - BLOCK_SIZE_BYTES;
+	const u8 *in_block_ptr;
+	u8 *out_block_ptr;
+	int i, k;
+
+	for (k = height / BLOCK_SIZE_PIXELS; k > 0; k--) {
+		in_block_ptr = src + src_line_stride * (height - 1)
+		    - (src_line_stride * BLOCK_SIZE_PIXELS *
+		       (height / BLOCK_SIZE_PIXELS - k));
+		out_block_ptr = dst + BYTES_PER_PIXEL * BLOCK_SIZE_PIXELS
+		    * ((height / BLOCK_SIZE_PIXELS) - k);
+
+		/*
+		 * For horizontal mirroring the writing starts from the
+		 * bottom line
+		 */
+		if (vmirror)
+			out_block_ptr += dst_line_stride * (width - 1);
+
+		for (i = width; i > 0; i--) {
+			__asm__ volatile (
+				"ldrh	r2, [%0], -%4\n\t"
+				"ldrh	r3, [%0], -%4\n\t"
+				"ldrh	r4, [%0], -%4\n\t"
+				"ldrh	r5, [%0], -%4\n\t"
+				"orr	r2, r2, r3, lsl #16\n\t"
+				"orr	r4, r4, r5, lsl #16\n\t"
+				"str	r2, [%1], #4\n\t"
+				"str	r4, [%1], #4\n\t"
+
+				:"+r" (in_block_ptr), "+r"(out_block_ptr)	/* output */
+				:"0"(in_block_ptr), "1"(out_block_ptr), "r"(src_line_stride)	/* input  */
+				:"r2", "r3", "r4", "r5", "memory"	/* modify */
+			);
+			in_block_ptr += IN_INDEX;
+			out_block_ptr += OUT_INDEX;
+		}
+	}
+
+	return OPLERR_SUCCESS;
+}
+
+EXPORT_SYMBOL(opl_rotate90_u16);
+EXPORT_SYMBOL(opl_rotate90_vmirror_u16);
Index: linux-2.6.18/drivers/media/video/mxc/opl/rotate90_u16_qcif.S
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/media/video/mxc/opl/rotate90_u16_qcif.S
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#include <linux/linkage.h>
+
+	.text
+	.align	2
+ENTRY(opl_rotate90_u16_qcif)
+        STMFD    sp!,{r4-r10}
+        MOV      r12,#0x160
+        MOV      r10,#0x90
+        MOV      r3,r10,LSR #4
+.L1.216:
+        RSB      r2,r3,r10,LSR #4
+        MOV      r4,#0x20
+        SMULBB   r5,r4,r2
+        MOV      r4,#0x1600
+        SMULBB   r2,r4,r2
+        ADD      r4,r0,#0xc000
+        ADD      r4,r4,#0x4a0
+        SUB      r4,r4,r2
+        MOV      r2,r12,LSR #1
+        ADD      r5,r1,r5
+.L1.256:
+        LDRH     r6,[r4],-r12
+        LDRH     r7,[r4],-r12
+        LDRH     r8,[r4],-r12
+        LDRH     r9,[r4],-r12
+        ORR      r6,r6,r7,LSL #16
+        ORR      r7,r8,r9,LSL #16
+        STMIA    r5!,{r6,r7}
+        SUBS     r2,r2,#1
+        LDRH     r6,[r4],-r12
+        LDRH     r7,[r4],-r12
+        LDRH     r8,[r4],-r12
+        LDRH     r9,[r4],-r12
+        ORR      r6,r6,r7,LSL #16
+        ORR      r7,r8,r9,LSL #16
+        STMIA    r5!,{r6,r7}
+        LDRH     r6,[r4],-r12
+        LDRH     r7,[r4],-r12
+        LDRH     r8,[r4],-r12
+        LDRH     r9,[r4],-r12
+        ORR      r6,r6,r7,LSL #16
+        ORR      r7,r8,r9,LSL #16
+        STMIA    r5!,{r6,r7}
+        LDRH     r6,[r4],-r12
+        LDRH     r7,[r4],-r12
+        LDRH     r8,[r4],-r12
+        LDRH     r9,[r4],-r12
+        ORR      r6,r6,r7,LSL #16
+        ORR      r7,r8,r9,LSL #16
+        ADD      r4,r4,#0x1600
+        STMIA    r5!,{r6,r7}
+        ADD      r5,r5,#0x100
+        ADD      r4,r4,#2
+        BGT      .L1.256
+        SUBS     r3,r3,#1
+        BGT      .L1.216
+        LDMFD    sp!,{r4-r10}
+        BX       lr
+	.size	opl_rotate90_u16_qcif, . - opl_rotate90_u16_qcif
Index: linux-2.6.18/drivers/media/video/mxc/opl/vmirror_u16.c
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/media/video/mxc/opl/vmirror_u16.c
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/string.h>
+#include "opl.h"
+
+int opl_vmirror_u16(const u8 * src, int src_line_stride, int width, int height,
+		    u8 * dst, int dst_line_stride)
+{
+	const u8 *src_row_addr;
+	u8 *dst_row_addr;
+	int i;
+
+	if (!src || !dst)
+		return OPLERR_NULL_PTR;
+
+	if (width == 0 || height == 0 || src_line_stride == 0
+	    || dst_line_stride == 0)
+		return OPLERR_BAD_ARG;
+
+	src_row_addr = src;
+	dst_row_addr = dst + (height - 1) * dst_line_stride;
+
+	/* Loop over all rows */
+	for (i = 0; i < height; i++) {
+		/* memcpy each row */
+		memcpy(dst_row_addr, src_row_addr, BYTES_PER_PIXEL * width);
+		src_row_addr += src_line_stride;
+		dst_row_addr -= dst_line_stride;
+	}
+
+	return OPLERR_SUCCESS;
+}
+
+EXPORT_SYMBOL(opl_vmirror_u16);
Index: linux-2.6.18/include/asm-arm/arch-mxc/ipu.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/asm-arm/arch-mxc/ipu.h
@@ -0,0 +1,768 @@
+/*
+ * Copyright 2005-2007 Freescale Semiconductor, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+/*!
+ * @defgroup IPU MXC Image Processing Unit (IPU) Driver
+ */
+/*!
+ * @file arch-mxc/ipu.h
+ *
+ * @brief This file contains the IPU driver API declarations.
+ *
+ * @ingroup IPU
+ */
+
+#ifndef __ASM_ARCH_IPU_H__
+#define __ASM_ARCH_IPU_H__
+
+#include <linux/types.h>
+#include <linux/interrupt.h>
+
+/*!
+ * Enumeration of IPU rotation modes
+ */
+typedef enum {
+	/* Note the enum values correspond to BAM value */
+	IPU_ROTATE_NONE = 0,
+	IPU_ROTATE_VERT_FLIP = 1,
+	IPU_ROTATE_HORIZ_FLIP = 2,
+	IPU_ROTATE_180 = 3,
+	IPU_ROTATE_90_RIGHT = 4,
+	IPU_ROTATE_90_RIGHT_VFLIP = 5,
+	IPU_ROTATE_90_RIGHT_HFLIP = 6,
+	IPU_ROTATE_90_LEFT = 7,
+} ipu_rotate_mode_t;
+
+/*!
+ * Enumeration of Post Filter modes
+ */
+typedef enum {
+	PF_DISABLE_ALL = 0,
+	PF_MPEG4_DEBLOCK = 1,
+	PF_MPEG4_DERING = 2,
+	PF_MPEG4_DEBLOCK_DERING = 3,
+	PF_H264_DEBLOCK = 4,
+} pf_operation_t;
+
+/*!
+ * Enumeration of Synchronous (Memory-less) panel types
+ */
+typedef enum {
+	IPU_PANEL_SHARP_TFT,
+	IPU_PANEL_TFT,
+} ipu_panel_t;
+
+/*  IPU Pixel format definitions */
+/*  Four-character-code (FOURCC) */
+#define ipu_fourcc(a,b,c,d)\
+        (((__u32)(a)<<0)|((__u32)(b)<<8)|((__u32)(c)<<16)|((__u32)(d)<<24))
+
+/*!
+ * @name IPU Pixel Formats
+ *
+ * Pixel formats are defined with ASCII FOURCC code. The pixel format codes are
+ * the same used by V4L2 API.
+ */
+
+/*! @{ */
+/*! @name Generic or Raw Data Formats */
+/*! @{ */
+#define IPU_PIX_FMT_GENERIC ipu_fourcc('I','P','U','0')	/*!< IPU Generic Data */
+#define IPU_PIX_FMT_GENERIC_32 ipu_fourcc('I','P','U','1')	/*!< IPU Generic Data */
+/*! @} */
+/*! @name RGB Formats */
+/*! @{ */
+#define IPU_PIX_FMT_RGB332  ipu_fourcc('R','G','B','1')	/*!<  8  RGB-3-3-2     */
+#define IPU_PIX_FMT_RGB555  ipu_fourcc('R','G','B','O')	/*!< 16  RGB-5-5-5     */
+#define IPU_PIX_FMT_RGB565  ipu_fourcc('R','G','B','P')	/*!< 16  RGB-5-6-5     */
+#define IPU_PIX_FMT_RGB666  ipu_fourcc('R','G','B','6')	/*!< 18  RGB-6-6-6     */
+#define IPU_PIX_FMT_BGR666  ipu_fourcc('B','G','R','6')	/*!< 18  BGR-6-6-6     */
+#define IPU_PIX_FMT_BGR24   ipu_fourcc('B','G','R','3')	/*!< 24  BGR-8-8-8     */
+#define IPU_PIX_FMT_RGB24   ipu_fourcc('R','G','B','3')	/*!< 24  RGB-8-8-8     */
+#define IPU_PIX_FMT_BGR32   ipu_fourcc('B','G','R','4')	/*!< 32  BGR-8-8-8-8   */
+#define IPU_PIX_FMT_BGRA32  ipu_fourcc('B','G','R','A')	/*!< 32  BGR-8-8-8-8   */
+#define IPU_PIX_FMT_RGB32   ipu_fourcc('R','G','B','4')	/*!< 32  RGB-8-8-8-8   */
+#define IPU_PIX_FMT_RGBA32  ipu_fourcc('R','G','B','A')	/*!< 32  RGB-8-8-8-8   */
+#define IPU_PIX_FMT_ABGR32  ipu_fourcc('A','B','G','R')	/*!< 32  ABGR-8-8-8-8  */
+/*! @} */
+/*! @name YUV Interleaved Formats */
+/*! @{ */
+#define IPU_PIX_FMT_YUYV    ipu_fourcc('Y','U','Y','V')	/*!< 16  YUV 4:2:2     */
+#define IPU_PIX_FMT_UYVY    ipu_fourcc('U','Y','V','Y')	/*!< 16  YUV 4:2:2     */
+#define IPU_PIX_FMT_Y41P    ipu_fourcc('Y','4','1','P')	/*!< 12  YUV 4:1:1     */
+/*! @} */
+/*! @name YUV Planar Formats */
+/*! @{ */
+#define IPU_PIX_FMT_GREY    ipu_fourcc('G','R','E','Y')	/*!< 8  Greyscale     */
+#define IPU_PIX_FMT_YVU410P ipu_fourcc('Y','V','U','9')	/*!< 9  YVU 4:1:0     */
+#define IPU_PIX_FMT_YUV410P ipu_fourcc('Y','U','V','9')	/*!< 9  YUV 4:1:0     */
+#define IPU_PIX_FMT_YVU420P ipu_fourcc('Y','V','1','2')	/*!< 12  YVU 4:2:0     */
+#define IPU_PIX_FMT_YUV420P ipu_fourcc('I','4','2','0')	/*!< 12  YUV420 planar */
+#define IPU_PIX_FMT_YUV420P2 ipu_fourcc('Y','U','1','2')	/*!< 12  YUV 4:2:0 planar */
+#define IPU_PIX_FMT_YVU422P ipu_fourcc('Y','V','1','6')	/*!< 16  YVU422 planar */
+#define IPU_PIX_FMT_YUV422P ipu_fourcc('4','2','2','P')	/*!< 16  YUV422 planar */
+/*! @} */
+
+/*#define IPU_PIX_FMT_YUV411P ipu_fourcc('4','1','1','P')  16  YVU411 planar */
+/*#define IPU_PIX_FMT_YYUV    ipu_fourcc('Y','Y','U','V')  16  YUV 4:2:2     */
+
+/* IPU Driver channels definitions.	*/
+/* Note these are different from IDMA channels */
+#define _MAKE_CHAN(num, in, out, sec)    ((num << 24) | (sec << 16) | (out << 8) | in)
+#define IPU_CHAN_ID(ch)         (ch >> 24)
+#define IPU_CHAN_SEC_DMA(ch)    ((uint32_t) (ch >> 16) & 0xFF)
+#define IPU_CHAN_OUT_DMA(ch)    ((uint32_t) (ch >> 8) & 0xFF)
+#define IPU_CHAN_IN_DMA(ch)     ((uint32_t) (ch & 0xFF))
+
+/*!
+ * Enumeration of IPU logical channels. An IPU logical channel is defined as a
+ * combination of an input (memory to IPU), output (IPU to memory), and/or
+ * secondary input IDMA channels and in some cases an Image Converter task.
+ * Some channels consist of only an input or output.
+ */
+typedef enum {
+	CSI_MEM = _MAKE_CHAN(1, 0xFF, 7, 0xFF),	/*!< CSI raw sensor data to memory */
+
+	CSI_PRP_ENC_MEM = _MAKE_CHAN(2, 0xFF, 0, 0xFF),	/*!< CSI to IC Encoder PreProcessing to Memory */
+	MEM_PRP_ENC_MEM = _MAKE_CHAN(3, 6, 0, 0xFF),	/*!< Memory to IC Encoder PreProcessing to Memory */
+	MEM_ROT_ENC_MEM = _MAKE_CHAN(4, 10, 8, 0xFF),	/*!< Memory to IC Encoder Rotation to Memory */
+
+	CSI_PRP_VF_MEM = _MAKE_CHAN(5, 0xFF, 1, 0xFF),	/*!< CSI to IC Viewfinder PreProcessing to Memory */
+	CSI_PRP_VF_ADC = _MAKE_CHAN(6, 0xFF, 1, 0xFF),	/*!< CSI to IC Viewfinder PreProcessing to ADC */
+	MEM_PRP_VF_MEM = _MAKE_CHAN(7, 6, 1, 3),	/*!< Memory to IC Viewfinder PreProcessing to Memory */
+	MEM_PRP_VF_ADC = _MAKE_CHAN(8, 6, 1, 3),	/*!< Memory to IC Viewfinder PreProcessing to ADC */
+	MEM_ROT_VF_MEM = _MAKE_CHAN(9, 11, 9, 0xFF),	/*!< Memory to IC Viewfinder Rotation to Memory */
+
+	MEM_PP_MEM = _MAKE_CHAN(10, 5, 2, 4),	/*!< Memory to IC PostProcessing to Memory */
+	MEM_ROT_PP_MEM = _MAKE_CHAN(11, 13, 12, 0xFF),	/*!< Memory to IC PostProcessing Rotation to Memory */
+	MEM_PP_ADC = _MAKE_CHAN(12, 5, 2, 4),	/*!< Memory to IC PostProcessing to ADC */
+
+	MEM_SDC_BG = _MAKE_CHAN(14, 14, 0xFF, 0xFF),	/*!< Memory to SDC Background plane */
+	MEM_SDC_FG = _MAKE_CHAN(15, 15, 0xFF, 0xFF),	/*!< Memory to SDC Foreground plane */
+	MEM_SDC_MASK = _MAKE_CHAN(16, 16, 0xFF, 0xFF),	/*!< Memory to SDC Mask */
+
+	ADC_SYS1 = _MAKE_CHAN(17, 18, 22, 20),	/*!< Memory to ADC System Channel 1 */
+	ADC_SYS2 = _MAKE_CHAN(18, 19, 23, 21),	/*!< Memory to ADC System Channel 2 */
+
+	MEM_PF_Y_MEM = _MAKE_CHAN(19, 26, 29, 24),	/*!< Y and PF Memory to Post-filter to Y Memory */
+	MEM_PF_U_MEM = _MAKE_CHAN(20, 27, 30, 25),	/*!< U and PF Memory to Post-filter to U Memory */
+	MEM_PF_V_MEM = _MAKE_CHAN(21, 28, 31, 0xFF),	/*!< V Memory to Post-filter to V Memory */
+
+	CHAN_NONE = 0xFFFFFFFF,
+} ipu_channel_t;
+
+/*!
+ * Enumeration of types of buffers for a logical channel.
+ */
+typedef enum {
+	IPU_INPUT_BUFFER,	/*!< Buffer for input to IPU */
+	IPU_OUTPUT_BUFFER,	/*!< Buffer for output from IPU */
+	IPU_SEC_INPUT_BUFFER,	/*!< Buffer for second input to IPU */
+} ipu_buffer_t;
+
+/*!
+ * Enumeration of DI ports for ADC.
+ */
+typedef enum {
+	DISP0,
+	DISP1,
+	DISP2,
+	DISP3
+} display_port_t;
+
+/*!
+ * Enumeration of ADC channels.
+typedef enum
+{
+        PRPCHAN,
+        PPCHAN,
+        SYSCHAN1,
+        SYSCHAN2
+}sys_channel_t;
+ */
+
+/*!
+ * Enumeration of ADC channel operation mode.
+ */
+typedef enum {
+	Disable,
+	WriteTemplateNonSeq,
+	ReadTemplateNonSeq,
+	WriteTemplateUnCon,
+	ReadTemplateUnCon,
+	WriteDataWithRS,
+	WriteDataWoRS,
+	WriteCmd
+} mcu_mode_t;
+
+/*!
+ * Enumeration of ADC channel addressing mode.
+ */
+typedef enum {
+	FullWoBE,
+	FullWithBE,
+	XY
+} display_addressing_t;
+
+/*!
+ * Union of initialization parameters for a logical channel.
+ */
+typedef union {
+	struct {
+		uint32_t temp;
+	} csi_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+	} csi_prp_enc_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+	} mem_prp_enc_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+	} mem_rot_enc_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+		bool graphics_combine_en;
+		bool global_alpha_en;
+		bool key_color_en;
+	} csi_prp_vf_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+		bool graphics_combine_en;
+		bool global_alpha_en;
+		bool key_color_en;
+		display_port_t disp;
+		uint32_t out_left;
+		uint32_t out_top;
+	} csi_prp_vf_adc;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+		bool graphics_combine_en;
+		bool global_alpha_en;
+		bool key_color_en;
+	} mem_prp_vf_mem;
+	struct {
+		uint32_t temp;
+	} mem_prp_vf_adc;
+	struct {
+		uint32_t temp;
+	} mem_rot_vf_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+		bool graphics_combine_en;
+		bool global_alpha_en;
+		bool key_color_en;
+	} mem_pp_mem;
+	struct {
+		uint32_t temp;
+	} mem_rot_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+		bool graphics_combine_en;
+		bool global_alpha_en;
+		bool key_color_en;
+		display_port_t disp;
+		uint32_t out_left;
+		uint32_t out_top;
+	} mem_pp_adc;
+
+	struct {
+		pf_operation_t operation;
+	} mem_pf_mem;
+
+	struct {
+		uint32_t temp;
+	} mem_sdc_fg;
+	struct {
+		uint32_t temp;
+	} mem_sdc_bg;
+	struct {
+		display_port_t disp;
+		mcu_mode_t ch_mode;
+		uint32_t out_left;
+		uint32_t out_top;
+	} adc_sys1;
+	struct {
+		display_port_t disp;
+		mcu_mode_t ch_mode;
+		uint32_t out_left;
+		uint32_t out_top;
+	} adc_sys2;
+} ipu_channel_params_t;
+
+/*!
+ * Enumeration of IPU interrupt sources.
+ */
+enum ipu_irq_line {
+	IPU_IRQ_PRP_ENC_OUT_EOF = 0,
+	IPU_IRQ_PRP_VF_OUT_EOF = 1,
+	IPU_IRQ_PP_OUT_EOF = 2,
+	IPU_IRQ_PRP_GRAPH_IN_EOF = 3,
+	IPU_IRQ_PP_GRAPH_IN_EOF = 4,
+	IPU_IRQ_PP_IN_EOF = 5,
+	IPU_IRQ_PRP_IN_EOF = 6,
+	IPU_IRQ_SENSOR_OUT_EOF = 7,
+	IPU_IRQ_PRP_ENC_ROT_OUT_EOF = 8,
+	IPU_IRQ_PRP_VF_ROT_OUT_EOF = 9,
+	IPU_IRQ_PRP_ENC_ROT_IN_EOF = 10,
+	IPU_IRQ_PRP_VF_ROT_IN_EOF = 11,
+	IPU_IRQ_PP_ROT_OUT_EOF = 12,
+	IPU_IRQ_PP_ROT_IN_EOF = 13,
+	IPU_IRQ_SDC_BG_EOF = 14,
+	IPU_IRQ_SDC_FG_EOF = 15,
+	IPU_IRQ_SDC_MASK_EOF = 16,
+	IPU_IRQ_SDC_BG_PART_EOF = 17,
+	IPU_IRQ_ADC_SYS1_WR_EOF = 18,
+	IPU_IRQ_ADC_SYS2_WR_EOF = 19,
+	IPU_IRQ_ADC_SYS1_CMD_EOF = 20,
+	IPU_IRQ_ADC_SYS2_CMD_EOF = 21,
+	IPU_IRQ_ADC_SYS1_RD_EOF = 22,
+	IPU_IRQ_ADC_SYS2_RD_EOF = 23,
+	IPU_IRQ_PF_QP_IN_EOF = 24,
+	IPU_IRQ_PF_BSP_IN_EOF = 25,
+	IPU_IRQ_PF_Y_IN_EOF = 26,
+	IPU_IRQ_PF_U_IN_EOF = 27,
+	IPU_IRQ_PF_V_IN_EOF = 28,
+	IPU_IRQ_PF_Y_OUT_EOF = 29,
+	IPU_IRQ_PF_U_OUT_EOF = 30,
+	IPU_IRQ_PF_V_OUT_EOF = 31,
+
+	IPU_IRQ_PRP_ENC_OUT_NF = 32,
+	IPU_IRQ_PRP_VF_OUT_NF = 33,
+	IPU_IRQ_PP_OUT_NF = 34,
+	IPU_IRQ_PRP_GRAPH_IN_NF = 35,
+	IPU_IRQ_PP_GRAPH_IN_NF = 36,
+	IPU_IRQ_PP_IN_NF = 37,
+	IPU_IRQ_PRP_IN_NF = 38,
+	IPU_IRQ_SENSOR_OUT_NF = 39,
+	IPU_IRQ_PRP_ENC_ROT_OUT_NF = 40,
+	IPU_IRQ_PRP_VF_ROT_OUT_NF = 41,
+	IPU_IRQ_PRP_ENC_ROT_IN_NF = 42,
+	IPU_IRQ_PRP_VF_ROT_IN_NF = 43,
+	IPU_IRQ_PP_ROT_OUT_NF = 44,
+	IPU_IRQ_PP_ROT_IN_NF = 45,
+	IPU_IRQ_SDC_FG_NF = 46,
+	IPU_IRQ_SDC_BG_NF = 47,
+	IPU_IRQ_SDC_MASK_NF = 48,
+	IPU_IRQ_SDC_BG_PART_NF = 49,
+	IPU_IRQ_ADC_SYS1_WR_NF = 50,
+	IPU_IRQ_ADC_SYS2_WR_NF = 51,
+	IPU_IRQ_ADC_SYS1_CMD_NF = 52,
+	IPU_IRQ_ADC_SYS2_CMD_NF = 53,
+	IPU_IRQ_ADC_SYS1_RD_NF = 54,
+	IPU_IRQ_ADC_SYS2_RD_NF = 55,
+	IPU_IRQ_PF_QP_IN_NF = 56,
+	IPU_IRQ_PF_BSP_IN_NF = 57,
+	IPU_IRQ_PF_Y_IN_NF = 58,
+	IPU_IRQ_PF_U_IN_NF = 59,
+	IPU_IRQ_PF_V_IN_NF = 60,
+	IPU_IRQ_PF_Y_OUT_NF = 61,
+	IPU_IRQ_PF_U_OUT_NF = 62,
+	IPU_IRQ_PF_V_OUT_NF = 63,
+
+	IPU_IRQ_BREAKRQ = 64,
+	IPU_IRQ_SDC_BG_OUT_EOF = 65,
+	IPU_IRQ_SDC_FG_OUT_EOF = 66,
+	IPU_IRQ_SDC_MASK_OUT_EOF = 67,
+	IPU_IRQ_ADC_SERIAL_DATA_OUT = 68,
+	IPU_IRQ_SENSOR_NF = 69,
+	IPU_IRQ_SENSOR_EOF = 70,
+	IPU_IRQ_SDC_DISP3_VSYNC = 80,
+	IPU_IRQ_ADC_DISP0_VSYNC = 81,
+	IPU_IRQ_ADC_DISP12_VSYNC = 82,
+	IPU_IRQ_ADC_PRP_EOF = 83,
+	IPU_IRQ_ADC_PP_EOF = 84,
+	IPU_IRQ_ADC_SYS1_EOF = 85,
+	IPU_IRQ_ADC_SYS2_EOF = 86,
+
+	IPU_IRQ_PRP_ENC_OUT_NFB4EOF_ERR = 96,
+	IPU_IRQ_PRP_VF_OUT_NFB4EOF_ERR = 97,
+	IPU_IRQ_PP_OUT_NFB4EOF_ERR = 98,
+	IPU_IRQ_PRP_GRAPH_IN_NFB4EOF_ERR = 99,
+	IPU_IRQ_PP_GRAPH_IN_NFB4EOF_ERR = 100,
+	IPU_IRQ_PP_IN_NFB4EOF_ERR = 101,
+	IPU_IRQ_PRP_IN_NFB4EOF_ERR = 102,
+	IPU_IRQ_SENSOR_OUT_NFB4EOF_ERR = 103,
+	IPU_IRQ_PRP_ENC_ROT_OUT_NFB4EOF_ERR = 104,
+	IPU_IRQ_PRP_VF_ROT_OUT_NFB4EOF_ERR = 105,
+	IPU_IRQ_PRP_ENC_ROT_IN_NFB4EOF_ERR = 106,
+	IPU_IRQ_PRP_VF_ROT_IN_NFB4EOF_ERR = 107,
+	IPU_IRQ_PP_ROT_OUT_NFB4EOF_ERR = 108,
+	IPU_IRQ_PP_ROT_IN_NFB4EOF_ERR = 109,
+	IPU_IRQ_SDC_FG_NFB4EOF_ERR = 110,
+	IPU_IRQ_SDC_BG_NFB4EOF_ERR = 111,
+	IPU_IRQ_SDC_MASK_NFB4EOF_ERR = 112,
+	IPU_IRQ_SDC_BG_PART_NFB4EOF_ERR = 113,
+	IPU_IRQ_ADC_SYS1_WR_NFB4EOF_ERR = 114,
+	IPU_IRQ_ADC_SYS2_WR_NFB4EOF_ERR = 115,
+	IPU_IRQ_ADC_SYS1_CMD_NFB4EOF_ERR = 116,
+	IPU_IRQ_ADC_SYS2_CMD_NFB4EOF_ERR = 117,
+	IPU_IRQ_ADC_SYS1_RD_NFB4EOF_ERR = 118,
+	IPU_IRQ_ADC_SYS2_RD_NFB4EOF_ERR = 119,
+	IPU_IRQ_PF_QP_IN_NFB4EOF_ERR = 120,
+	IPU_IRQ_PF_BSP_IN_NFB4EOF_ERR = 121,
+	IPU_IRQ_PF_Y_IN_NFB4EOF_ERR = 122,
+	IPU_IRQ_PF_U_IN_NFB4EOF_ERR = 123,
+	IPU_IRQ_PF_V_IN_NFB4EOF_ERR = 124,
+	IPU_IRQ_PF_Y_OUT_NFB4EOF_ERR = 125,
+	IPU_IRQ_PF_U_OUT_NFB4EOF_ERR = 126,
+	IPU_IRQ_PF_V_OUT_NFB4EOF_ERR = 127,
+
+	IPU_IRQ_BAYER_BUFOVF_ERR = 128,
+	IPU_IRQ_ENC_BUFOVF_ERR = 129,
+	IPU_IRQ_VF_BUFOVF_ERR = 130,
+	IPU_IRQ_ADC_PP_TEAR_ERR = 131,
+	IPU_IRQ_ADC_SYS1_TEAR_ERR = 132,
+	IPU_IRQ_ADC_SYS2_TEAR_ERR = 133,
+	IPU_IRQ_SDC_BGD_ERR = 134,
+	IPU_IRQ_SDC_FGD_ERR = 135,
+	IPU_IRQ_SDC_MASKD_ERR = 136,
+	IPU_IRQ_BAYER_FRM_LOST_ERR = 137,
+	IPU_IRQ_ENC_FRM_LOST_ERR = 138,
+	IPU_IRQ_VF_FRM_LOST_ERR = 139,
+	IPU_IRQ_ADC_LOCK_ERR = 140,
+	IPU_IRQ_DI_LLA_LOCK_ERR = 141,
+	IPU_IRQ_AHB_M1_ERR = 142,
+	IPU_IRQ_AHB_M12_ERR = 143,
+
+	IPU_IRQ_COUNT
+};
+
+/*!
+ * Bitfield of Display Interface signal polarities.
+ */
+typedef struct {
+	unsigned datamask_en:1;
+	unsigned clksel_en:1;
+	unsigned clkidle_en:1;
+	unsigned data_pol:1;	/* true = inverted */
+	unsigned clk_pol:1;	/* true = rising edge */
+	unsigned enable_pol:1;
+	unsigned Hsync_pol:1;	/* true = active high */
+	unsigned Vsync_pol:1;
+} ipu_di_signal_cfg_t;
+
+/*!
+ * Bitfield of CSI signal polarities and modes.
+ */
+typedef struct {
+	unsigned data_width:3;
+	unsigned clk_mode:2;
+	unsigned ext_vsync:1;
+	unsigned Vsync_pol:1;
+	unsigned Hsync_pol:1;
+	unsigned pixclk_pol:1;
+	unsigned data_pol:1;
+	unsigned sens_clksrc:1;
+} ipu_csi_signal_cfg_t;
+
+/*!
+ * Enumeration of CSI data bus widths.
+ */
+enum {
+	IPU_CSI_DATA_WIDTH_4,
+	IPU_CSI_DATA_WIDTH_8,
+	IPU_CSI_DATA_WIDTH_10,
+	IPU_CSI_DATA_WIDTH_16,
+};
+
+/*!
+ * Enumeration of CSI clock modes.
+ */
+enum {
+	IPU_CSI_CLK_MODE_GATED_CLK,
+	IPU_CSI_CLK_MODE_NONGATED_CLK,
+	IPU_CSI_CLK_MODE_CCIR656_PROGRESSIVE,
+	IPU_CSI_CLK_MODE_CCIR656_INTERLACED,
+};
+
+typedef enum {
+	RGB,
+	YCbCr,
+	YUV
+} ipu_color_space_t;
+
+/*!
+ * Enumeration of ADC vertical sync mode.
+ */
+typedef enum {
+	VsyncNone,
+	VsyncInternal,
+	VsyncCSI,
+	VsyncExternal
+} vsync_t;
+
+typedef enum {
+	DAT,
+	CMD
+} cmddata_t;
+
+/*!
+ * Enumeration of ADC display update mode.
+ */
+typedef enum {
+	IPU_ADC_REFRESH_NONE,
+	IPU_ADC_AUTO_REFRESH,
+	IPU_ADC_AUTO_REFRESH_SNOOP,
+	IPU_ADC_SNOOPING,
+} ipu_adc_update_mode_t;
+
+/*!
+ * Enumeration of ADC display interface types (serial or parallel).
+ */
+enum {
+	IPU_ADC_IFC_MODE_SYS80_TYPE1,
+	IPU_ADC_IFC_MODE_SYS80_TYPE2,
+	IPU_ADC_IFC_MODE_SYS68K_TYPE1,
+	IPU_ADC_IFC_MODE_SYS68K_TYPE2,
+	IPU_ADC_IFC_MODE_3WIRE_SERIAL,
+	IPU_ADC_IFC_MODE_4WIRE_SERIAL,
+	IPU_ADC_IFC_MODE_5WIRE_SERIAL_CLK,
+	IPU_ADC_IFC_MODE_5WIRE_SERIAL_CS,
+};
+
+enum {
+	IPU_ADC_IFC_WIDTH_8,
+	IPU_ADC_IFC_WIDTH_16,
+};
+
+/*!
+ * Enumeration of ADC display interface burst mode.
+ */
+enum {
+	IPU_ADC_BURST_WCS,
+	IPU_ADC_BURST_WBLCK,
+	IPU_ADC_BURST_NONE,
+	IPU_ADC_BURST_SERIAL,
+};
+
+/*!
+ * Enumeration of ADC display interface RW signal timing modes.
+ */
+enum {
+	IPU_ADC_SER_NO_RW,
+	IPU_ADC_SER_RW_BEFORE_RS,
+	IPU_ADC_SER_RW_AFTER_RS,
+};
+
+/*!
+ * Bitfield of ADC signal polarities and modes.
+ */
+typedef struct {
+	unsigned data_pol:1;
+	unsigned clk_pol:1;
+	unsigned cs_pol:1;
+	unsigned addr_pol:1;
+	unsigned read_pol:1;
+	unsigned write_pol:1;
+	unsigned Vsync_pol:1;
+	unsigned burst_pol:1;
+	unsigned burst_mode:2;
+	unsigned ifc_mode:3;
+	unsigned ifc_width:5;
+	unsigned ser_preamble_len:4;
+	unsigned ser_preamble:8;
+	unsigned ser_rw_mode:2;
+} ipu_adc_sig_cfg_t;
+
+/*!
+ * Enumeration of ADC template commands.
+ */
+enum {
+	RD_DATA,
+	RD_ACK,
+	RD_WAIT,
+	WR_XADDR,
+	WR_YADDR,
+	WR_ADDR,
+	WR_CMND,
+	WR_DATA,
+};
+
+/*!
+ * Enumeration of ADC template command flow control.
+ */
+enum {
+	SINGLE_STEP,
+	PAUSE,
+	STOP,
+};
+
+/*Define template constants*/
+#define     ATM_ADDR_RANGE      0x20	/*offset address of DISP */
+#define     TEMPLATE_BUF_SIZE   0x20	/*size of template */
+
+/*!
+ * Define to create ADC template command entry.
+ */
+#define ipu_adc_template_gen(oc, rs, fc, dat) ( ((rs) << 29) | ((fc) << 27) | \
+                                                ((oc) << 24) | (dat) )
+
+typedef struct {
+	u32 reg;
+	u32 value;
+} ipu_lpmc_reg_t;
+
+#define IPU_LPMC_REG_READ       0x80000000L
+
+#define CSI_MCLK_VF  1
+#define CSI_MCLK_ENC 2
+#define CSI_MCLK_RAW 4
+#define CSI_MCLK_I2C 8
+
+/* Common IPU API */
+int32_t ipu_init_channel(ipu_channel_t channel, ipu_channel_params_t * params);
+void ipu_uninit_channel(ipu_channel_t channel);
+
+int32_t ipu_init_channel_buffer(ipu_channel_t channel, ipu_buffer_t type,
+				uint32_t pixel_fmt,
+				uint16_t width, uint16_t height,
+				uint32_t stride,
+				ipu_rotate_mode_t rot_mode,
+				dma_addr_t phyaddr_0, dma_addr_t phyaddr_1,
+				uint32_t u_offset, uint32_t v_offset);
+
+int32_t ipu_update_channel_buffer(ipu_channel_t channel, ipu_buffer_t type,
+				  uint32_t bufNum, dma_addr_t phyaddr);
+
+int32_t ipu_select_buffer(ipu_channel_t channel,
+			  ipu_buffer_t type, uint32_t bufNum);
+
+int32_t ipu_link_channels(ipu_channel_t src_ch, ipu_channel_t dest_ch);
+int32_t ipu_unlink_channels(ipu_channel_t src_ch, ipu_channel_t dest_ch);
+
+int32_t ipu_enable_channel(ipu_channel_t channel);
+int32_t ipu_disable_channel(ipu_channel_t channel, bool wait_for_stop);
+
+void ipu_enable_irq(uint32_t irq);
+void ipu_disable_irq(uint32_t irq);
+void ipu_clear_irq(uint32_t irq);
+int ipu_request_irq(uint32_t irq,
+		    irqreturn_t(*handler) (int, void *),
+		    uint32_t irq_flags, const char *devname, void *dev_id);
+void ipu_free_irq(uint32_t irq, void *dev_id);
+bool ipu_get_irq_status(uint32_t irq);
+
+/* SDC API */
+int32_t ipu_sdc_init_panel(ipu_panel_t panel,
+			   uint32_t pixel_clk,
+			   uint16_t width, uint16_t height,
+			   uint32_t pixel_fmt,
+			   uint16_t hStartWidth, uint16_t hSyncWidth,
+			   uint16_t hEndWidth, uint16_t vStartWidth,
+			   uint16_t vSyncWidth, uint16_t vEndWidth,
+			   ipu_di_signal_cfg_t sig);
+int32_t ipu_sdc_set_window_pos(ipu_channel_t channel, int16_t x_pos,
+			       int16_t y_pos);
+int32_t ipu_sdc_set_global_alpha(bool enable, uint8_t alpha);
+int32_t ipu_sdc_set_color_key(ipu_channel_t channel, bool enable,
+			      uint32_t colorKey);
+int32_t ipu_sdc_set_brightness(uint8_t value);
+
+/* ADC API */
+int32_t ipu_adc_write_template(display_port_t disp, uint32_t * pCmd,
+			       bool write);
+
+int32_t ipu_adc_set_update_mode(ipu_channel_t channel,
+				ipu_adc_update_mode_t mode,
+				uint32_t refresh_rate, unsigned long addr,
+				uint32_t * size);
+
+int32_t ipu_adc_get_snooping_status(uint32_t * statl, uint32_t * stath);
+
+int32_t ipu_adc_write_cmd(display_port_t disp, cmddata_t type,
+			  uint32_t cmd, const uint32_t * params,
+			  uint16_t numParams);
+
+int32_t ipu_adc_init_panel(display_port_t disp,
+			   uint16_t width, uint16_t height,
+			   uint32_t pixel_fmt,
+			   uint32_t stride,
+			   ipu_adc_sig_cfg_t sig,
+			   display_addressing_t addr,
+			   uint32_t vsync_width, vsync_t mode);
+
+int32_t ipu_adc_init_ifc_timing(display_port_t disp, bool read,
+				uint32_t cycle_time,
+				uint32_t up_time,
+				uint32_t down_time,
+				uint32_t read_latch_time, uint32_t pixel_clk);
+
+/* CMOS Sensor Interface API */
+int32_t ipu_csi_init_interface(uint16_t width, uint16_t height,
+			       uint32_t pixel_fmt, ipu_csi_signal_cfg_t sig);
+
+int32_t ipu_csi_enable_mclk(int src, bool flag, bool wait);
+
+int ipu_csi_read_mclk_flag(void);
+
+void ipu_csi_flash_strobe(bool flag);
+
+void ipu_csi_get_window_size(uint32_t * width, uint32_t * height);
+
+void ipu_csi_set_window_size(uint32_t width, uint32_t height);
+
+void ipu_csi_set_window_pos(uint32_t left, uint32_t top);
+
+/* Post Filter functions */
+int32_t ipu_pf_set_pause_row(uint32_t pause_row);
+
+/* LPMC module functions */
+int ipu_lpmc_init(u32 dfm_freq,
+		  ipu_lpmc_reg_t * save_list,
+		  u32 save_count, ipu_lpmc_reg_t * lpm_list, u32 lpm_count);
+void ipu_lpmc_uninit(void);
+
+uint32_t bytes_per_pixel(uint32_t fmt);
+
+#endif
Index: linux-2.6.18/include/asm-arm/arch-mxc/mxc_v4l2.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/asm-arm/arch-mxc/mxc_v4l2.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+/*!
+ * @file arch-mxc/mxc_v4l2.h
+ *
+ * @brief mxc V4L2 private structures
+ *
+ * @ingroup MXC_V4L2_CAPTURE
+ */
+
+#ifndef __ASM_ARCH_MXC_V4L2_H__
+#define __ASM_ARCH_MXC_V4L2_H__
+
+#define V4L2_CID_MXC_ROT		(V4L2_CID_PRIVATE_BASE + 0)
+#define V4L2_CID_MXC_FLASH		(V4L2_CID_PRIVATE_BASE + 1)
+#define V4L2_CID_MXC_FLICKER		(V4L2_CID_PRIVATE_BASE + 2)
+#define V4L2_CID_MXC_TEAR_PROTECT	(V4L2_CID_PRIVATE_BASE + 3)
+
+#define V4L2_MXC_ROTATE_NONE			0
+#define V4L2_MXC_ROTATE_VERT_FLIP		1
+#define V4L2_MXC_ROTATE_HORIZ_FLIP		2
+#define V4L2_MXC_ROTATE_180			3
+#define V4L2_MXC_ROTATE_90_RIGHT		4
+#define V4L2_MXC_ROTATE_90_RIGHT_VFLIP		5
+#define V4L2_MXC_ROTATE_90_RIGHT_HFLIP		6
+#define V4L2_MXC_ROTATE_90_LEFT			7
+
+struct v4l2_mxc_offset {
+	uint32_t u_offset;
+	uint32_t v_offset;
+};
+
+#endif
Index: linux-2.6.18/mvl_patches/pro50-0124.c
===================================================================
--- /dev/null
+++ linux-2.6.18/mvl_patches/pro50-0124.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(124);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

