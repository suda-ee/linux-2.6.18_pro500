#! /usr/bin/env bash
# Patch: -common_arm_freescale_mx27ads_fb
# Date: Wed Aug 29 07:26:26 2007

PATCHNUM=113
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Index: linux-2.6.18/arch/arm/mach-mx2/mx27ads.c
===================================================================
--- linux-2.6.18.orig/arch/arm/mach-mx2/mx27ads.c
+++ linux-2.6.18/arch/arm/mach-mx2/mx27ads.c
@@ -35,6 +35,35 @@
  * @ingroup System
  */
 
+static void mxc_nop_release(struct device *dev)
+{
+        /* Nothing */
+}
+
+#if defined(CONFIG_FB_MXC_SYNC_PANEL) || defined(CONFIG_FB_MXC_SYNC_PANEL_MODULE)
+static const char fb_default_mode[] = "Sharp-QVGA";
+
+/* mxc lcd driver */
+static struct platform_device mxc_fb_device = {
+        .name = "mxc_sdc_fb",
+        .id = 0,
+        .dev = {
+                .release = mxc_nop_release,
+                .platform_data = &fb_default_mode,
+                .coherent_dma_mask = 0xFFFFFFFF,
+                },
+};
+
+static void mxc_init_fb(void)
+{
+        (void)platform_device_register(&mxc_fb_device);
+}
+#else
+static inline void mxc_init_fb(void)
+{
+}
+#endif
+
 static const int pbc_card_bit[4][3] = {
 	/* BSTAT            IMR enable       IMR removal */
 	{PBC_BSTAT_SD2_DET, PBC_INTR_SD2_EN, PBC_INTR_SD2_R_EN},
@@ -337,6 +366,7 @@ static void __init mx27ads_board_init(vo
 	mxc_gpio_init();
 	mxc_expio_init();
 	mxc_init_extuart();
+	mxc_init_fb();
 }
 
 /*
Index: linux-2.6.18/drivers/video/Kconfig
===================================================================
--- linux-2.6.18.orig/drivers/video/Kconfig
+++ linux-2.6.18/drivers/video/Kconfig
@@ -257,6 +257,10 @@ config FB_CLPS711X
 	  Say Y to enable the Framebuffer driver for the CLPS7111 and
 	  EP7212 processors.
 
+if ARCH_MXC
+source "drivers/video/mxc/Kconfig"
+endif
+
 config FB_SA1100
 	bool "SA-1100 LCD support"
 	depends on (FB = y) && ARM && ARCH_SA1100
Index: linux-2.6.18/drivers/video/Makefile
===================================================================
--- linux-2.6.18.orig/drivers/video/Makefile
+++ linux-2.6.18/drivers/video/Makefile
@@ -98,6 +98,7 @@ obj-$(CONFIG_FB_IMX)              += imx
 obj-$(CONFIG_FB_S3C2410)	  += s3c2410fb.o
 obj-$(CONFIG_FB_PNX4008_DUM)	  += pnx4008/
 obj-$(CONFIG_FB_PNX4008_DUM_RGB)  += pnx4008/
+obj-$(CONFIG_FB_MXC)              += mxc/
 
 # Platform or fallback drivers go here
 obj-$(CONFIG_FB_VESA)             += vesafb.o
Index: linux-2.6.18/drivers/video/mxc/Kconfig
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/video/mxc/Kconfig
@@ -0,0 +1,63 @@
+config FB_MXC
+	tristate "MXC Framebuffer support"
+	depends on FB && (MXC_IPU || ARCH_MX2)
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	default y
+	help
+	  This is a framebuffer device for the MXC LCD Controller.
+	  See <http://www.linux-fbdev.org/> for information on framebuffer
+	  devices.
+
+	  If you plan to use the LCD display with your MXC system, say
+	  Y here.
+
+config FB_MXC_SYNC_PANEL
+	depends on FB_MXC
+	tristate "Synchronous Panel Framebuffer"
+	default y
+
+config FB_MXC_TVOUT
+	tristate "TV Out Encoder"
+	depends on FB_MXC_SYNC_PANEL
+	default n
+
+config FB_MXC_OVERLAY
+	bool "Framebuffer Overlay Plane"
+	depends on FB_MXC_SYNC_PANEL
+	default n
+
+config FB_MXC_ASYNC_PANEL
+	depends on FB_MXC
+	bool "Asynchronous Panels"
+	default n
+
+menu "Asynchronous Panel Type"
+	depends on FB_MXC_ASYNC_PANEL && FB_MXC
+
+config FB_MXC_EPSON_PANEL
+    depends on FB_MXC_ASYNC_PANEL
+	default n
+	bool "Epson 176x220 Panel"
+
+
+
+endmenu
+
+choice
+	prompt "Async Panel Interface Type"
+	depends on FB_MXC_ASYNC_PANEL && FB_MXC
+	default FB_MXC_ASYNC_PANEL_IFC_16_BIT
+
+config FB_MXC_ASYNC_PANEL_IFC_8_BIT
+	bool "8-bit Parallel Bus Interface"
+
+config FB_MXC_ASYNC_PANEL_IFC_16_BIT
+	bool "16-bit Parallel Bus Interface"
+
+config FB_MXC_ASYNC_PANEL_IFC_SERIAL
+	bool "Serial Bus Interface"
+
+endchoice
+
Index: linux-2.6.18/drivers/video/mxc/Makefile
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/video/mxc/Makefile
@@ -0,0 +1,5 @@
+ifeq ($(CONFIG_ARCH_MX2),y)
+	obj-$(CONFIG_FB_MXC_TVOUT)              += fs453.o
+	obj-$(CONFIG_FB_MXC_SYNC_PANEL)         += mx2fb.o mxcfb_modedb.o
+	obj-$(CONFIG_FB_MXC_EPSON_PANEL)        += mx2fb_epson.o
+endif
Index: linux-2.6.18/drivers/video/mxc/fs453.c
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/video/mxc/fs453.c
@@ -0,0 +1,506 @@
+/*
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup FS453 Focus FS453 TV Encoder Driver
+ */
+/*!
+ * @file fs453.c
+ * @brief Driver for FS453/4 TV encoder
+ *
+ * @ingroup FS453
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/ioctl.h>
+#include <linux/video_encoder.h>
+
+#include "fs453.h"
+
+/*
+ * FIXME: VGA mode is not defined by video_encoder.h
+ * while FS453 supports VGA output.
+ */
+#ifndef VIDEO_ENCODER_VGA
+#define VIDEO_ENCODER_VGA	32
+#endif
+
+/*!
+ * This stucture contains the status of FS453.
+ */
+struct fs453_data {
+	int norm;
+	int input;
+	int output;
+	int enable;
+};
+
+/*!
+ * This structure contains all the register values needed to program the
+ * TV encoder chip.  This structure is instantiated and initialized for
+ * each supported output standard.
+ */
+struct fs453_presets {
+	u32 mode;		/*! Video mode */
+	u16 qpr;		/*! Quick Program Register */
+	u16 pwr_mgmt;		/*! Power Management */
+	u16 iho;		/*! Input Horizontal Offset */
+	u16 ivo;		/*! Input Vertical Offset */
+	u16 ihw;		/*! Input Horizontal Width */
+	u16 vsc;		/*! Vertical Scaling Coefficient */
+	u16 hsc;		/*! Horizontal Scaling Coefficient */
+	u16 bypass;		/*! Bypass */
+	u16 misc;		/*! Miscellaneous Bits Register */
+	u8 misc46;		/*! Miscellaneous Bits Register 46 */
+	u8 misc47;		/*! Miscellaneous Bits Register 47 */
+	u32 ncon;		/*! Numerator of NCO Word */
+	u32 ncod;		/*! Denominator of NCO Word */
+	u16 pllm;		/*! PLL M and Pump Control */
+	u16 plln;		/*! PLL N */
+	u16 pllpd;		/*! PLL Post-Divider */
+	u16 vid_cntl0;		/*! Video Control 0 */
+	u16 dac_cntl;		/*! DAC Control */
+	u16 fifo_lat;		/*! FIFO Latency */
+};
+
+static struct fs453_presets fs453_vga_presets = {
+	.mode = VIDEO_ENCODER_VGA,
+	.qpr = 0x9cb0,
+	.pwr_mgmt = 0x0408,
+	.misc = 0x0103,
+	.ncon = 0x00000000,
+	.ncod = 0x00000000,
+	.misc46 = 0xa9,
+	.misc47 = 0x00,
+	.pllm = 0x317f,
+	.plln = 0x008e,
+	.pllpd = 0x0202,
+	.vid_cntl0 = 0x4006,
+	.dac_cntl = 0x00e4,
+	.fifo_lat = 0x0082,
+};
+
+static struct fs453_presets fs453_ntsc_presets = {
+	.mode = VIDEO_ENCODER_NTSC,
+	.qpr = 0x9c48,
+	.pwr_mgmt = 0x0200,
+	.misc = 0x0103,
+	.ncon = 0x00000001,
+	.ncod = 0x00000001,
+	.misc46 = 0x01,
+	.misc47 = 0x00,
+	.pllm = 0x4000 | (296 - 17),
+	.plln = 30 - 1,
+	.pllpd = ((10 - 1) << 8) | (10 - 1),
+	.iho = 0,
+	.ivo = 40,
+	.ihw = 768,
+	.vsc = 789,
+	.hsc = 0x0000,
+	.bypass = 0x000a,
+	.vid_cntl0 = 0x0340,
+	.dac_cntl = 0x00e4,
+	.fifo_lat = 0x0082,
+};
+
+static struct fs453_presets fs453_pal_presets = {
+	.mode = VIDEO_ENCODER_PAL,
+	.qpr = 0x9c41,
+	.pwr_mgmt = 0x0200,
+	.misc = 0x0103,
+	.ncon = 0x00000001,
+	.ncod = 0x00000001,
+	.misc46 = 0x01,
+	.misc47 = 0x00,
+	.pllm = 0x4000 | (296 - 17),
+	.plln = 30 - 1,
+	.pllpd = ((10 - 1) << 8) | (10 - 1),
+	.iho = 0,
+	.ivo = 19,
+	.ihw = 768,
+	.vsc = 8200,
+	.hsc = 0x0000,
+	.bypass = 0x000a,
+	.vid_cntl0 = 0x0340,
+	.dac_cntl = 0x00e4,
+	.fifo_lat = 0x0082,
+};
+
+static int fs453_preset(struct i2c_client *client,
+			struct fs453_presets *presets);
+static int fs453_enable(struct i2c_client *client, int enable);
+
+static struct i2c_driver fs453_driver;
+/*
+ * FIXME: fs453_client will represent the first FS453 device found by
+ * the I2C subsystem, which means fs453_ioctl() always works on the
+ * first FS453 device.
+ */
+static struct i2c_client *fs453_client = 0;
+
+static int fs453_command(struct i2c_client *client, unsigned int cmd, void *arg)
+{
+	int val;
+	char *smode = 0;
+	struct video_encoder_capability *cap;
+	struct fs453_data *data = i2c_get_clientdata(client);
+	int ret = 0;
+
+	switch (cmd) {
+	case ENCODER_GET_CAPABILITIES:
+		cap = arg;
+		cap->flags =
+		    VIDEO_ENCODER_PAL | VIDEO_ENCODER_NTSC | VIDEO_ENCODER_VGA;
+		cap->inputs = 1;
+		cap->outputs = 1;
+		break;
+	case ENCODER_SET_NORM:
+		val = *(int *)arg;
+		switch (val) {
+		case VIDEO_ENCODER_PAL:
+			ret = fs453_preset(client, &fs453_pal_presets);
+			smode = "PAL";
+			break;
+		case VIDEO_ENCODER_NTSC:
+			ret = fs453_preset(client, &fs453_ntsc_presets);
+			smode = "NTSC";
+			break;
+		case VIDEO_ENCODER_VGA:
+			ret = fs453_preset(client, &fs453_vga_presets);
+			smode = "VGA";
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+		}
+		if (!ret) {
+			data->norm = val;
+			data->enable = 1;
+			pr_debug("FS453: switched to %s\n", smode);
+		}
+		break;
+	case ENCODER_SET_INPUT:
+		val = *(int *)arg;
+		/* We have only one input */
+		if (val != 0)
+			return -EINVAL;
+		data->input = val;
+		break;
+	case ENCODER_SET_OUTPUT:
+		val = *(int *)arg;
+		/* We have only one output */
+		if (val != 0)
+			return -EINVAL;
+		data->output = val;
+		break;
+	case ENCODER_ENABLE_OUTPUT:
+		val = *(int *)arg;
+		if ((ret = fs453_enable(client, val)) == 0)
+			data->enable = val;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+static int i2c_fs453_detect_client(struct i2c_adapter *adapter, int address,
+				   int kind)
+{
+	int chip_id;
+	struct i2c_client *client;
+	struct fs453_data *data;
+	const char *client_name = "FS453 I2C dev";
+
+	pr_debug("FS453: i2c-bus: %s; address: 0x%x\n", adapter->name, address);
+
+	/* Let's see whether this adapter can support what we need */
+	if (!i2c_check_functionality(adapter,
+				     I2C_FUNC_SMBUS_WORD_DATA |
+				     I2C_FUNC_SMBUS_BYTE_DATA)) {
+		pr_debug("FS453: SMBUS word/byte operations not permited.\n");
+		return 0;
+	}
+
+	client =
+	    kmalloc(sizeof(struct i2c_client) + sizeof(struct fs453_data),
+		    GFP_KERNEL);
+	if (!client)
+		return -ENOMEM;
+
+	data = (struct fs453_data *)(client + 1);
+	client->addr = address;
+	client->adapter = adapter;
+	client->driver = &fs453_driver;
+	client->flags = 0;
+
+	/*
+	 * The generic detection, that is skipped if any force
+	 * parameter was used.
+	 */
+	if (kind < 0) {
+		chip_id = i2c_smbus_read_word_data(client, FS453_ID);
+		if (chip_id != FS453_CHIP_ID) {
+			pr_info("FS453: TV encoder not present\n");
+			kfree(client);
+			return 0;
+		} else
+			pr_info("FS453: TV encoder present, ID=0x%04X\n",
+				chip_id);
+	}
+	strcpy(client->name, client_name);
+
+	/* FS453 default status */
+	data->input = 0;
+	data->output = 0;
+	data->norm = 0;
+	data->enable = 0;
+	i2c_set_clientdata(client, data);
+
+	if (i2c_attach_client(client)) {
+		pr_debug("FS453: i2c_attach_client() failed.\n");
+		kfree(client);
+	} else if (fs453_client == 0)
+		fs453_client = client;
+
+	return 0;
+}
+
+static unsigned short normal_i2c[] = { FS453_I2C_ADDR, I2C_CLIENT_END };
+
+/* Magic definition of all other variables and things */
+I2C_CLIENT_INSMOD;
+
+static int i2c_fs453_attach(struct i2c_adapter *adap)
+{
+	return i2c_probe(adap, &addr_data, &i2c_fs453_detect_client);
+}
+
+static int i2c_fs453_detach(struct i2c_client *client)
+{
+	int err;
+
+	if ((err = i2c_detach_client(client))) {
+		pr_debug("FS453: i2c_detach_client() failed\n");
+		return err;
+	}
+
+	if (fs453_client == client)
+		fs453_client = 0;
+
+	kfree(client);
+	return 0;
+}
+
+static struct i2c_driver fs453_driver = {
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = "FS453 driver",
+		   },
+	.attach_adapter = &i2c_fs453_attach,
+	.detach_client = &i2c_fs453_detach,
+	.command = fs453_command,
+};
+
+/*!
+ * @brief Function to read TV encoder registers on the i2c bus
+ * @param     client	I2C client structure
+ * @param     reg	The register number
+ * @param     value	Pointer to buffer to receive the read data
+ * @param     len	Number of 16-bit register words to read
+ * @return    0 on success, others on failure
+ */
+static int fs453_read(struct i2c_client *client, u8 reg, u32 * value, u32 len)
+{
+	if (len == 1)
+		*value = i2c_smbus_read_byte_data(client, reg);
+	else if (len == 2)
+		*value = i2c_smbus_read_word_data(client, reg);
+	else if (len == 4) {
+		*(u16 *) value = i2c_smbus_read_word_data(client, reg);
+		*((u16 *) value + 1) =
+		    i2c_smbus_read_word_data(client, reg + 2);
+	} else
+		return -EINVAL;
+
+	return 0;
+}
+
+/*!
+ * @brief Function to write a TV encoder register on the i2c bus
+ * @param     client	I2C client structure
+ * @param     reg	The register number
+ * @param     value	The value to write
+ * @param     len	Number of words to write (must be 1)
+ * @return    0 on success, others on failure
+ */
+static int fs453_write(struct i2c_client *client, u8 reg, u32 value, u32 len)
+{
+	if (len == 1)
+		return i2c_smbus_write_byte_data(client, reg, (u8) value);
+	else if (len == 2)
+		return i2c_smbus_write_word_data(client, reg, (u16) value);
+	else if (len == 4)
+		return i2c_smbus_write_block_data(client, reg, len,
+						  (u8 *) & value);
+	else
+		return -EINVAL;
+}
+
+/*!
+ * @brief Function to initialize the TV encoder
+ * @param     client	I2C client structure
+ * @param     presets	FS453 pre-defined register values
+ * @return    0 on success; ENODEV if the encoder wasn't found
+ */
+static int fs453_preset(struct i2c_client *client,
+			struct fs453_presets *presets)
+{
+	u32 data;
+
+	if (!client)
+		return -ENODEV;
+
+	/* set the clock level */
+	fs453_write(client, FS453_CR, CR_GCC_CK_LVL, 2);
+
+	/* soft reset the encoder */
+	fs453_read(client, FS453_CR, &data, 2);
+	fs453_write(client, FS453_CR, data | CR_SRESET, 2);
+	fs453_write(client, FS453_CR, data & ~CR_SRESET, 2);
+
+	fs453_write(client, FS453_BYPASS, presets->bypass, 2);
+
+	/* Write the QPR (Quick Programming Register). */
+	fs453_write(client, FS453_QPR, presets->qpr, 2);
+
+	if (presets->mode != VIDEO_ENCODER_VGA) {
+		/* set up the NCO and PLL */
+		fs453_write(client, FS453_NCON, presets->ncon, 4);
+		fs453_write(client, FS453_NCOD, presets->ncod, 4);
+		fs453_write(client, FS453_PLL_M_PUMP, presets->pllm, 2);
+		fs453_write(client, FS453_PLL_N, presets->plln, 2);
+		fs453_write(client, FS453_PLL_PDIV, presets->pllpd, 2);
+
+		/* latch the NCO and PLL settings */
+		fs453_read(client, FS453_CR, &data, 2);
+		fs453_write(client, FS453_CR, data | CR_NCO_EN, 2);
+		fs453_write(client, FS453_CR, data & ~CR_NCO_EN, 2);
+	}
+
+	/* customize */
+	fs453_write(client, FS453_PWR_MGNT, presets->pwr_mgmt, 2);
+
+	fs453_write(client, FS453_IHO, presets->iho, 2);
+	fs453_write(client, FS453_IVO, presets->ivo, 2);
+	fs453_write(client, FS453_IHW, presets->ihw, 2);
+	fs453_write(client, FS453_VSC, presets->vsc, 2);
+	fs453_write(client, FS453_HSC, presets->hsc, 2);
+
+	fs453_write(client, FS453_MISC, presets->misc, 2);
+
+	fs453_write(client, FS453_VID_CNTL0, presets->vid_cntl0, 2);
+	fs453_write(client, FS453_MISC_46, presets->misc46, 1);
+	fs453_write(client, FS453_MISC_47, presets->misc47, 1);
+
+	fs453_write(client, FS453_DAC_CNTL, presets->dac_cntl, 2);
+	fs453_write(client, FS453_FIFO_LAT, presets->fifo_lat, 2);
+
+	return 0;
+}
+
+/*!
+ * @brief Function to enable/disable the TV encoder
+ * @param     client	I2C client structure
+ * @param     enable	0 to disable, others to enable
+ * @return    0 on success; ENODEV if the encoder wasn't found
+ */
+static int fs453_enable(struct i2c_client *client, int enable)
+{
+	struct fs453_data *data;
+
+	if (!client)
+		return -ENODEV;
+
+	data = i2c_get_clientdata(client);
+
+	if (enable)
+		return fs453_command(client, ENCODER_SET_NORM, &data->norm);
+	else
+		return fs453_write(client, FS453_PWR_MGNT, 0x3BFF, 2);
+}
+
+#ifdef CONFIG_ARCH_MX27
+extern void gpio_fs453_reset_low(void);
+extern void gpio_fs453_reset_high(void);
+#endif
+
+/*!
+ * @brief FS453 control routine
+ * @param	cmd	Control command
+ * @param	arg	Control argument
+ * @return	0 on success, others on failure
+ */
+int fs453_ioctl(unsigned int cmd, void *arg)
+{
+	/* check for deferred I2C registration */
+	if (!fs453_client) {
+		int err;
+#ifdef CONFIG_ARCH_MX27
+		/* reset the FS453 via the CLS/GPIOA25 line */
+		gpio_fs453_reset_low();
+		gpio_fs453_reset_high();
+#endif
+
+		if ((err = i2c_add_driver(&fs453_driver))) {
+			pr_info("FS453: driver registration failed\n");
+		}
+	}
+
+	if (!fs453_client)
+		return -ENODEV;
+
+	return fs453_command(fs453_client, cmd, arg);
+}
+
+/*!
+ * @brief Probe for the TV enocder and initialize the driver
+ * @return    0 on success, others on failure
+ */
+static int __init fs453_init(void)
+{
+	pr_info("FS453/4 driver, (c) 2005 Freescale Semiconductor, Inc.\n");
+
+	return 0;
+}
+
+/*!
+ * @brief Module exit routine
+ */
+static void __exit fs453_exit(void)
+{
+	i2c_del_driver(&fs453_driver);
+}
+
+module_init(fs453_init);
+module_exit(fs453_exit);
+
+EXPORT_SYMBOL(fs453_ioctl);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("FS453/4 TV encoder driver");
+MODULE_LICENSE("GPL");
Index: linux-2.6.18/drivers/video/mxc/fs453.h
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/video/mxc/fs453.h
@@ -0,0 +1,134 @@
+/*
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+ /*!
+  * @file fs453.h
+  * @brief Driver for FS453/4 TV encoder
+  *
+  * @ingroup FS453
+  */
+
+#ifndef __FS453_H__
+#define __FS453_H__
+
+/* I2C address of the FS453 chip */
+
+#define I2C1_BUS	0
+#define FS453_I2C_ADDR	0x6A
+
+/*!
+ *
+ * FS453 register file
+ *
+ */
+#define FS453_IHO		0x00	/*! Input Horizontal Offset */
+#define FS453_IVO		0x02	/*! Input Vertical Offset */
+#define FS453_IHW		0x04	/*! Input Horizontal Width */
+#define FS453_VSC		0x06	/*! Vertical Scaling Coefficient */
+#define FS453_HSC		0x08	/*! Horizontal Scaling Coefficient */
+#define FS453_BYPASS		0x0A	/*! BYPASS */
+#define FS453_CR		0x0C	/*! Command Register */
+#define FS453_MISC		0x0E	/*! Miscellaneous Bits Register */
+#define FS453_NCON		0x10	/*! Numerator of NCO Word */
+#define FS453_NCOD		0x14	/*! Denominator of NCO Word */
+#define FS453_PLL_M_PUMP	0x18	/*! PLL M and Pump Control */
+#define FS453_PLL_N		0x1A	/*! PLL N */
+#define FS453_PLL_PDIV		0x1C	/*! PLL Post-Divider */
+#define FS453_SHP		0x24	/*! Sharpness Filter */
+#define FS453_FLK		0x26	/*! Filcker Filter Coefficient */
+#define FS453_GPIO		0x28	/*! General Purpose I/O, Output Enab */
+#define FS453_ID		0x32	/*! Part Identification Number */
+#define FS453_STATUS		0x34	/*! Status Port */
+#define FS453_FIFO_SP		0x36	/*! FIFO Status Port Fill/Underrun */
+#define FS453_FIFO_LAT		0x38	/*! FIFO Latency */
+#define FS453_CHR_FREQ		0x40	/*! Chroma Subcarrier Frequency */
+#define FS453_CHR_PHASE		0x44	/*! Chroma Phase */
+#define FS453_MISC_45		0x45	/*! Miscellaneous Bits Register 45 */
+#define FS453_MISC_46		0x46	/*! Miscellaneous Bits Register 46 */
+#define FS453_MISC_47		0x47	/*! Miscellaneous Bits Register 47 */
+#define FS453_HSYNC_WID		0x48	/*! HSync Width */
+#define FS453_BURST_WID		0x49	/*! Burst Width */
+#define FS453_BPORCH		0x4A	/*! Back Porch Width */
+#define FS453_CB_BURST		0x4B	/*! Cb Burst Amplitude */
+#define FS453_CR_BURST		0x4C	/*! Cr Burst Amplitude */
+#define FS453_MISC_4D		0x4D	/*! Miscellaneous Bits Register 4D */
+#define FS453_BLACK_LVL		0x4E	/*! Black Level */
+#define FS453_BLANK_LVL		0x50	/*! Blank Level */
+#define FS453_NUM_LINES		0x57	/*! Number of Lines */
+#define FS453_WHITE_LVL		0x5E	/*! White Level */
+#define FS453_CB_GAIN		0x60	/*! Cb Color Saturation */
+#define FS453_CR_GAIN		0x62	/*! Cr Color Saturation */
+#define FS453_TINT		0x65	/*! Tint */
+#define FS453_BR_WAY		0x69	/*! Width of Breezeway */
+#define FS453_FR_PORCH		0x6C	/*! Front Porch */
+#define FS453_NUM_PIXELS	0x71	/*! Total num. of luma/chroma Pixels */
+#define FS453_1ST_LINE		0x73	/*! First Video Line */
+#define FS453_MISC_74		0x74	/*! Miscellaneous Bits Register 74 */
+#define FS453_SYNC_LVL		0x75	/*! Sync Level */
+#define FS453_VBI_BL_LVL	0x7C	/*! VBI Blank Level */
+#define FS453_SOFT_RST		0x7E	/*! Encoder Soft Reset */
+#define FS453_ENC_VER		0x7F	/*! Encoder Version */
+#define FS453_WSS_CONFIG	0x80	/*! WSS Configuration Register */
+#define FS453_WSS_CLK		0x81	/*! WSS Clock */
+#define FS453_WSS_DATAF1	0x83	/*! WSS Data Field 1 */
+#define FS453_WSS_DATAF0	0x86	/*! WSS Data Field 0 */
+#define FS453_WSS_LNF1		0x89	/*! WSS Line Number Field 1 */
+#define FS453_WSS_LNF0		0x8A	/*! WSS Line Number Field 0 */
+#define FS453_WSS_LVL		0x8B	/*! WSS Level */
+#define FS453_MISC_8D		0x8D	/*! Miscellaneous Bits Register 8D */
+#define FS453_VID_CNTL0		0x92	/*! Video Control 0 */
+#define FS453_HD_FP_SYNC	0x94	/*! Horiz. Front Porch & HSync Width */
+#define FS453_HD_YOFF_BP	0x96	/*! HDTV Lum. Offset & Back Porch */
+#define FS453_SYNC_DL		0x98	/*! Sync Delay Value */
+#define FS453_LD_DET		0x9C	/*! DAC Load Detect */
+#define FS453_DAC_CNTL		0x9E	/*! DAC Control */
+#define FS453_PWR_MGNT		0xA0	/*! Power Management */
+#define FS453_RED_MTX		0xA2	/*! RGB to YCrCb Matrix Red Coeff. */
+#define FS453_GRN_MTX		0xA4	/*! RGB to YCrCb Matrix Green Coeff. */
+#define FS453_BLU_MTX		0xA6	/*! RGB to YCrCb Matrix Blue Coeff. */
+#define FS453_RED_SCL		0xA8	/*! RGB to YCrCb Scaling Red Coeff. */
+#define FS453_GRN_SCL		0xAA	/*! RGB to YCrCb Scaling Green Coeff. */
+#define FS453_BLU_SCL		0xAC	/*! RGB to YCrCb Scaling Blue Coeff. */
+#define FS453_CC_FIELD_1	0xAE	/*! Closed Caption Field 1 Data */
+#define FS453_CC_FIELD_2	0xB0	/*! Closed Caption Field 2 Data */
+#define FS453_CC_CONTROL	0xB2	/*! Closed Caption Control */
+#define FS453_CC_BLANK_VALUE	0xB4	/*! Closed Caption Blanking Value */
+#define FS453_CC_BLANK_SAMPLE	0xB6	/*! Closed Caption Blanking Sample */
+#define FS453_HACT_ST		0xB8	/*! HDTV Horizontal Active Start */
+#define FS453_HACT_WD		0xBA	/*! HDTV Horizontal Active Width */
+#define FS453_VACT_ST		0xBC	/*! HDTV Veritical Active Width */
+#define FS453_VACT_HT		0xBE	/*! HDTV Veritical Active Height */
+#define FS453_PR_PB_SCALING	0xC0	/*! Pr and Pb Relative Scaling */
+#define FS453_LUMA_BANDWIDTH	0xC2	/*! Luminance Frequency Response */
+#define FS453_QPR		0xC4	/*! Quick Program Register */
+
+/*! Command register bits */
+
+#define CR_GCC_CK_LVL		0x2000	/*! Graphics Controller switching lev */
+#define CR_P656_LVL		0x1000	/*! Pixel Port Output switching level */
+#define CR_P656_IN		0x0800	/*! Pixel Port In */
+#define CR_P656_OUT		0x0400	/*! Pixel Port Out */
+#define CR_CBAR_480P		0x0200	/*! 480P Color Bars */
+#define CR_PAL_NTSCIN		0x0100	/*! PAL or NTSC input */
+#define CR_SYNC_MS		0x0080	/*! Sync Master or Slave */
+#define CR_FIFO_CLR		0x0040	/*! FIFO Clear */
+#define CR_CACQ_CLR		0x0020	/*! CACQ Clear */
+#define CR_CDEC_BP		0x0010	/*! Chroma Decimator Bypass */
+#define CR_NCO_EN		0x0002	/*! Enable NCO Latch */
+#define CR_SRESET		0x0001	/*! Soft Reset */
+
+/*! Chip ID register bits */
+
+#define FS453_CHIP_ID		0xFE05	/*! Chip ID register expected value */
+
+#endif				/* __FS453_H__ */
Index: linux-2.6.18/drivers/video/mxc/mx2fb.c
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/video/mxc/mx2fb.c
@@ -0,0 +1,1363 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup Framebuffer_MX27 Framebuffer Driver for MX27.
+ */
+
+/*!
+ * @file mx2fb.c
+ *
+ * @brief Frame buffer driver for MX27 ADS.
+ *
+ * @ingroup Framebuffer_MX27
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <asm/uaccess.h>
+#include <asm/arch/mxcfb.h>
+
+#include "mx2fb.h"
+
+#define MX2FB_TYPE_BG          0
+#define MX2FB_TYPE_GW          1
+
+extern void gpio_lcdc_active(void);
+extern void gpio_lcdc_inactive(void);
+extern void board_power_lcd(int on);
+
+static char *fb_mode = 0;
+static int fb_enabled = 0;
+static unsigned long default_bpp = 16;
+static unsigned char brightness = 255;
+static ATOMIC_NOTIFIER_HEAD(mx2fb_notifier_list);
+static struct clk *lcdc_clk;
+/*!
+ * @brief Structure containing the MX2 specific framebuffer information.
+ */
+struct mx2fb_info {
+	int type;
+	char *id;
+	int registered;
+	int blank;
+	unsigned long pseudo_palette[16];
+};
+
+/* Framebuffer APIs */
+static int mx2fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info);
+static int mx2fb_set_par(struct fb_info *info);
+static int mx2fb_setcolreg(unsigned regno, unsigned red, unsigned green,
+			   unsigned blue, unsigned transp,
+			   struct fb_info *info);
+static int mx2fb_pan_display(struct fb_var_screeninfo *var,
+			     struct fb_info *info);
+static int mx2fb_blank(int blank_mode, struct fb_info *info);
+static int mx2fb_ioctl(struct fb_info *info, unsigned int cmd,
+		       unsigned long arg);
+
+/* Driver entries */
+int __init mx2fb_init(void);
+void __exit mx2fb_exit(void);
+#ifndef MODULE
+static int __init mx2fb_setup(char *);
+#endif
+
+/* Internal functions */
+static int __init _init_fbinfo(struct fb_info *info,
+			       struct platform_device *pdev);
+static int __init _install_fb(struct fb_info *info,
+			      struct platform_device *pdev);
+static void __exit _uninstall_fb(struct fb_info *info);
+static int _map_video_memory(struct fb_info *info);
+static void _unmap_video_memory(struct fb_info *info);
+static void _set_fix(struct fb_info *info);
+static void _enable_lcdc(struct fb_info *info);
+static void _disable_lcdc(struct fb_info *info);
+static void _enable_graphic_window(struct fb_info *info);
+static void _disable_graphic_window(struct fb_info *info);
+static void _update_lcdc(struct fb_info *info);
+static void _set_brightness(unsigned char level);
+static void _request_irq(void);
+static void _free_irq(void);
+
+#ifdef CONFIG_PM
+static int mx2fb_suspend(struct platform_device *pdev, pm_message_t state);
+static int mx2fb_resume(struct platform_device *pdev);
+#else
+#define mx2fb_suspend	0
+#define mx2fb_resume	0
+#endif
+
+static int mx2fb_probe(struct platform_device *pdev);
+
+#ifdef CONFIG_FB_MXC_TVOUT
+#include <linux/video_encoder.h>
+/*
+ * FIXME: VGA mode is not defined by video_encoder.h
+ * while FS453 supports VGA output.
+ */
+#ifndef VIDEO_ENCODER_VGA
+#define VIDEO_ENCODER_VGA	32
+#endif
+
+#define MODE_PAL		"TV-PAL"
+#define MODE_NTSC		"TV-NTSC"
+#define MODE_VGA		"TV-VGA"
+
+extern int fs453_ioctl(unsigned int cmd, void *arg);
+#endif
+
+struct mx2fb_info mx2fbi_bg = {
+	.type = MX2FB_TYPE_BG,
+	.id = "DISP0 BG",
+	.registered = 0,
+};
+
+#ifdef CONFIG_FB_MXC_OVERLAY
+static struct mx2fb_info mx2fbi_gw = {
+	.type = MX2FB_TYPE_GW,
+	.id = "DISP0 FG",
+	.registered = 0,
+};
+#endif
+
+/*! Current graphic window information */
+static struct fb_gwinfo g_gwinfo = {
+	.enabled = 0,
+	.alpha_value = 255,
+	.ck_enabled = 0,
+	.ck_red = 0,
+	.ck_green = 0,
+	.ck_blue = 0,
+	.xpos = 0,
+	.ypos = 0,
+};
+
+/*!
+ * @brief Framebuffer information structures.
+ * There are up to 3 framebuffers: background, TVout, and graphic window.
+ * If graphic window is configured, it must be the last framebuffer.
+ */
+static struct fb_info mx2fb_info[] = {
+	{.par = &mx2fbi_bg},
+#ifdef CONFIG_FB_MXC_OVERLAY
+	{.par = &mx2fbi_gw},
+#endif
+};
+
+/*!
+ * @brief This structure contains pointers to the power management
+ * callback functions.
+ */
+static struct platform_driver mx2fb_driver = {
+	.driver = {
+		   .name = "mxc_sdc_fb",
+		   .owner = THIS_MODULE,
+		   .bus = &platform_bus_type,
+		   },
+	.probe = mx2fb_probe,
+	.suspend = mx2fb_suspend,
+	.resume = mx2fb_resume,
+};
+
+/*!
+ * @brief Framebuffer file operations
+ */
+static struct fb_ops mx2fb_ops = {
+	.owner = THIS_MODULE,
+	.fb_check_var = mx2fb_check_var,
+	.fb_set_par = mx2fb_set_par,
+	.fb_setcolreg = mx2fb_setcolreg,
+	.fb_blank = mx2fb_blank,
+	.fb_pan_display = mx2fb_pan_display,
+	.fb_fillrect = cfb_fillrect,
+	.fb_copyarea = cfb_copyarea,
+	.fb_imageblit = cfb_imageblit,
+	//.fb_cursor = soft_cursor,
+	.fb_ioctl = mx2fb_ioctl,
+};
+
+/*!
+ * @brief Validates a var passed in.
+ *
+ * @param var	Frame buffer variable screen structure
+ * @param info	Frame buffer structure that represents a single frame buffer
+ *
+ * @return	Negative errno on error, or zero on success.
+ *
+ * Checks to see if the hardware supports the state requested by var passed
+ * in. This function does not alter the hardware state! If the var passed in
+ * is slightly off by what the hardware can support then we alter the var
+ * PASSED in to what we can do. If the hardware doesn't support mode change
+ * a -EINVAL will be returned by the upper layers.
+ *
+ */
+static int mx2fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	unsigned long htotal, vtotal;
+
+	if (var->xres_virtual < var->xres)
+		var->xres_virtual = var->xres;
+	if (var->yres_virtual < var->yres)
+		var->yres_virtual = var->yres;
+
+	if (var->xoffset < 0)
+		var->xoffset = 0;
+
+	if (var->yoffset < 0)
+		var->yoffset = 0;
+
+	if (var->xoffset + info->var.xres > info->var.xres_virtual)
+		var->xoffset = info->var.xres_virtual - info->var.xres;
+
+	if (var->yoffset + info->var.yres > info->var.yres_virtual)
+		var->yoffset = info->var.yres_virtual - info->var.yres;
+
+	if ((var->bits_per_pixel != 32) && (var->bits_per_pixel != 24) &&
+	    (var->bits_per_pixel != 16)) {
+		var->bits_per_pixel = default_bpp;
+	}
+
+	switch (var->bits_per_pixel) {
+	case 16:
+		var->red.length = 5;
+		var->red.offset = 11;
+		var->red.msb_right = 0;
+
+		var->green.length = 6;
+		var->green.offset = 5;
+		var->green.msb_right = 0;
+
+		var->blue.length = 5;
+		var->blue.offset = 0;
+		var->blue.msb_right = 0;
+
+		var->transp.length = 0;
+		var->transp.offset = 0;
+		var->transp.msb_right = 0;
+		break;
+	case 24:
+		var->red.length = 8;
+		var->red.offset = 16;
+		var->red.msb_right = 0;
+
+		var->green.length = 8;
+		var->green.offset = 8;
+		var->green.msb_right = 0;
+
+		var->blue.length = 8;
+		var->blue.offset = 0;
+		var->blue.msb_right = 0;
+
+		var->transp.length = 0;
+		var->transp.offset = 0;
+		var->transp.msb_right = 0;
+		break;
+	case 32:
+		var->red.length = 8;
+		var->red.offset = 16;
+		var->red.msb_right = 0;
+
+		var->green.length = 8;
+		var->green.offset = 8;
+		var->green.msb_right = 0;
+
+		var->blue.length = 8;
+		var->blue.offset = 0;
+		var->blue.msb_right = 0;
+
+		var->transp.length = 8;
+		var->transp.offset = 24;
+		var->transp.msb_right = 0;
+		break;
+	}
+
+	if (var->pixclock < 1000) {
+		htotal = var->xres + var->right_margin + var->hsync_len +
+		    var->left_margin;
+		vtotal = var->yres + var->lower_margin + var->vsync_len +
+		    var->upper_margin;
+		var->pixclock = (vtotal * htotal * 6UL) / 100UL;
+		var->pixclock = KHZ2PICOS(var->pixclock);
+		dev_dbg(info->device,
+			"pixclock set for 60Hz refresh = %u ps\n",
+			var->pixclock);
+	}
+
+	var->height = -1;
+	var->width = -1;
+	var->grayscale = 0;
+
+	/* Copy nonstd field to/from sync for fbset usage */
+	var->sync |= var->nonstd;
+	var->nonstd |= var->sync;
+
+	return 0;
+}
+
+/*!
+ * @brief Alters the hardware state.
+ *
+ * @param info	Frame buffer structure that represents a single frame buffer
+ *
+ * @return Zero on success others on failure
+ *
+ * Using the fb_var_screeninfo in fb_info we set the resolution of this
+ * particular framebuffer. This function alters the fb_fix_screeninfo stored
+ * in fb_info. It doesn't not alter var in fb_info since we are using that
+ * data. This means we depend on the data in var inside fb_info to be
+ * supported by the hardware. mx2fb_check_var is always called before
+ * mx2fb_set_par to ensure this.
+ */
+static int mx2fb_set_par(struct fb_info *info)
+{
+	unsigned long len;
+	struct mx2fb_info *mx2fbi = (struct mx2fb_info *)info->par;
+
+	_set_fix(info);
+
+	len = info->var.yres_virtual * info->fix.line_length;
+	if (len > info->fix.smem_len) {
+		if (info->fix.smem_start)
+			_unmap_video_memory(info);
+
+		/* Memory allocation for framebuffer */
+		if (_map_video_memory(info)) {
+			dev_err(info->device, "Unable to allocate fb memory\n");
+			return -ENOMEM;
+		}
+	}
+
+	_update_lcdc(info);
+	if (info->fbops->fb_blank)
+		info->fbops->fb_blank(mx2fbi->blank, info);
+
+	return 0;
+}
+
+/*!
+ * @brief Sets a color register.
+ *
+ * @param regno		Which register in the CLUT we are programming
+ * @param red		The red value which can be up to 16 bits wide
+ * @param green		The green value which can be up to 16 bits wide
+ * @param blue		The blue value which can be up to 16 bits wide.
+ * @param transp	If supported the alpha value which can be up to
+ *                      16 bits wide.
+ * @param info		Frame buffer info structure
+ *
+ * @return		Negative errno on error, or zero on success.
+ *
+ * Set a single color register. The values supplied have a 16 bit magnitude
+ * which needs to be scaled in this function for the hardware. Things to take
+ * into consideration are how many color registers, if any, are supported with
+ * the current color visual. With truecolor mode no color palettes are
+ * supported. Here a psuedo palette is created which we store the value in
+ * pseudo_palette in struct fb_info. For pseudocolor mode we have a limited
+ * color palette.
+ */
+static int mx2fb_setcolreg(unsigned regno, unsigned red, unsigned green,
+			   unsigned blue, unsigned transp, struct fb_info *info)
+{
+	int ret = 1;
+
+	/*
+	 * If greyscale is true, then we convert the RGB value
+	 * to greyscale no matter what visual we are using.
+	 */
+	if (info->var.grayscale)
+		red = green = blue = (19595 * red + 38470 * green +
+				      7471 * blue) >> 16;
+	switch (info->fix.visual) {
+	case FB_VISUAL_TRUECOLOR:
+		/*
+		 * 16-bit True Colour.  We encode the RGB value
+		 * according to the RGB bitfield information.
+		 */
+		if (regno < 16) {
+			u32 *pal = info->pseudo_palette;
+			u32 v;
+
+#define CNVT_TOHW(val,width) ((((val)<<(width))+0x7FFF-(val))>>16)
+			red = CNVT_TOHW(red, info->var.red.length);
+			green = CNVT_TOHW(green, info->var.green.length);
+			blue = CNVT_TOHW(blue, info->var.blue.length);
+			transp = CNVT_TOHW(transp, info->var.transp.length);
+#undef CNVT_TOHW
+
+			v = (red << info->var.red.offset) |
+			    (green << info->var.green.offset) |
+			    (blue << info->var.blue.offset) |
+			    (transp << info->var.transp.offset);
+
+			pal[regno] = v;
+			ret = 0;
+		}
+		break;
+	case FB_VISUAL_STATIC_PSEUDOCOLOR:
+	case FB_VISUAL_PSEUDOCOLOR:
+		break;
+	}
+
+	return ret;
+}
+
+/*!
+ * @brief Pans the display.
+ *
+ * @param var	Frame buffer variable screen structure
+ * @param info	Frame buffer structure that represents a single frame buffer
+ *
+ * @return	Negative errno on error, or zero on success.
+ *
+ * Pan (or wrap, depending on the `vmode' field) the display using the
+ * 'xoffset' and 'yoffset' fields of the 'var' structure. If the values
+ * don't fit, return -EINVAL.
+ */
+static int mx2fb_pan_display(struct fb_var_screeninfo *var,
+			     struct fb_info *info)
+{
+	if ((info->var.xoffset == var->xoffset) &&
+	    (info->var.yoffset == var->yoffset)) {
+		return 0;	/* No change, do nothing */
+	}
+
+	if (var->xoffset < 0 || var->yoffset < 0
+	    || var->xoffset + info->var.xres > info->var.xres_virtual
+	    || var->yoffset + info->var.yres > info->var.yres_virtual)
+		return -EINVAL;
+
+	info->var.xoffset = var->xoffset;
+	info->var.yoffset = var->yoffset;
+
+	_update_lcdc(info);
+
+	if (var->vmode & FB_VMODE_YWRAP) {
+		info->var.vmode |= FB_VMODE_YWRAP;
+	} else {
+		info->var.vmode &= ~FB_VMODE_YWRAP;
+	}
+
+	return 0;
+}
+
+/*!
+ * @brief Blanks the display.
+ *
+ * @param blank_mode	The blank mode we want.
+ * @param info		Frame buffer structure that represents a single frame buffer
+ *
+ * @return		Negative errno on error, or zero on success.
+ *
+ * Blank the screen if blank_mode != 0, else unblank. Return 0 if blanking
+ * succeeded, != 0 if un-/blanking failed.
+ * blank_mode == 2: suspend vsync
+ * blank_mode == 3: suspend hsync
+ * blank_mode == 4: powerdown
+ */
+static int mx2fb_blank(int blank_mode, struct fb_info *info)
+{
+	struct mx2fb_info *mx2fbi = (struct mx2fb_info *)info->par;
+
+	dev_dbg(info->device, "blank mode = %d\n", blank_mode);
+
+	mx2fbi->blank = blank_mode;
+
+	switch (blank_mode) {
+	case FB_BLANK_POWERDOWN:
+	case FB_BLANK_VSYNC_SUSPEND:
+	case FB_BLANK_HSYNC_SUSPEND:
+	case FB_BLANK_NORMAL:
+		_disable_lcdc(info);
+		break;
+	case FB_BLANK_UNBLANK:
+		_enable_lcdc(info);
+		break;
+	}
+
+	return 0;
+}
+
+/*!
+ * @brief Ioctl function to support customized ioctl operations.
+ *
+ * @param info	Framebuffer structure that represents a single frame buffer
+ * @param cmd	The command number
+ * @param arg	Argument which depends on cmd
+ *
+ * @return	Negative errno on error, or zero on success.
+ */
+static int mx2fb_ioctl(struct fb_info *info, unsigned int cmd,
+		       unsigned long arg)
+{
+	struct mx2fb_info *mx2fbi = (struct mx2fb_info *)info->par;
+	struct mx2fb_gbl_alpha ga;
+	struct mx2fb_color_key ck;
+	unsigned char level;
+
+	switch (cmd) {
+	case MX2FB_SET_GBL_ALPHA:
+		if (mx2fbi->type != MX2FB_TYPE_GW)
+			return -ENODEV;
+
+		if (!arg)
+			return -EINVAL;
+
+		/* set graphic window information */
+		if (copy_from_user((void *)&ga, (void *)arg, sizeof(ga)))
+			return -EFAULT;
+
+		g_gwinfo.alpha_value = ga.alpha;
+
+		if (g_gwinfo.enabled)
+			_enable_graphic_window(info);
+		else
+			_disable_graphic_window(info);
+		break;
+	case MX2FB_SET_CLR_KEY:
+		if (mx2fbi->type != MX2FB_TYPE_GW)
+			return -ENODEV;
+
+		if (!arg)
+			return -EINVAL;
+
+		/* set graphic window information */
+		if (copy_from_user((void *)&ck, (void *)arg, sizeof(ck)))
+			return -EFAULT;
+
+		g_gwinfo.ck_enabled = ck.enable;
+		g_gwinfo.ck_red = (ck.color_key & 0x003F0000) >> 16;
+		g_gwinfo.ck_green = (ck.color_key & 0x00003F00) >> 8;
+		g_gwinfo.ck_blue = ck.color_key & 0x0000003F;
+
+		if (g_gwinfo.enabled)
+			_enable_graphic_window(info);
+		else
+			_disable_graphic_window(info);
+		break;
+	case MX2FB_SET_BRIGHTNESS:
+		if (copy_from_user((void *)&level, (void *)arg, sizeof(level)))
+			return -EFAULT;
+		brightness = level;
+		_set_brightness(level);
+		break;
+	case FBIOGET_GWINFO:
+		if (mx2fbi->type != MX2FB_TYPE_GW)
+			return -ENODEV;
+
+		if (!arg)
+			return -EINVAL;
+
+		/* get graphic window information */
+		if (copy_to_user((void *)arg, (void *)&g_gwinfo,
+				 sizeof(g_gwinfo)))
+			return -EFAULT;
+		break;
+	case FBIOPUT_GWINFO:
+		if (mx2fbi->type != MX2FB_TYPE_GW)
+			return -ENODEV;
+
+		if (!arg)
+			return -EINVAL;
+
+		/* set graphic window information */
+		if (copy_from_user((void *)&g_gwinfo, (void *)arg,
+				   sizeof(g_gwinfo)))
+			return -EFAULT;
+
+		if (g_gwinfo.enabled)
+			_enable_graphic_window(info);
+		else
+			_disable_graphic_window(info);
+		break;
+#ifdef CONFIG_FB_MXC_TVOUT
+	case ENCODER_GET_CAPABILITIES:{
+			int ret;
+			struct video_encoder_capability cap;
+
+			if (mx2fbi->type != MX2FB_TYPE_BG)
+				return -ENODEV;
+
+			ret = fs453_ioctl(cmd, &cap);
+			if (ret)
+				return ret;
+
+			if (copy_to_user((void *)arg, &cap, sizeof(cap)))
+				return -EFAULT;
+			break;
+		}
+	case ENCODER_SET_NORM:{
+			int ret;
+			unsigned long mode;
+			char *smode;
+			struct fb_var_screeninfo var;
+
+			if (mx2fbi->type != MX2FB_TYPE_BG)
+				return -ENODEV;
+
+			if (copy_from_user(&mode, (void *)arg, sizeof(mode)))
+				return -EFAULT;
+			if ((ret = fs453_ioctl(cmd, &mode)))
+				return ret;
+
+			if (mode == VIDEO_ENCODER_PAL)
+				smode = MODE_PAL;
+			else if (mode == VIDEO_ENCODER_NTSC)
+				smode = MODE_NTSC;
+			else
+				smode = MODE_VGA;
+
+			var = info->var;
+			var.nonstd = 0;
+			ret = fb_find_mode(&var, info, smode, mxcfb_modedb,
+					   mxcfb_modedb_sz, NULL, default_bpp);
+			if ((ret != 1) && (ret != 2))	/* specified mode not found */
+				return -ENODEV;
+
+			info->var = var;
+			fb_mode = smode;
+			return mx2fb_set_par(info);
+		}
+	case ENCODER_SET_INPUT:
+	case ENCODER_SET_OUTPUT:
+	case ENCODER_ENABLE_OUTPUT:{
+			unsigned long varg;
+
+			if (mx2fbi->type != MX2FB_TYPE_BG)
+				return -ENODEV;
+
+			if (copy_from_user(&varg, (void *)arg, sizeof(varg)))
+				return -EFAULT;
+			return fs453_ioctl(cmd, &varg);
+		}
+#endif
+	default:
+		dev_dbg(info->device, "Unknown ioctl command (0x%08X)\n", cmd);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*!
+ * @brief Set fixed framebuffer parameters based on variable settings.
+ *
+ * @param info	framebuffer information pointer
+ * @return	Negative errno on error, or zero on success.
+ */
+static void _set_fix(struct fb_info *info)
+{
+	struct fb_fix_screeninfo *fix = &info->fix;
+	struct fb_var_screeninfo *var = &info->var;
+	struct mx2fb_info *mx2fbi = (struct mx2fb_info *)info->par;
+
+	strncpy(fix->id, mx2fbi->id, strlen(mx2fbi->id));
+	fix->line_length = var->xres_virtual * var->bits_per_pixel / 8;
+	fix->type = FB_TYPE_PACKED_PIXELS;
+	fix->accel = FB_ACCEL_NONE;
+	fix->visual = FB_VISUAL_TRUECOLOR;
+	fix->xpanstep = 1;
+	fix->ypanstep = 1;
+}
+
+/*!
+ * @brief Initialize framebuffer information structure.
+ *
+ * @param info	framebuffer information pointer
+ * @param pdev	pointer to struct device
+ * @return	Negative errno on error, or zero on success.
+ */
+static int __init _init_fbinfo(struct fb_info *info,
+			       struct platform_device *pdev)
+{
+	struct mx2fb_info *mx2fbi = (struct mx2fb_info *)info->par;
+
+	info->device = &pdev->dev;
+	info->var.activate = FB_ACTIVATE_NOW;
+	info->fbops = &mx2fb_ops;
+	info->flags = FBINFO_FLAG_DEFAULT;
+	info->pseudo_palette = &mx2fbi->pseudo_palette;
+
+	/* Allocate colormap */
+	fb_alloc_cmap(&info->cmap, 16, 0);
+
+	return 0;
+}
+
+/*!
+ * @brief Install framebuffer into the system.
+ *
+ * @param info	framebuffer information pointer
+ * @param pdev  pointer to struct device
+ * @return	Negative errno on error, or zero on success.
+ */
+static int __init _install_fb(struct fb_info *info,
+			      struct platform_device *pdev)
+{
+	struct mx2fb_info *mx2fbi = (struct mx2fb_info *)info->par;
+
+	if (_init_fbinfo(info, pdev))
+		return -EINVAL;
+
+	if (fb_mode == 0)
+		fb_mode = pdev->dev.platform_data;
+
+	if (!fb_find_mode(&info->var, info, fb_mode, mxcfb_modedb,
+			  mxcfb_modedb_sz, NULL, default_bpp)) {
+		fb_dealloc_cmap(&info->cmap);
+		return -EBUSY;
+	}
+
+	/* Default Y virtual size is 2x panel size */
+	/* info->var.yres_virtual = info->var.yres << 1; */
+
+	if (mx2fbi->type == MX2FB_TYPE_GW)
+		mx2fbi->blank = FB_BLANK_NORMAL;
+	else
+		mx2fbi->blank = FB_BLANK_UNBLANK;
+
+	if (mx2fb_set_par(info)) {
+		fb_dealloc_cmap(&info->cmap);
+		return -EINVAL;
+	}
+
+	if (register_framebuffer(info) < 0) {
+		_unmap_video_memory(info);
+		fb_dealloc_cmap(&info->cmap);
+		return -EINVAL;
+	}
+
+	mx2fbi->registered = 1;
+	dev_info(info->device, "fb%d: %s fb device registered successfully.\n",
+		 info->node, info->fix.id);
+
+	return 0;
+}
+
+/*!
+ * @brief Uninstall framebuffer from the system.
+ *
+ * @param info	framebuffer information pointer
+ */
+static void __exit _uninstall_fb(struct fb_info *info)
+{
+	struct mx2fb_info *mx2fbi = (struct mx2fb_info *)info->par;
+
+	if (!mx2fbi->registered)
+		return;
+
+	unregister_framebuffer(info);
+	_unmap_video_memory(info);
+	if (&info->cmap)
+		fb_dealloc_cmap(&info->cmap);
+
+	mx2fbi->registered = 0;
+}
+
+/*!
+ * @brief Allocate memory for framebuffer.
+ *
+ * @param info	framebuffer information pointer
+ * @return	Negative errno on error, or zero on success.
+ */
+static int _map_video_memory(struct fb_info *info)
+{
+	info->fix.smem_len = info->fix.line_length * info->var.yres_virtual;
+	info->screen_base = dma_alloc_coherent(0,
+					       info->fix.smem_len,
+					       (dma_addr_t *) & info->fix.
+					       smem_start,
+					       GFP_DMA | GFP_KERNEL);
+
+	if (info->screen_base == 0) {
+		dev_err(info->device, "Unable to allocate fb memory\n");
+		return -EBUSY;
+	}
+	dev_dbg(info->device, "Allocated fb @ paddr=0x%08X, size=%d.\n",
+		info->fix.smem_start, info->fix.smem_len);
+
+	info->screen_size = info->fix.smem_len;
+
+	/* Clear the screen */
+	memset((char *)info->screen_base, 0, info->fix.smem_len);
+
+	return 0;
+}
+
+/*!
+ * @brief Release memory for framebuffer.
+ * @param info	framebuffer information pointer
+ */
+static void _unmap_video_memory(struct fb_info *info)
+{
+	dma_free_coherent(0, info->fix.smem_len, info->screen_base,
+			  (dma_addr_t) info->fix.smem_start);
+
+	info->screen_base = 0;
+	info->fix.smem_start = 0;
+	info->fix.smem_len = 0;
+}
+
+/*!
+ * @brief Enable LCD controller.
+ * @param info	framebuffer information pointer
+ */
+static void _enable_lcdc(struct fb_info *info)
+{
+	static int first_enable = 1;
+	struct mx2fb_info *mx2fbi = (struct mx2fb_info *)info->par;
+
+	/*
+	 * Graphic window can only be enabled while the HCLK to the LCDC
+	 * is disabled. Once enabled it can subsequently be disabled and
+	 * enabled without turning off the HCLK.
+	 * The graphic window is enabled and then disabled here. So next
+	 * time to enable graphic window the HCLK to LCDC does not need
+	 * to be disabled, and the flicker (due to disabling of HCLK to
+	 * LCDC) is avoided.
+	 */
+	if (first_enable) {
+		_enable_graphic_window(info);
+		_disable_graphic_window(info);
+		first_enable = 0;
+	}
+
+	if (mx2fbi->type == MX2FB_TYPE_GW)
+		_enable_graphic_window(info);
+	else if (!fb_enabled) {
+		clk_enable(lcdc_clk);
+		gpio_lcdc_active();
+		board_power_lcd(1);
+		_set_brightness(brightness);
+		fb_enabled++;
+#ifdef CONFIG_FB_MXC_TVOUT
+		if (fb_mode) {
+			unsigned long mode = 0;
+
+			if (strcmp(fb_mode, MODE_VGA) == 0)
+				mode = VIDEO_ENCODER_VGA;
+			else if (strcmp(fb_mode, MODE_NTSC) == 0)
+				mode = VIDEO_ENCODER_NTSC;
+			else if (strcmp(fb_mode, MODE_PAL) == 0)
+				mode = VIDEO_ENCODER_PAL;
+			if (mode)
+				fs453_ioctl(ENCODER_SET_NORM, &mode);
+		}
+#endif
+	}
+}
+
+/*!
+ * @brief Disable LCD controller.
+ * @param info	framebuffer information pointer
+ */
+static void _disable_lcdc(struct fb_info *info)
+{
+	struct mx2fb_info *mx2fbi = (struct mx2fb_info *)info->par;
+
+	if (mx2fbi->type == MX2FB_TYPE_GW)
+		_disable_graphic_window(info);
+	else {
+		if (fb_enabled) {
+			gpio_lcdc_inactive();
+			board_power_lcd(0);
+			_set_brightness(0);
+			clk_disable(lcdc_clk);
+			fb_enabled = 0;
+		}
+#ifdef CONFIG_FB_MXC_TVOUT
+		if (fb_mode) {
+			int enable = 0;
+
+			if ((strcmp(fb_mode, MODE_VGA) == 0)
+			    || (strcmp(fb_mode, MODE_NTSC) == 0)
+			    || (strcmp(fb_mode, MODE_PAL) == 0))
+				fs453_ioctl(ENCODER_ENABLE_OUTPUT, &enable);
+		}
+#endif
+	}
+}
+
+/*!
+ * @brief Enable graphic window.
+ * @param info	framebuffer information pointer
+ */
+static void _enable_graphic_window(struct fb_info *info)
+{
+	struct fb_var_screeninfo *var = &info->var;
+
+	g_gwinfo.enabled = 1;
+
+	g_gwinfo.base = (var->yoffset * var->xres_virtual + var->xoffset);
+	g_gwinfo.base *= (var->bits_per_pixel) / 8;
+	g_gwinfo.base += info->fix.smem_start;
+
+	g_gwinfo.xres = var->xres;
+	g_gwinfo.yres = var->yres;
+	g_gwinfo.xres_virtual = var->xres_virtual;
+
+	mx2_gw_set(&g_gwinfo);
+}
+
+/*!
+ * @brief Disable graphic window.
+ * @param info	framebuffer information pointer
+ */
+static void _disable_graphic_window(struct fb_info *info)
+{
+	unsigned long i = 0;
+
+	g_gwinfo.enabled = 0;
+
+	/*
+	 * Set alpha value to zero and reduce gw size, otherwise the graphic
+	 * window will not be able to be enabled again.
+	 */
+	__raw_writel(__raw_readl(LCDC_REG(LCDC_LGWCR)) & 0x00FFFFFF,
+		     LCDC_REG(LCDC_LGWCR));
+	__raw_writel(((16 >> 4) << 20) + 16, LCDC_REG(LCDC_LGWSR));
+	while (i < 1000)
+		i++;
+
+	/* Now disable graphic window */
+	__raw_writel(__raw_readl(LCDC_REG(LCDC_LGWCR)) & ~0x00400000,
+		     LCDC_REG(LCDC_LGWCR));
+
+	dev_dbg(info->device, "Graphic window disabled.\n");
+}
+
+/*!
+ * @brief Setup graphic window properties.
+ * @param gwinfo	graphic window information pointer
+ */
+void mx2_gw_set(struct fb_gwinfo *gwinfo)
+{
+	int width, height, xpos, ypos;
+	int width_bg, height_bg;
+	unsigned long lgwcr = 0x00400000;	/* Graphic window control register */
+
+	if (!gwinfo->enabled) {
+		_disable_graphic_window(0);
+		return;
+	}
+
+	/* Graphic window start address register */
+	__raw_writel(gwinfo->base, LCDC_REG(LCDC_LGWSAR));
+
+	/*
+	 * The graphic window width, height, x position and y position
+	 * must be synced up width the background window, otherwise there
+	 * may be flickering.
+	 */
+	width_bg = (__raw_readl(LCDC_REG(LCDC_LSR)) & 0x03F00000) >> 16;
+	height_bg = __raw_readl(LCDC_REG(LCDC_LSR)) & 0x000003FF;
+
+	width = (gwinfo->xres > width_bg) ? width_bg : gwinfo->xres;
+	height = (gwinfo->yres > height_bg) ? height_bg : gwinfo->yres;
+
+	xpos = gwinfo->xpos;
+	ypos = gwinfo->ypos;
+
+	if (xpos + width > width_bg)
+		xpos = width_bg - width;
+	if (ypos + height > height_bg)
+		ypos = height_bg - height;
+
+	/* Graphic window size register */
+	__raw_writel(((width >> 4) << 20) + height, LCDC_REG(LCDC_LGWSR));
+
+	/* Graphic window virtual page width register */
+	__raw_writel(gwinfo->xres_virtual >> 1, LCDC_REG(LCDC_LGWVPWR));
+
+	/* Graphic window position register */
+	__raw_writel(((xpos & 0x000003FF) << 16) | (ypos & 0x000003FF),
+		     LCDC_REG(LCDC_LGWPR));
+
+	/* Graphic window panning offset register */
+	__raw_writel(0, LCDC_REG(LCDC_LGWPOR));
+
+	/* Graphic window DMA control register */
+	if (cpu_is_mx27_rev(CHIP_REV_2_0) > 0)
+		__raw_writel(0x00040060, LCDC_REG(LCDC_LGWDCR));
+	else
+		__raw_writel(0x00020010, LCDC_REG(LCDC_LGWDCR));
+
+	/* Graphic window control register */
+	lgwcr |= (gwinfo->alpha_value & 0x000000FF) << 24;
+	lgwcr |= gwinfo->ck_enabled ? 0x00800000 : 0;
+	lgwcr |= gwinfo->vs_reversed ? 0x00200000 : 0;
+
+	/*
+	 * Color keying value
+	 * Todo: assume always use RGB565
+	 */
+	lgwcr |= (gwinfo->ck_red & 0x0000003F) << 12;
+	lgwcr |= (gwinfo->ck_green & 0x0000003F) << 6;
+	lgwcr |= gwinfo->ck_blue & 0x0000003F;
+
+	__raw_writel(lgwcr, LCDC_REG(LCDC_LGWCR));
+
+	pr_debug("Graphic window enabled.\n");
+}
+
+/*!
+ * @brief Update LCDC registers
+ * @param info	framebuffer information pointer
+ */
+static void _update_lcdc(struct fb_info *info)
+{
+	unsigned long base;
+	unsigned long perclk3, pcd, pcr;
+	struct fb_var_screeninfo *var = &info->var;
+	struct mx2fb_info *mx2fbi = (struct mx2fb_info *)info->par;
+
+	if (mx2fbi->type == MX2FB_TYPE_GW) {
+		_enable_graphic_window(info);
+		return;
+	}
+
+	base = (var->yoffset * var->xres_virtual + var->xoffset);
+	base *= (var->bits_per_pixel) / 8;
+	base += info->fix.smem_start;
+
+	/* Screen start address register */
+	__raw_writel(base, LCDC_REG(LCDC_LSSAR));
+
+	/* Size register */
+	dev_dbg(info->device, "xres = %d, yres = %d\n",
+		info->var.xres, info->var.yres);
+	__raw_writel(((info->var.xres >> 4) << 20) + info->var.yres,
+		     LCDC_REG(LCDC_LSR));
+
+	/* Virtual page width register */
+	__raw_writel(info->var.xres_virtual >> 1, LCDC_REG(LCDC_LVPWR));
+
+	/* To setup LCDC pixel clock */
+	perclk3 = clk_round_rate(lcdc_clk, 134000000);
+	if (clk_set_rate(lcdc_clk, perclk3)) {
+		printk(KERN_INFO "mx2fb: Unable to set clock to %lu\n",
+		       perclk3);
+		perclk3 = clk_get_rate(lcdc_clk);
+	}
+
+	/* Calculate pixel clock divider, and round to the nearest integer */
+	pcd = (perclk3 * 8 / (PICOS2KHZ(var->pixclock) * 1000UL) + 4) / 8;
+	if (--pcd > 0x3F)
+		pcd = 0x3F;
+
+	/* Panel configuration register */
+	pcr = 0xFA008B80 | pcd;
+	pcr |= (var->sync & FB_SYNC_CLK_INVERT) ? 0x01000000 : 0;
+	pcr |= (var->sync & FB_SYNC_SHARP_MODE) ? 0x00000040 : 0;
+	pcr |= (var->sync & FB_SYNC_OE_ACT_HIGH) ? 0 : 0x00100000;
+	__raw_writel(pcr, LCDC_REG(LCDC_LPCR));
+
+	/* Horizontal and vertical configuration register */
+	__raw_writel(((var->hsync_len - 1) << 26)
+		     + ((var->right_margin - 1) << 8)
+		     + (var->left_margin - 3), LCDC_REG(LCDC_LHCR));
+	__raw_writel((var->vsync_len << 26)
+		     + (var->lower_margin << 8)
+		     + var->upper_margin, LCDC_REG(LCDC_LVCR));
+
+	/* Sharp configuration register */
+	__raw_writel(0x00120300, LCDC_REG(LCDC_LSCR));
+
+	/* Refresh mode control reigster */
+	__raw_writel(0x00000000, LCDC_REG(LCDC_LRMCR));
+
+	/* DMA control register */
+	if (cpu_is_mx27_rev(CHIP_REV_2_0) > 0)
+		__raw_writel(0x00040060, LCDC_REG(LCDC_LDCR));
+	else
+		__raw_writel(0x00020010, LCDC_REG(LCDC_LDCR));
+
+	/* PWM contrast control register */
+	_set_brightness(brightness);
+}
+
+/*!
+ * @brief Set LCD brightness
+ * @param level	brightness level
+ */
+static void _set_brightness(unsigned char level)
+{
+	/* Set LCDC PWM contract control register */
+	__raw_writel(0x00A90300 | level, LCDC_REG(LCDC_LPCCR));
+}
+
+/*
+ * @brief LCDC interrupt handler
+ */
+static irqreturn_t mx2fb_isr(int irq, void *dev_id)
+{
+	struct fb_event event;
+	unsigned long status = __raw_readl(LCDC_REG(LCDC_LISR));
+
+	if (status & MX2FB_INT_EOF) {
+		event.info = &mx2fb_info[0];
+		atomic_notifier_call_chain(&mx2fb_notifier_list,
+					   FB_EVENT_MXC_EOF, &event);
+	}
+#ifdef CONFIG_FB_MXC_OVERLAY
+	if (status & MX2FB_INT_GW_EOF) {
+		event.info = &mx2fb_info[1];
+		atomic_notifier_call_chain(&mx2fb_notifier_list,
+					   FB_EVENT_MXC_EOF, &event);
+	}
+#endif
+
+	return IRQ_HANDLED;
+}
+
+/*!
+ * @brief Config and request LCDC interrupt
+ */
+static void _request_irq(void)
+{
+	unsigned long status;
+	unsigned long flags;
+
+	/* Read to clear the status */
+	status = __raw_readl(LCDC_REG(LCDC_LISR));
+
+	if (request_irq(MXC_INT_LCDC, mx2fb_isr, 0, "LCDC", 0))
+		pr_info("Request LCDC IRQ failed.\n");
+	else {
+		spin_lock_irqsave(&mx2fb_notifier_list.lock, flags);
+
+		/* Enable interrupt in case client has registered */
+		if (mx2fb_notifier_list.head != NULL) {
+			unsigned long status;
+			unsigned long ints = MX2FB_INT_EOF;
+#ifdef CONFIG_FB_MXC_OVERLAY
+			ints |= MX2FB_INT_GW_EOF;
+#endif
+			/* Read to clear the status */
+			status = __raw_readl(LCDC_REG(LCDC_LISR));
+
+			/* Configure interrupt condition for EOF */
+			__raw_writel(0x0, LCDC_REG(LCDC_LICR));
+
+			/* Enable EOF and graphic window EOF interrupt */
+			__raw_writel(ints, LCDC_REG(LCDC_LIER));
+		}
+
+		spin_unlock_irqrestore(&mx2fb_notifier_list.lock, flags);
+	}
+}
+
+/*!
+ * @brief Free LCDC interrupt handler
+ */
+static void _free_irq(void)
+{
+	/* Disable all LCDC interrupt */
+	__raw_writel(0x0, LCDC_REG(LCDC_LIER));
+
+	free_irq(MXC_INT_LCDC, 0);
+}
+
+/*!
+ * @brief Register a client notifier
+ * @param nb	notifier block to callback on events
+ */
+int mx2fb_register_client(struct notifier_block *nb)
+{
+	unsigned long flags;
+	int ret;
+
+	ret = atomic_notifier_chain_register(&mx2fb_notifier_list, nb);
+
+	spin_lock_irqsave(&mx2fb_notifier_list.lock, flags);
+
+	/* Enable interrupt in case client has registered */
+	if (mx2fb_notifier_list.head != NULL) {
+		unsigned long status;
+		unsigned long ints = MX2FB_INT_EOF;
+#ifdef CONFIG_FB_MXC_OVERLAY
+		ints |= MX2FB_INT_GW_EOF;
+#endif
+		/* Read to clear the status */
+		status = __raw_readl(LCDC_REG(LCDC_LISR));
+
+		/* Configure interrupt condition for EOF */
+		__raw_writel(0x0, LCDC_REG(LCDC_LICR));
+
+		/* Enable EOF and graphic window EOF interrupt */
+		__raw_writel(ints, LCDC_REG(LCDC_LIER));
+	}
+
+	spin_unlock_irqrestore(&mx2fb_notifier_list.lock, flags);
+
+	return ret;
+}
+
+/*!
+ * @brief Unregister a client notifier
+ * @param nb	notifier block to callback on events
+ */
+int mx2fb_unregister_client(struct notifier_block *nb)
+{
+	unsigned long flags;
+	int ret;
+
+	ret = atomic_notifier_chain_unregister(&mx2fb_notifier_list, nb);
+
+	spin_lock_irqsave(&mx2fb_notifier_list.lock, flags);
+
+	/* Mask interrupt in case no client registered */
+	if (mx2fb_notifier_list.head == NULL)
+		__raw_writel(0x0, LCDC_REG(LCDC_LIER));
+
+	spin_unlock_irqrestore(&mx2fb_notifier_list.lock, flags);
+
+	return ret;
+}
+
+#ifdef CONFIG_PM
+/*
+ * Power management hooks. Note that we won't be called from IRQ context,
+ * unlike the blank functions above, so we may sleep.
+ */
+
+/*!
+ * @brief Suspends the framebuffer and blanks the screen.
+ * Power management support
+ */
+static int mx2fb_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	_disable_lcdc(&mx2fb_info[0]);
+
+	return 0;
+}
+
+/*!
+ * @brief Resumes the framebuffer and unblanks the screen.
+ * Power management support
+ */
+static int mx2fb_resume(struct platform_device *pdev)
+{
+	_enable_lcdc(&mx2fb_info[0]);
+
+	return 0;
+}
+
+#endif				/* CONFIG_PM */
+
+/*!
+ * @brief Probe routine for the framebuffer driver. It is called during the
+ *        driver binding process.
+ *
+ * @return Appropriate error code to the kernel common code
+ */
+static int mx2fb_probe(struct platform_device *pdev)
+{
+	int ret, i;
+
+	lcdc_clk = clk_get(&pdev->dev, "lcdc_clk");
+
+	for (i = 0; i < sizeof(mx2fb_info) / sizeof(struct fb_info); i++) {
+		if ((ret = _install_fb(&mx2fb_info[i], pdev))) {
+			dev_err(&pdev->dev,
+				"Failed to register framebuffer %d\n", i);
+			return ret;
+		}
+	}
+	_request_irq();
+
+	return 0;
+}
+
+/*!
+ * @brief Initialization
+ */
+int __init mx2fb_init(void)
+{
+	/*
+	 * For kernel boot options (in 'video=xxxfb:<options>' format)
+	 */
+#ifndef MODULE
+	{
+		char *option;
+
+		if (fb_get_options("mxcfb", &option))
+			return -ENODEV;
+		mx2fb_setup(option);
+	}
+#endif
+	return platform_driver_register(&mx2fb_driver);
+}
+
+/*!
+ * @brief Cleanup
+ */
+void __exit mx2fb_exit(void)
+{
+	int i;
+
+	_free_irq();
+	for (i = sizeof(mx2fb_info) / sizeof(struct fb_info); i > 0; i--)
+		_uninstall_fb(&mx2fb_info[i - 1]);
+
+	platform_driver_unregister(&mx2fb_driver);
+}
+
+#ifndef MODULE
+/*!
+ * @brief Setup
+ * Parse user specified options
+ * Example: video=mxcfb:240x320,bpp=16,Sharp-QVGA
+ */
+static int __init mx2fb_setup(char *options)
+{
+	char *opt;
+
+	if (!options || !*options)
+		return 0;
+
+	while ((opt = strsep(&options, ",")) != NULL) {
+		if (!*opt)
+			continue;
+
+		if (!strncmp(opt, "bpp=", 4))
+			default_bpp = simple_strtoul(opt + 4, NULL, 0);
+		else
+			fb_mode = opt;
+	}
+
+	return 0;
+}
+#endif
+
+/* Modularization */
+module_init(mx2fb_init);
+module_exit(mx2fb_exit);
+
+EXPORT_SYMBOL(mx2_gw_set);
+EXPORT_SYMBOL(mx2fb_register_client);
+EXPORT_SYMBOL(mx2fb_unregister_client);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MX2 framebuffer driver");
+MODULE_LICENSE("GPL");
Index: linux-2.6.18/drivers/video/mxc/mx2fb.h
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/video/mxc/mx2fb.h
@@ -0,0 +1,142 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file    mx2fb.h
+ *
+ * @brief Header file for the MX27 Frame buffer
+ *
+ * @ingroup Framebuffer
+ */
+#ifndef __MX2FB_H__
+#define __MX2FB_H__
+
+/*! @brief MX27 LCDC graphic window information */
+struct fb_gwinfo {
+	/*! Non-zero if graphic window is enabled */
+	__u32 enabled;
+
+	/* The fields below are valid only when graphic window is enabled */
+
+	/*! Graphic window alpha value from 0 to 255 */
+	__u32 alpha_value;
+
+	/*! Non-zero if graphic window color keying is enabled. */
+	__u32 ck_enabled;
+
+	/*
+	 * The fields ck_red, ck_green and ck_blue are valid only when
+	 * graphic window and the color keying are enabled. They are the
+	 * color component of graphic window color keying.
+	 */
+
+	/*! Color keying red component */
+	__u32 ck_red;
+
+	/*! Color keying green component */
+	__u32 ck_green;
+
+	/*! Color keying blue component */
+	__u32 ck_blue;
+
+	/*! Graphic window x position */
+	__u32 xpos;
+
+	/*! Graphic window y position */
+	__u32 ypos;
+
+	/*! Non-zero if graphic window vertical scan in reverse direction. */
+	__u32 vs_reversed;
+
+	/*
+	 * The following fields are valid for FBIOGET_GWINFO and
+	 * mx2_gw_set(). FBIOPUT_GWINFO ignores these fields.
+	 */
+	__u32 base;		/* Graphic window start address */
+	__u32 xres;		/* Visible x resolution */
+	__u32 yres;		/* Visible y resolution */
+	__u32 xres_virtual;	/* Virtual x resolution */
+};
+
+/* 0x46E0-0x46FF are reserved for MX27 */
+#define FBIOGET_GWINFO		0x46E0	/*!< Get graphic window information */
+#define FBIOPUT_GWINFO		0x46E1	/*!< Set graphic window information */
+
+struct mx2fb_gbl_alpha {
+	int enable;
+	int alpha;
+};
+
+struct mx2fb_color_key {
+	int enable;
+	__u32 color_key;
+};
+
+#define MX2FB_SET_GBL_ALPHA	_IOW('M', 0, struct mx2fb_gbl_alpha)
+#define MX2FB_SET_CLR_KEY	_IOW('M', 1, struct mx2fb_color_key)
+#define MX2FB_WAIT_FOR_VSYNC	_IOW('F', 0x20, u_int32_t)
+#define MX2FB_SET_BRIGHTNESS	_IOW('M', 3, __u8)
+
+#ifdef __KERNEL__
+
+/*
+ * LCDC register definitions
+ */
+#define LCDC_LSSAR		0x00
+#define LCDC_LSR		0x04
+#define LCDC_LVPWR		0x08
+#define LCDC_LCPR		0x0C
+#define LCDC_LCWHBR		0x10
+#define LCDC_LCCMR		0x14
+#define LCDC_LPCR		0x18
+#define LCDC_LHCR		0x1C
+#define LCDC_LVCR		0x20
+#define LCDC_LPOR		0x24
+#define LCDC_LSCR		0x28
+#define LCDC_LPCCR		0x2C
+#define LCDC_LDCR		0x30
+#define LCDC_LRMCR		0x34
+#define LCDC_LICR		0x38
+#define LCDC_LIER		0x3C
+#define LCDC_LISR		0x40
+#define LCDC_LGWSAR		0x50
+#define LCDC_LGWSR		0x54
+#define LCDC_LGWVPWR		0x58
+#define LCDC_LGWPOR		0x5C
+#define LCDC_LGWPR		0x60
+#define LCDC_LGWCR		0x64
+#define LCDC_LGWDCR		0x68
+#define LCDC_LAUSCR		0x80
+#define LCDC_LAUSCCR		0x84
+
+#define LCDC_REG(reg)		(IO_ADDRESS(LCDC_BASE_ADDR) + reg)
+
+#define MX2FB_INT_BOF		0x0001	/* Beginning of Frame */
+#define MX2FB_INT_EOF		0x0002	/* End of Frame */
+#define MX2FB_INT_ERR_RES	0x0004	/* Error Response */
+#define MX2FB_INT_UDR_ERR	0x0008	/* Under Run Error */
+#define MX2FB_INT_GW_BOF	0x0010	/* Graphic Window BOF */
+#define MX2FB_INT_GW_EOF	0x0020	/* Graphic Window EOF */
+#define MX2FB_INT_GW_ERR_RES	0x0040	/* Graphic Window ERR_RES */
+#define MX2FB_INT_GW_UDR_ERR	0x0080	/* Graphic Window UDR_ERR */
+
+#define FB_EVENT_MXC_EOF	0x8001	/* End of Frame event */
+
+int mx2fb_register_client(struct notifier_block *nb);
+int mx2fb_unregister_client(struct notifier_block *nb);
+
+void mx2_gw_set(struct fb_gwinfo *gwinfo);
+
+#endif				/* __KERNEL__ */
+
+#endif				/* __MX2FB_H__ */
Index: linux-2.6.18/drivers/video/mxc/mx2fb_epson.c
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/video/mxc/mx2fb_epson.c
@@ -0,0 +1,2173 @@
+#error "please port this file to linux 2.6.18"
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!@example slcdctest.c test driver using EPSON L2F50032T00 serial mode */
+
+/**
+ *
+ * @defgroup SLCDC 			SLCDC driver
+ **/
+/**@{*/
+/**
+ * @file   mx2fb_epson.c
+ * @brief   slcdc driver source code
+ *
+ * This is the basic release for SLCDC driver, which is to support EPSON
+ * L2F50032T00 16bit seria mode5-6-5 and parallel mode. This driver acts as a
+ * standard character device, which can be dinamically loaded.
+ * For example, you can refer to slcdctest.c file.
+ *
+ * Modification History:
+ * 15,Dec,2003 Karen Kang
+ *
+ * 21,Feb,2006 Vasanthan S
+ *
+ * @bug
+ **/
+
+#ifndef __KERNEL__
+#  define __KERNEL__
+#endif
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/string.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/interrupt.h>
+#include <linux/ptrace.h>
+#include <linux/ioport.h>
+#include <linux/in.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/string.h>
+#include <linux/init.h>
+#include <linux/fb.h>
+#include <linux/errno.h>
+#include <linux/wait.h>
+#include <linux/pm.h>
+
+#include "../console/fbcon.h"
+#include "../../mxc/mempool/mempool.h"
+#include <linux/timer.h>
+
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>	/* get_user,copy_to_user */
+#include <asm/irq.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/irqs.h>
+#include <asm/arch/mx27.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+
+#include <linux/devfs_fs_kernel.h>
+
+#ifdef CONFIG_ARCH_MX2ADS
+#include <asm/arch/mx2.h>
+#endif
+
+#define MODULE_NAME "slcdc"
+
+#define DBMX_DEBUG 1
+#ifdef DBMX_DEBUG
+#define TRACE(fmt, args...) \
+	{ \
+		printk("\n %s:%d:%s:",__FILE__, __LINE__,__FUNCTION__); \
+		printk(fmt, ## args);\
+	}
+#else
+#define TRACE(fmt, args...)
+#endif
+
+#define FAILED(fmt, args...) \
+	{ \
+		printk("\n %s:%d:%s:",__FILE__, __LINE__,__FUNCTION__); \
+		printk(fmt, ## args);\
+	}
+
+#define INFO(fmt, args...) \
+	{ \
+		printk("\n"); \
+		printk(fmt, ## args);\
+	}
+
+/*@brief definition for SLCDC_LCD_TXCONFIG */
+#define SLCDC_IMG_8L	0x00020000
+
+/*@name SLCDC connection configuration
+ *@brief config macro for serial mode or parallel mode. SLCDC can operate in
+ *       serial or parallel mode. This macro reflects the hardware configuration
+ *       and is not a software configuration.
+ */
+/**@{*/
+#define SLCDC_SERIAL_MODE
+/* #define SLCDC_PARALLE_MODE */
+/**@}*/
+
+/*@name SLCDC IO MUX configuration
+ *@brief configuration macro for the pin mux detail. This tells which pins are
+ *       configured for SLCDC. For more information refer processor data sheet.
+ *       Most cases only one of the following macros should be enabled.
+ */
+/**@{*/
+#define SLCDC_MUX_SSI3_SLCDC2	/*!< 1. SLCDC is mux.ed with SSI3 */
+ //#define SLCDC_MUX_SD_SLCDC1  /*!< 2. SLCDC is mux.ed with SD2 */
+ //#define SLCDC_MUX_LCD_SLCDC1 /*!< 3. SLCDC is mux.ed with LCD */
+/**@}*/
+
+/*@brief configuration macro which tells whether the interrupt should be used
+ *        or not for SLCDC. SLCDC will provide an interrupt on a completed
+ *        transfer, which can be used for refreshing the data.
+ */
+#define USING_INTERRUPT_SLCDC
+
+/**
+ *@name ioctl command macro definitions
+ *@brief definition for SLCDC ioctl cmd,these command definition is different
+ *       for serial \nmode and paralel mode ,in this driver, we have not
+ *       supported all these commands, \n please check the ioctl function for
+ *       details.
+ **/
+/**@{*/
+/* definition for SLCDC cmd */
+/* same as Epson 10043 & 50052 */
+#ifdef SLCDC_SERIAL_MODE
+#define SLCDC_CMD_DISON			0xaf00	/*!< 1. display on */
+#define SLCDC_CMD_DISOFF		0xae00	/*!< 2. display off */
+#define SLCDC_CMD_DISNOR		0xa600	/*!< 3. normal display */
+#define SLCDC_CMD_DISINV		0xa700	/*!< 4. inverse display */
+#define SLCDC_CMD_DISCTL		0xca00	/*!< 5. display control */
+#define SLCDC_CMD_SLPIN			0x9500	/*!< 10.sleep in */
+#define SLCDC_CMD_SLPOUT		0x9400	/*!< 11.sleep out */
+#define SLCDC_CMD_SD_PSET		0x7500	/*!< 12.page address set */
+#define SLCDC_CMD_SD_CSET		0x1500	/*!< 14.column address set */
+
+#define SLCDC_CMD_DATCTL		0xbc	/*!< 16.data scan direction, etc. */
+#define SLCDC_CMD_RAMWR			0x5c00	/*!< 17.writing to memory */
+#define SLCDC_CMD_PTLIN			0xa800	/*!< 19.partial display in */
+#define SLCDC_CMD_PTLOUT		0xa900	/*!< 20.partial display out */
+
+/* value different from 10043 but same as 50052 */
+#define SLCDC_CMD_VOLCTR		0xc600	/*!< 25.Electronic volume control */
+
+/* commands not found in 10043 but in 50052*/
+#define SLCDC_CMD_GCP64			0xcb00	/*!< 6. 64 grayscale pulse positon set */
+#define SLCDC_CMD_GCP16			0xcc00	/*!< 7. 16 grayscale pulse positon set */
+#define SLCDC_CMD_GSSET			0xcd00	/*!< 8. grayscale set */
+#define SLCDC_CMD_RAMRD			0x5d00	/*!< 18.memory read */
+#define SLCDC_CMD_ASCSET		0xaa00	/*!< 21.area scroll set */
+#define SLCDC_CMD_SCSTART		0xab00	/*!< 22.scroll start set */
+#define SLCDC_CMD_EPCTIN		0x6100	/*!< 26.Power IC control for EVR */
+#define SLCDC_CMD_EPCTOUT		0x6200	/*!< 27.Power IC control for EVR */
+
+#else
+#define SLCDC_CMD_DISON			0xaf	/*!<1. display on */
+#define SLCDC_CMD_DISOFF		0xae	/*!<2. display off */
+#define SLCDC_CMD_DISNOR		0xa6	/*!<3. normal display */
+#define SLCDC_CMD_DISINV		0xa7	/*!<4. inverse display */
+#define SLCDC_CMD_DISCTL		0xca	/*!<5. display control */
+#define SLCDC_CMD_SLPIN			0x95	/*!<10.sleep in */
+#define SLCDC_CMD_SLPOUT		0x94	/*!<11.sleep out */
+#define SLCDC_CMD_SD_PSET		0x75	/*!<12.page address set */
+#define SLCDC_CMD_SD_CSET		0x15	/*!<14.column address set */
+
+#define SLCDC_CMD_DATCTL		0xbc	/*!<16.data scan direction, etc. */
+//#define SLCDC_CMD_DATCTL              0xbc00  /*!<16.data scan direction, etc.*/
+#define SLCDC_CMD_RAMWR			0x5c	/*!<17.writing to memory */
+#define SLCDC_CMD_PTLIN			0xa8	/*!<19.partial display in */
+#define SLCDC_CMD_PTLOUT		0xa9	/*!<20.partial display out */
+
+/* value different from 10043 but same as 50052 */
+#define SLCDC_CMD_VOLCTR		0xc6	/*!<25.Electronic volume control */
+
+/* commands not found in 10043 but in 50052*/
+#define SLCDC_CMD_GCP64			0xcb	/*!<6. 64 grayscale pulse positon set */
+#define SLCDC_CMD_GCP16			0xcc	/*!<7. 16 grayscale pulse positon set */
+#define SLCDC_CMD_GSSET			0xcd	/*!<8. grayscale set */
+#define SLCDC_CMD_RAMRD			0x5d	/*!<18.memory read */
+#define SLCDC_CMD_ASCSET		0xaa	/*!<21.area scroll set */
+#define SLCDC_CMD_SCSTART		0xab	/*!<22.scroll start set */
+#define SLCDC_CMD_EPCTIN		0x61	/*!<26.Power IC control for EVR */
+#define SLCDC_CMD_EPCTOUT		0x62	/*!<27.Power IC control for EVR */
+#endif
+
+/**@}*/
+
+#define SLCDC_IRQ	INT_SLCDC
+#define SLCDC_CMD_MEM_SIZE		4
+#define SLCDC_WIDTH				176
+#define SLCDC_HIGH				220
+#define SLCDC_BPP				16
+#define SLCDC_PIXEL_MEM_SIZE	(SLCDC_WIDTH*SLCDC_HIGH*SLCDC_BPP)/8
+#define SLCDC_MEM_SIZE  (SLCDC_WIDTH*SLCDC_HIGH)
+#define _SLCDC_DATA_SIZE_		(SLCDC_PIXEL_MEM_SIZE + 32)
+#define SLCDC_DATA_MEM_SIZE	\
+                    ((unsigned)(PAGE_ALIGN(_SLCDC_DATA_SIZE_ + PAGE_SIZE * 2)))
+
+//bit mask definition in STAT/CTRL register
+#define SLCDC_TRANSFER_BUSY		0x4
+#define SLCDC_TRANSFER_ERROR	0x10
+
+//<<<<<< Global Variable
+/*used for SLCDC data buffer */
+__attribute__ ((aligned(4)))
+u16 *g_slcdc_dbuffer_address;
+
+/* physical address for SLCDC data buffer*/
+__attribute__ ((aligned(4)))
+u16 *g_slcdc_dbuffer_phyaddress;
+
+/* used for SLCDC command buffer */
+__attribute__ ((aligned(4)))
+u16 *g_slcdc_cbuffer_address;
+
+/* physical address for SLCDC command buffer */
+__attribute__ ((aligned(4)))
+u16 *g_slcdc_cbuffer_phyaddress;
+
+static wait_queue_head_t slcdc_wait;
+static int slcdc_device_num;
+static int g_slcdc_status;
+
+static int slcdc_major;
+module_param(slcdc_major, int, 0444);
+MODULE_PARM_DESC(slcdc_major,
+		 "slcdc char device major number. If this number is"
+		 " set to zero, then automatic major number allocation will be done");
+
+static int slcdc_minor;
+module_param(slcdc_minor, int, 0444);
+MODULE_PARM_DESC(slcdc_minor, "slcdc char device minor number");
+
+#define SLCDC_OPEN_STATUS		0x0001
+#define SLCDC_SUSPEND_STATUS	0x0002
+
+#define SLCDC_MAJOR_NUM 10	/*!< SLCDC char dev default major number */
+#define SLCDC_MINOR_NUM 156	/*!< SLCDC char dev default minor number */
+
+#define FBCON_HAS_CFB4
+#define FBCON_HAS_CFB8
+#define FBCON_HAS_CFB16
+
+static struct cdev slcdc_dev;
+
+extern void gpio_slcdc_active(int type);
+extern void gpio_slcdc_inactive(int type);
+
+int slcdc_open(struct inode *inode, struct file *filp);
+int slcdc_release(struct inode *inode, struct file *filp);
+static int slcdc_ioctl(struct inode *inode, struct file *filp,
+		       u_int cmd, u_long arg);
+static int slcdc_mmap(struct file *filp, struct vm_area_struct *vma);
+static void __init _init_fbinfo(void);
+
+typedef struct {
+	u16 *screen_start_address;
+	u16 *v_screen_start_address;
+} slcdc_par_t;
+
+slcdc_par_t slcdc_par;
+
+struct file_operations g_slcdc_fops = {
+      open:slcdc_open,
+      release:slcdc_release,
+      ioctl:slcdc_ioctl,
+      mmap:slcdc_mmap,
+};
+
+//>>>>>> Global Variable
+
+#ifdef DBMX_DEBUG
+#define FUNC_START	TRACE(KERN_ERR"start of %s\n", __FUNCTION__);
+#define FUNC_END	TRACE(KERN_ERR"end of %s\n", __FUNCTION__);
+#else
+#define FUNC_START
+#define FUNC_END
+#endif
+
+#define RED		0xf00
+#define GREEN	0xf0
+#define BLUE	0x0f
+
+/**@brief Local LCD controller parameters*/
+struct slcdcfb_par {
+	u_char *screen_start_address;	/*!< Screen Start Address */
+	u_char *v_screen_start_address;	/*!< Virtul Screen Start Address */
+	unsigned long screen_memory_size;	/*!< Screen memory size */
+	unsigned int palette_size;	/*!<Palette size */
+	unsigned int max_xres;	/*!<Maximum x resolution */
+	unsigned int max_yres;	/*!<Maximum x resolution */
+	unsigned int xres;	/*!<X resolution */
+	unsigned int yres;	/*!<Y resolution */
+	unsigned int xres_virtual;	/*!<Vitual x resolution */
+	unsigned int yres_virtual;	/*!<Vitual y resolution */
+	unsigned int max_bpp;	/*!<Maximum bit per pixel */
+	unsigned int bits_per_pixel;	/*!<Bits per pixel */
+	unsigned int currcon;	/*!<Current console ID */
+	unsigned int visual;	/*!<Vitual color type */
+	unsigned int TFT:1;	/*!<TFT flag */
+	unsigned int color:1;	/*!<Color flag */
+	unsigned int sharp:1;	/*!< Sharp LCD flag */
+};
+
+/* Frame buffer device API */
+static int slcdcfb_set_var(struct fb_info *info);
+/* perform fb specific mmap */
+static int slcdcfb_mmap(struct fb_info *info, struct file *file,
+			struct vm_area_struct *vma);
+/* perform fb specific ioctl (optional) */
+static int slcdcfb_ioctl(struct inode *inode, struct file *file,
+			 unsigned int cmd, unsigned long arg,
+			 struct fb_info *info);
+static int slcdcfb_open(struct fb_info *info, int user);
+static int slcdcfb_release(struct fb_info *info, int user);
+
+static int _check_var(struct fb_var_screeninfo *var, struct fb_info *info);
+static int _decode_var(struct fb_info *info);
+static int slcdcfb_blank(int blank, struct fb_info *info);
+
+/*
+ *  Framebuffer file operations
+ */
+static struct fb_ops slcdcfb_ops = {
+	.owner = THIS_MODULE,
+	.fb_open = slcdcfb_open,
+	.fb_release = slcdcfb_release,
+	.fb_check_var = _check_var,
+	.fb_set_par = _decode_var,
+	.fb_blank = slcdcfb_blank,
+	.fb_fillrect = cfb_fillrect,
+	.fb_copyarea = cfb_copyarea,
+	.fb_imageblit = cfb_imageblit,
+	.fb_cursor = soft_cursor,
+	.fb_ioctl = slcdcfb_ioctl,
+	.fb_mmap = slcdcfb_mmap,
+};
+
+static struct display global_disp;	/* Initial (default) Display Settings */
+static struct fb_info slcdc_fb_info;
+static struct fb_var_screeninfo init_var;
+static struct slcdcfb_par current_par;
+static struct timer_list slcdc_timer;
+static int start_fb_timer_flag = 0;	//0 is stop, 1 is start
+
+#define MIN_XRES        64
+#define MIN_YRES        64
+#define LCD_MAX_BPP		SLCDC_BPP
+#define MAX_PIXEL_MEM_SIZE SLCDC_PIXEL_MEM_SIZE
+#define SLCDC_REFRESH_RATE (HZ / 100)
+
+#define SLCDC2_CLK_PC31 31	/* refer iMX27 Pin Mux details */
+#define SLCDC2_CS_PC30  30
+#define SLCDC2_RS_PC29  29
+#define SLCDC2_D0_PC28  28
+
+#define SLCDC1_CLK_PB5 5
+#define SLCDC1_CS_PB8  8
+#define SLCDC1_RS_PB7  7
+#define SLCDC1_D0_PB6  6
+
+#define SLCDC1_DAT0_PA6 6
+
+/* Fake monspecs to fill in fbinfo structure */
+static struct fb_monspecs monspecs __initdata = {
+	.hfmin = 30000,
+	.hfmax = 70000,
+	.vfmin = 50,
+	.vfmax = 65,
+	.dpms = 0		/* Generic */
+};
+
+void slcdc_delay(int num)
+{
+	udelay(num);
+}
+
+/**
+ *@brief slcdc gpio configure routine for serial mode
+ *
+ * Function Name: slcdc_gpio_serial
+ *
+ *
+ * Description:This routine will implement gpio configurations for serial mode
+ *             both for\n LCDC mux and SDHC2 mux, you can use macro
+ *             SLCDC_MUX_SSI3_SLCDC2 or SLCDC_MUX_SD_SLCDC1 \n to choose the
+ *             right way according to your hardware configuration.
+ *
+ *
+ *@return		None
+ *
+ * Modification History:
+ * 	Dec,2003			Karen update for MX21 TO2
+ *  Jun,2004			Shirley update for LCDC mux
+ *  Mar,2006            Update for MX27 mux
+ **/
+
+void slcdc_gpio_serial(void)
+{
+#ifdef SLCDC_MUX_SSI3_SLCDC2
+	/* we have to set SLCDC2_CLK, SLCDC2_CS, SLCDC2_RS and SLCDC2_D0 */
+	//gpio_request_mux(MX27_PIN_SSI3_CLK,  GPIO_MUX_ALT); /* CLK */
+	//gpio_request_mux(MX27_PIN_SSI3_TXDAT,GPIO_MUX_ALT); /* CS  */
+	//gpio_request_mux(MX27_PIN_SSI3_RXDAT,GPIO_MUX_ALT); /* RS  */
+	//gpio_request_mux(MX27_PIN_SSI3_FS,   GPIO_MUX_ALT); /* D0  */
+	gpio_slcdc_active(0);
+
+#endif
+#ifdef SLCDC_MUX_SD_SLCDC1
+	//gpio_request_mux(MX27_PIN_SD2_D1, GPIO_MUX_GPIO); /* CLK */
+	//gpio_request_mux(MX27_PIN_SD2_D2, GPIO_MUX_GPIO); /* D0  */
+	//gpio_request_mux(MX27_PIN_SD2_D3, GPIO_MUX_GPIO); /* RS  */
+	//gpio_request_mux(MX27_PIN_SD2_CMD,GPIO_MUX_GPIO); /* CS  */
+	gpio_slcdc_active(1);
+
+#endif
+}
+
+/**
+ *@brief slcdc gpio configure routine for parallel mode
+ *
+ * Function Name: slcdc_gpio_paralle
+ *
+ *
+ * Description:This routine will implement gpio configurations for parralel
+ *             mode both for\n LCDC mux and SDHC2 mux, you can use macro
+ *             SLCDC_MUX_SSI3_SLCDC2 or SLCDC_MUX_SD_SLCDC1 \n to choose the
+ *             right way according to your hardware configuration.
+ *
+ *
+ *@return		None
+ *
+ * Modification History:
+ *  Jun,2004			Shirley update for LCDC mux
+ *  Mar,2006            Update for MX27 mux
+ **/
+#ifndef SLCDC_MUX_SSI3_SLCDC2
+void slcdc_gpio_paralle(void)
+{
+#ifdef SLCDC_MUX_LCD_SLCDC1
+	/* Make sure the actual hardware connection is based on this, if other port
+	   is used then the following code has to be modified accordingly.
+	   For further details refer Pin Mux details in iMX27 Spec. */
+	/* gpio_request_mux(MX27_PIN_LD0,  GPIO_MUX_GPIO);
+	   gpio_request_mux(MX27_PIN_LD1,  GPIO_MUX_GPIO);
+	   gpio_request_mux(MX27_PIN_LD2,  GPIO_MUX_GPIO);
+	   gpio_request_mux(MX27_PIN_LD3,  GPIO_MUX_GPIO);
+	   gpio_request_mux(MX27_PIN_LD4,  GPIO_MUX_GPIO);
+	   gpio_request_mux(MX27_PIN_LD5,  GPIO_MUX_GPIO);
+	   gpio_request_mux(MX27_PIN_LD6,  GPIO_MUX_GPIO);
+	   gpio_request_mux(MX27_PIN_LD7,  GPIO_MUX_GPIO);
+	   gpio_request_mux(MX27_PIN_LD8,  GPIO_MUX_GPIO);
+	   gpio_request_mux(MX27_PIN_LD9,  GPIO_MUX_GPIO);
+	   gpio_request_mux(MX27_PIN_LD10, GPIO_MUX_GPIO);
+	   gpio_request_mux(MX27_PIN_LD11, GPIO_MUX_GPIO);
+	   gpio_request_mux(MX27_PIN_LD12, GPIO_MUX_GPIO);
+	   gpio_request_mux(MX27_PIN_LD13, GPIO_MUX_GPIO);
+	   gpio_request_mux(MX27_PIN_LD14, GPIO_MUX_GPIO);
+	   gpio_request_mux(MX27_PIN_LD15, GPIO_MUX_GPIO);
+	 */
+	gpio_slcdc_active(2);
+
+#endif
+}
+#endif
+
+void slcdc_reset(int level)
+{
+	if (level == 0) {
+#if 0
+#ifdef SLCDC_MUX_SSI3_SLCDC2
+		/* OE_ACD as a reset pin */
+		_reg_GPIO_GIUS(GPIOA) |= 0x80000000;
+		_reg_GPIO_OCR2(GPIOA) |= 0xc0000000;
+		_reg_GPIO_DDIR(GPIOA) |= 0x80000000;
+
+		/* set reset pin to low */
+		_reg_GPIO_DR(GPIOA) &= 0x7fffffff;
+#endif
+#ifdef SLCDC_MUX_SD_SLCDC1
+		/* SD2_D1 as reset pin */
+		_reg_GPIO_GIUS(GPIOB) |= 0x00000020;
+		_reg_GPIO_OCR1(GPIOB) |= 0x00000c00;
+		_reg_GPIO_DDIR(GPIOB) |= 0x00000020;
+
+		/* set reset pin to low */
+		_reg_GPIO_DR(GPIOB) &= 0xffffffdf;
+#endif
+	} else {
+#ifdef SLCDC_MUX_SSI3_SLCDC2
+		/* set reset pin to high */
+		_reg_GPIO_DR(GPIOA) |= 0x80000000;
+#endif
+#ifdef SLCDC_MUX_SD_SLCDC1
+		/* set reset pin to high */
+		_reg_GPIO_DR(GPIOB) |= 0x00000020;
+#endif
+#endif
+	}
+
+}
+
+/**
+ *@brief slcdc hardware initialization
+ *
+ * Function Name: slcdc_init_dev
+ *
+ * Description  : This routine will enable the SLCDC and the clock for it
+ *
+ **/
+void slcdc_init_dev(void)
+{
+	volatile unsigned long reg;
+
+	reg = __raw_readl(IO_ADDRESS(MAX_BASE_ADDR + 0x100 * 3 + 0x10));
+	reg = reg | 0x00040000;
+	__raw_writel(reg, IO_ADDRESS(MAX_BASE_ADDR + 0x100 * 3 + 0x10));
+
+	reg = __raw_readl(IO_ADDRESS(SYSCTRL_BASE_ADDR + 0x58));	/* _reg_SYS_PCSR */
+	reg = reg | 0x00000004;	/* set LCD/SLCD bus master high priority */
+	__raw_writel(reg, IO_ADDRESS(SYSCTRL_BASE_ADDR + 0x58));
+
+	/* enable the slcd clk */
+	reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR + 0x20));	/* _reg_CRM_PCCR0 */
+	reg |= 0x02200000;
+	__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR + 0x20));
+}
+
+/**
+ *@brief slcdc register initialization
+ *
+ * Function Name: slcdc_init_reg
+ *
+ * Description:This routine will setup the SLCDC register for first time
+ *
+ **/
+void slcdc_init_reg(void)
+{
+	__raw_writel(0, IO_ADDRESS(SLCDC_BASE_ADDR + 0x00));	/* _reg_SLCDC_DBADDR */
+	__raw_writel(0, IO_ADDRESS(SLCDC_BASE_ADDR + 0x04));	/* _reg_SLCDC_DBUF_SIZE */
+	__raw_writel(0, IO_ADDRESS(SLCDC_BASE_ADDR + 0x08));	/* _reg_SLCDC_CBADDR */
+	__raw_writel(0, IO_ADDRESS(SLCDC_BASE_ADDR + 0x0C));	/* _reg_SLCDC_CBUF_SIZE */
+	__raw_writel(0, IO_ADDRESS(SLCDC_BASE_ADDR + 0x10));	/* _reg_SLCDC_CBUF_SSIZE */
+	__raw_writel(0, IO_ADDRESS(SLCDC_BASE_ADDR + 0x14));	/* _reg_SLCDC_FIFO_CONFIG */
+	__raw_writel(0, IO_ADDRESS(SLCDC_BASE_ADDR + 0x18));	/* _reg_SLCDC_LCD_CONFIG */
+	__raw_writel(0, IO_ADDRESS(SLCDC_BASE_ADDR + 0x1C));
+						     /*_reg_SLCDC_LCD_TXCONFIG*/
+	__raw_writel(0, IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+						    /*_reg_SLCDC_LCD_CTRL_STAT*/
+	__raw_writel(0, IO_ADDRESS(SLCDC_BASE_ADDR + 0x24));
+						    /*_reg_SLCDC_LCD_CLKCONFIG*/
+}
+
+/**
+ *@brief slcdc initial configuration
+ *
+ * Function Name: slcdc_config
+ *
+ * Description:This routine will fist time configuration like buffer address
+ *             FIFO configuration etc.
+ *
+ **/
+void slcdc_config(int datlen)
+{
+	u32 xfrmode, sckpol, worddefcom, imgend = 0, worddefwrite =
+	    0, worddefdat = 0;
+	volatile unsigned long reg;
+
+	if (datlen == 8) {
+		imgend = 0x2;	/*8-bit little endian; */
+		worddefdat = 0;	/* 8-bit data */
+		worddefwrite = 10;
+	} else if (datlen == 16) {
+		imgend = 0x1;	/* 16-bit little endian; */
+		worddefdat = 1;	/* 16-bit data */
+		worddefwrite = 1;
+	} else {
+		FAILED(":invaild parameter, 8 or 16 is the value required");
+	}
+	worddefcom = 1;
+#ifdef SLCDC_SERIAL_MODE
+	xfrmode = 0;		/* serial mode */
+#else
+	xfrmode = 1;		/* paralle mode */
+#endif
+	sckpol = 1;		/* falling edge */
+	/* config to be little endian serial 16bit */
+	reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x1C));
+						       /*_reg_SLCDC_LCD_TXCONFIG*/
+	reg =
+	    (imgend << 16) | (worddefdat << 4) | (worddefcom << 3) | (xfrmode <<
+								      2) |
+	    (sckpol);
+	__raw_writel(reg, IO_ADDRESS(SLCDC_BASE_ADDR + 0x1C));
+
+	/* printk("SLCDC_TXCONFIG = %x \n",_reg_SLCDC_LCD_TXCONFIG); */
+	/* config dma setting */
+	__raw_writel(5, IO_ADDRESS(SLCDC_BASE_ADDR + 0x14));	/* _reg_SLCDC_FIFO_CONFIG,
+								   burst length is 4 32-bit words */
+	/* config buffer address setting */
+	__raw_writel((u32) (slcdc_par.screen_start_address), IO_ADDRESS(SLCDC_BASE_ADDR + 0x00));	/* _reg_SLCDC_DBADDR */
+	__raw_writel((u32) g_slcdc_cbuffer_phyaddress, IO_ADDRESS(SLCDC_BASE_ADDR + 0x08));	/* _reg_SLCDC_CBADDR */
+
+	/* config clk setting */
+	__raw_writel((u32) 0x3, IO_ADDRESS(SLCDC_BASE_ADDR + 0x24));
+						   /*_reg_SLCDC_LCD_CLKCONFIG*/
+	/* set GO 0 */
+	__raw_writel((u32) 0x0, IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+						   /*_reg_SLCDC_LCD_CTRL_STAT*/
+
+	slcdc_delay(5000);
+
+}
+
+/**
+ *@brief slcdc send command routine
+ *
+ * Function Name: slcdc_send_cmd
+ *
+ * Description:This help routine sends command to the SLCD from SLCDC
+ *
+ *@return		0 on success, any other value otherwise
+ **/
+/* for command transfer, it is very short, will not use interrupt */
+int slcdc_send_cmd(u32 length)
+{
+	u32 status;
+	volatile unsigned long reg;
+
+	/* disable interrupt */
+	reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+					       /*_reg_SLCDC_LCD_CTRL_STAT*/
+	reg = reg & 0xffffff7f;
+	__raw_writel(reg, IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+
+	/* set length */
+	__raw_writel(length, IO_ADDRESS(SLCDC_BASE_ADDR + 0x04));	/* _reg_SLCDC_DBUF_SIZE */
+
+	/* set automode 00 for command */
+	reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));	/* _reg_SLCDC_LCD_CTRL_STAT */
+	reg = reg & 0x000001ff;
+	__raw_writel(reg, IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+
+	/* set GO */
+	reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));	/* _reg_SLCDC_LCD_CTRL_STAT */
+	reg |= 0x1;
+	__raw_writel(reg, IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+
+	/* polling for data transfer finish */
+
+	status = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));	/* _reg_SLCDC_LCD_CTRL_STAT */
+	while ((!(status & SLCDC_TRANSFER_ERROR))
+	       && (status & SLCDC_TRANSFER_BUSY)) {
+		status = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));	/* _reg_SLCDC_LCD_CTRL_STAT */
+	}
+
+	if (status & SLCDC_TRANSFER_ERROR) {
+		TRACE("send cmd error status=0x%x \n", status);
+		return 1;
+	} else {
+		reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));	/* _reg_SLCDC_LCD_CTRL_STAT */
+		reg |= 0x40;
+		__raw_writel(reg, IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+
+		reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));	/* _reg_SLCDC_LCD_CTRL_STAT */
+		reg |= 0x20;
+		__raw_writel(reg, IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+		return 0;
+	}
+}
+
+/**
+ *@brief slcdc send data routine
+ *
+ * Function Name: slcdc_send_data
+ *
+ * Description: This help routine sends data to the SLCD from SLCDC
+ *
+ *@return		0 on success, any other value otherwise
+ **/
+void slcdc_send_data(u32 length)
+{
+	volatile unsigned long reg;
+
+	/* enable interrupt */
+#ifdef USING_INTERRUPT_SLCDC
+	reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+						    /*_reg_SLCDC_LCD_CTRL_STAT*/
+	reg |= ~0xffffff7f;
+	__raw_writel(reg, IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+#endif
+	/* set length */
+	__raw_writel(length, IO_ADDRESS(SLCDC_BASE_ADDR + 0x04));	/* _reg_SLCDC_DBUF_SIZE */
+	/* set automode 01 for data */
+	reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+						    /*_reg_SLCDC_LCD_CTRL_STAT*/
+	reg |= 0x00000800;
+	__raw_writel(reg, IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+
+	/* set GO  */
+	reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+						    /*_reg_SLCDC_LCD_CTRL_STAT*/
+	reg |= 0x1;
+	__raw_writel(reg, IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+
+#ifdef USING_INTERRUPT_SLCDC
+	interruptible_sleep_on(&slcdc_wait);
+#else
+	do {
+		reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+						    /*_reg_SLCDC_LCD_CTRL_STAT*/
+	} while ((reg & 0x00000004) != 0);
+
+	reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+						    /*_reg_SLCDC_LCD_CTRL_STAT*/
+	reg |= 0x40;
+	__raw_writel(reg, IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+
+	reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+						    /*_reg_SLCDC_LCD_CTRL_STAT*/
+	reg |= 0x20;
+	__raw_writel(reg, IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+
+#endif
+	return;
+
+}
+
+/**
+ *@brief slcdc isr
+ *
+ * Function Name: slcdc_isr
+ *
+ * Description: This ISR routine takes interrupt from SLCDC and does refresh of
+ *              display data if necessary
+ *
+ *@return		0 on success, any other value otherwise
+ **/
+static irqreturn_t slcdc_isr(int irq, void *dev_id)
+{
+	volatile u32 reg;
+	reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+						    /*_reg_SLCDC_LCD_CTRL_STAT*/
+
+	/* clear interrupt */
+	reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+						    /*_reg_SLCDC_LCD_CTRL_STAT*/
+	reg |= 0x40;
+	__raw_writel(reg, IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+
+	wake_up_interruptible(&slcdc_wait);
+
+	if (start_fb_timer_flag == 1) {
+		/*        while((_reg_SLCDC_LCD_CTRL_STAT &0x00000004)!=0);        */
+		reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+						    /*_reg_SLCDC_LCD_CTRL_STAT*/
+		reg |= 0x40;
+		__raw_writel(reg, IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+
+		reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+						    /*_reg_SLCDC_LCD_CTRL_STAT*/
+		reg |= 0x20;
+		__raw_writel(reg, IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+		mod_timer(&slcdc_timer, jiffies + SLCDC_REFRESH_RATE);
+		TRACE("slcdc_isr\n");
+	}
+
+	return IRQ_HANDLED;
+}
+
+/**
+ *@brief slcdc buffer initialization
+ *
+ * Function Name: slcdc_init_buffer
+ *
+ *
+ * Description:This routine will allocate physical memory for SLCDC data and
+ *             for SLCDC command.
+ *
+ *@return		0 on success, appropriate error value on error
+ **/
+int slcdc_init_buffer(void)
+{
+
+	TRACE("slcdc data buffer size = %x \n",
+	      (unsigned int)SLCDC_DATA_MEM_SIZE);
+
+	if (g_slcdc_dbuffer_phyaddress != NULL)
+		return -EINVAL;
+
+	if (g_slcdc_cbuffer_phyaddress != NULL)
+		return -EINVAL;
+
+	g_slcdc_dbuffer_phyaddress = (u16 *) mxc_malloc(SLCDC_DATA_MEM_SIZE);
+	g_slcdc_cbuffer_phyaddress = (u16 *) mxc_malloc(SLCDC_CMD_MEM_SIZE);
+
+	if (!g_slcdc_dbuffer_phyaddress || !g_slcdc_cbuffer_phyaddress) {
+		if (g_slcdc_dbuffer_phyaddress != (u16 *) 0)
+			mxc_free((u32) g_slcdc_dbuffer_phyaddress);
+
+		if (g_slcdc_cbuffer_phyaddress != (u16 *) 0)
+			mxc_free((u32) g_slcdc_cbuffer_phyaddress);
+
+		FAILED("can not allocated memory\n");
+		return -ENOMEM;
+	} else {
+
+		TRACE
+		    ("allocated cmd_buffer=0x%x size=%d, data_buffer=0x%x size=%d",
+		     (int)g_slcdc_cbuffer_phyaddress, SLCDC_CMD_MEM_SIZE,
+		     (int)g_slcdc_dbuffer_phyaddress, SLCDC_DATA_MEM_SIZE);
+
+		if ((!request_mem_region((u32) g_slcdc_dbuffer_phyaddress,
+					 SLCDC_DATA_MEM_SIZE,
+					 slcdc_fb_info.fix.id))
+		    ||
+		    (!request_mem_region
+		     ((u32) g_slcdc_cbuffer_phyaddress, SLCDC_CMD_MEM_SIZE,
+		      slcdc_fb_info.fix.id))) {
+			FAILED("request mem region failed.");
+			return -EBUSY;
+		}
+
+		if (!(slcdc_fb_info.screen_base = ioremap((u32)
+							  g_slcdc_dbuffer_phyaddress,
+							  SLCDC_DATA_MEM_SIZE)))
+		{
+			release_mem_region((u32) g_slcdc_dbuffer_phyaddress,
+					   SLCDC_DATA_MEM_SIZE);
+			FAILED("Unable to map fb memory to virtual address");
+			return -EIO;
+		} else {
+			g_slcdc_dbuffer_address =
+			    (u16 *) slcdc_fb_info.screen_base;
+		}
+
+		if (!
+		    (g_slcdc_cbuffer_address =
+		     ioremap((u32) g_slcdc_cbuffer_phyaddress,
+			     SLCDC_CMD_MEM_SIZE))) {
+			release_mem_region((u32) g_slcdc_dbuffer_phyaddress,
+					   SLCDC_DATA_MEM_SIZE);
+			release_mem_region((u32) g_slcdc_cbuffer_phyaddress,
+					   SLCDC_CMD_MEM_SIZE);
+			FAILED("Unable to map fb memory to virtual address");
+			return -EIO;
+		}
+	}
+
+	TRACE("slcdc data buffer address = %x cmd buffer address= %x \n",
+	      (unsigned int)slcdc_par.screen_start_address,
+	      (unsigned int)g_slcdc_cbuffer_address);
+
+	return 0;
+}
+
+/**
+ *@brief slcdc buffer de initialization
+ *
+ * Function Name: slcdc_free_buffer
+ *
+ *
+ * Description:This routine will deallocate the physical memory allocated by
+ *             slcdc_init_buffer.
+ *
+ *@return		0 on success
+ **/
+int slcdc_free_buffer(void)
+{
+
+	FUNC_START;
+
+	iounmap(g_slcdc_dbuffer_address);
+	iounmap(g_slcdc_cbuffer_address);
+
+	release_mem_region((unsigned long)g_slcdc_dbuffer_phyaddress,
+			   SLCDC_DATA_MEM_SIZE);
+	release_mem_region((unsigned long)g_slcdc_cbuffer_phyaddress,
+			   SLCDC_CMD_MEM_SIZE);
+
+	mxc_free((u32) g_slcdc_dbuffer_phyaddress);
+	mxc_free((u32) g_slcdc_cbuffer_phyaddress);
+
+	FUNC_END;
+	return 0;
+}
+
+/**
+ *@brief slcdc mmap function
+ *
+ * Function Name: slcdc_mmap
+ *
+ *
+ * Description: This is the memory map routine for this driver,will setup the
+ *              memory map used in this driver.
+ *
+ *@param	filp	the pointer to the file descripter
+ *@param	vma		the pointer to the vma structure related to the driver
+ *
+ *@return	int   return status
+ *			@li 0  sucessful
+ *			@li other failed
+ * Modification History:
+ * 	Dec,2003,			Karen first version
+ *
+ **/
+
+static int slcdc_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+	unsigned long page, pos;
+	unsigned long start = (unsigned long)vma->vm_start;
+	unsigned long size = (unsigned long)(vma->vm_end - vma->vm_start);
+
+	if (size > SLCDC_DATA_MEM_SIZE)
+		return -EINVAL;
+
+	TRACE("slcdc_mmap is called 1\n");
+	pos = (unsigned long)slcdc_par.v_screen_start_address;
+
+	while (size > 0) {
+		page = virt_to_phys((void *)pos);
+
+		vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+		/* This is an IO map - tell maydump to skip this VMA  */
+		vma->vm_flags |= VM_IO;
+
+		if (remap_pfn_range
+		    (vma, start, page >> PAGE_SHIFT, PAGE_SIZE, PAGE_SHARED))
+			return -EAGAIN;
+		start += PAGE_SIZE;
+		pos += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+
+	return 0;
+}
+
+/**
+ *@brief slcdc mmap function called from framebuffer
+ *
+ * Function Name: slcdcfb_mmap
+ *
+ *
+ * Description: This is the memory map routine for this driver,will setup the
+ *              memory map used in this driver.
+ *
+ *@return		0 on success any other value for failure
+ **/
+static int slcdcfb_mmap(struct fb_info *info, struct file *file,
+			struct vm_area_struct *vma)
+{
+
+	return slcdc_mmap(file, vma);
+
+}
+
+/**
+ *@brief slcdc display-on function
+ *
+ * Function Name: slcdc_display_on
+ *
+ * Description:This helper routine will send the command to the SLCD for display
+ *             on.
+ *
+ **/
+void slcdc_display_on(void)
+{
+	u16 *databuffer = NULL;
+
+	__raw_writel((u32) g_slcdc_cbuffer_phyaddress,
+		     IO_ADDRESS(SLCDC_BASE_ADDR + 0x00));
+
+	/* put cmd into cmd buffer */
+	databuffer = g_slcdc_cbuffer_address;
+	/* put cmd into cmd buffer */
+	*databuffer = SLCDC_CMD_DISON;
+	/* send cmd */
+	slcdc_send_cmd(1);
+	/* delay */
+	slcdc_delay(0xffff);
+	/* send cmd */
+	slcdc_send_cmd(1);
+	/* delay  */
+	slcdc_delay(0xffff);
+}
+
+/**
+ *@brief slcdc display-off function
+ *
+ * Function Name: slcdc_display_off
+ *
+ * Description:This helper routine will send the command to the SLCD for display
+ *             off.
+ *
+ **/
+void slcdc_display_off(void)
+{
+	u16 *databuffer = NULL;
+	/* Cause LCD module to enter sleep mode.Bu sure to input display OFF command
+	   to turn off the display before inputting the SLPIN command
+	   Keep the logic power supply turned on for 40ms after the LCD module
+	   enters the sleep mode.  */
+	/* put cmd into cmd buffer */
+	databuffer = slcdc_par.v_screen_start_address;
+	/* send cmd SLPIN */
+	*databuffer = SLCDC_CMD_SLPIN;
+	slcdc_send_cmd(1);
+	/* put reset high */
+
+#if 0
+#ifdef SLCDC_MUX_SSI3_SLCDC2
+	/* set reset pin to high */
+	_reg_GPIO_DR(GPIOA) |= 0x80000000;
+#endif
+#ifdef SLCDC_MUX_SD_SLCDC1
+	/* set reset pin to high */
+	_reg_GPIO_DR(GPIOB) |= 0x00000020;
+#endif
+#endif
+
+	/* delay      for 50ms */
+	slcdc_delay(0xffff);
+	/* put cmd into cmd buffer */
+	*databuffer = SLCDC_CMD_DISOFF;
+	/* send cmd DISOFF */
+	slcdc_send_cmd(1);
+	TRACE("disoff \n");
+	slcdc_delay(0xffff);
+}
+
+/**
+ *@brief slcdc display-off function
+ *
+ * Function Name: slcdc_display_normal
+ *
+ * Description:This helper routine will send the command to the SLCD for display
+ *             normal.
+ *
+ **/
+void slcdc_display_normal(void)
+{
+	u16 *databuffer = NULL;
+	databuffer = slcdc_par.v_screen_start_address;
+	*databuffer = SLCDC_CMD_DISNOR;
+	/* send cmd */
+	slcdc_send_cmd(1);
+	/* delay */
+	slcdc_delay(100);
+}
+
+/**
+ *@brief slcdc display sleep out function
+ *
+ * Function Name: slcdc_sleep_out
+ *
+ * Description:This helper routine will send the command to the SLCD for wakeup
+ *             from sleep.
+ *
+ **/
+void slcdc_sleep_out(void)
+{
+	u16 *databuffer = NULL;
+	databuffer = slcdc_par.v_screen_start_address;
+	*databuffer = SLCDC_CMD_SLPOUT;
+	/* send cmd */
+	slcdc_send_cmd(1);
+	/* delay */
+	slcdc_delay(0xffff);
+}
+
+/** @brief sends control command to SLCD */
+void slcdc_display_ctl(void)
+{
+	int i;
+#ifdef SLCDC_SERIAL_MODE
+	u16 disctl[11] = { 0x1c00, 0x0200, 0x8200, 0x0000,
+		0x1e00, 0xe000, 0x0000, 0xdc00,
+		0x0000, 0x0200, 0x0000
+	};
+#else
+	u16 disctl[11] = { 0x1c, 0x02, 0x82, 0x00,
+		0x1e, 0xe0, 0x00, 0xdc,
+		0x00, 0x02, 0x00
+	};
+#endif
+	u16 *databuffer = NULL;
+	/* It make various display timing settings. */
+	databuffer = slcdc_par.v_screen_start_address;
+	/* put cmd into cmd buffer */
+	*databuffer = SLCDC_CMD_DISCTL;
+	/* send cmd */
+	slcdc_send_cmd(1);
+	slcdc_delay(2000);
+	/* put parameter into data buffer */
+	for (i = 0; i < 11; i++) {
+		*databuffer = disctl[i];
+		databuffer++;
+	}
+	/* send data */
+	slcdc_send_data(11);
+
+}
+
+/**
+ *@brief slcd page set function
+ *
+ * Function Name: slcdc_page_set
+ *
+ * Description:This helper routine will send the command to the SLCD to set the
+ *             page inside video ram
+ *
+ **/
+void slcdc_page_set(void)
+{
+	/* It specify a page address area in order to access the display data
+	   RAM from the MPU. Be sure to set both starting and ending pages. */
+	int i;
+	u16 *databuffer = NULL;
+#ifdef SLCDC_SERIAL_MODE
+	u16 pset[4] = { 0x0000, 0x0000, 0xb100, 0x0000 };
+#else
+	u16 pset[4] = { 0x00, 0x00, 0xb1, 0x00 };
+#endif
+	databuffer = (u16 *) (slcdc_par.v_screen_start_address);
+	/* put cmd into cmd buffer */
+	*databuffer = SLCDC_CMD_SD_PSET;
+	/* send cmd */
+	slcdc_send_cmd(1);
+	slcdc_delay(20000);
+
+	/* put parameter into data buffer */
+	for (i = 0; i < 4; i++) {
+		*databuffer = pset[i];
+		databuffer++;
+	}
+	/* send data */
+	slcdc_send_data(4);
+
+	slcdc_delay(20000);
+}
+
+/**
+ *@brief slcd column set function
+ *
+ * Function Name: slcdc_col_set
+ *
+ * Description:This helper routine will send the command to the SLCD to set the
+ *             column inside video ram
+ *
+ **/
+void slcdc_col_set(void)
+{
+	/* It specify starting and ending collumns. */
+	int i;
+#ifdef SLCDC_SERIAL_MODE
+	u16 cset[4] = { 0x0200, 0x0000, 0xb100, 0x0000 };
+#else
+	u16 cset[4] = { 0x02, 0x00, 0xb1, 0x00 };
+#endif
+	u16 *databuffer = NULL;
+	databuffer = (u16 *) (slcdc_par.v_screen_start_address);
+	/* put cmd into cmd buffer */
+	*databuffer = SLCDC_CMD_SD_CSET;
+	/* send cmd */
+	slcdc_send_cmd(1);
+	slcdc_delay(20000);
+	/* put parameter into data buffer */
+	for (i = 0; i < 4; i++) {
+		*databuffer = cset[i];
+		databuffer++;
+	}
+	/* send data */
+	slcdc_send_data(4);
+	slcdc_delay(20000);
+
+}
+
+void slcdc_data_ctl(void)
+{
+	u8 *databuffer = NULL;
+	databuffer = (u8 *) (slcdc_par.v_screen_start_address);
+	*databuffer = SLCDC_CMD_DATCTL;
+	/* send cmd */
+	slcdc_send_cmd(1);
+	slcdc_delay(20000);
+	*databuffer = 0x28;
+	/* send data */
+	slcdc_send_data(1);
+	slcdc_delay(20000);
+}
+
+void slcdc_volctl(void)
+{
+	u16 *databuffer = NULL;
+	databuffer = slcdc_par.v_screen_start_address;
+	*databuffer = SLCDC_CMD_VOLCTR;
+	/* send cmd */
+	slcdc_send_cmd(1);
+	slcdc_delay(20000);
+#ifdef SLCDC_SERIAL_MODE
+	*databuffer = 0x9f00;
+#else
+	*databuffer = 0x9f;
+#endif
+	/* send data */
+	slcdc_send_data(1);
+	slcdc_delay(20000);
+}
+
+void slcdc_ascset(void)
+{
+	int i;
+#ifdef SLCDC_SERIAL_MODE
+	u16 lcd_para_ASCSET[7] = { 0x0000, 0x0000, 0x1f00, 0x0100,
+		0x1f00, 0x0100, 0x0300
+	};
+#else
+	u16 lcd_para_ASCSET[7] = { 0x00, 0x00, 0x1f, 0x01,
+		0x1f, 0x01, 0x03
+	};
+
+#endif
+	u16 *databuffer = NULL;
+	databuffer = (u16 *) (slcdc_par.v_screen_start_address);
+	/* put cmd into cmd buffer */
+	*databuffer = SLCDC_CMD_ASCSET;
+	/* put parameter into data buffer */
+	/* send cmd */
+	slcdc_send_cmd(1);
+	slcdc_delay(2000);
+	for (i = 0; i < 7; i++) {
+		*databuffer = lcd_para_ASCSET[i];
+		databuffer++;
+	}
+	/* send data */
+	slcdc_send_data(7);
+	slcdc_delay(20000);
+}
+
+void slcdc_scstart(void)
+{
+	int i;
+	u16 lcd_para_SCSTART[2] = { 0x00, 0x00 };
+	u16 *databuffer = NULL;
+	databuffer = (u16 *) (slcdc_par.v_screen_start_address);
+	/* put cmd into cmd buffer */
+	*databuffer = SLCDC_CMD_SCSTART;
+	/* put parameter into data buffer */
+	/* send cmd */
+	slcdc_send_cmd(1);
+	slcdc_delay(10000);
+	for (i = 0; i < 2; i++) {
+		*databuffer = lcd_para_SCSTART[i];
+		databuffer++;
+	}
+	/* send data */
+	slcdc_send_data(2);
+	slcdc_delay(20000);
+
+}
+
+void slcdc_config_panel(void)
+{
+	int i;
+#if 1
+	/* set data format */
+	slcdc_config(8);
+	slcdc_delay(0xffff);
+	slcdc_reset(1);		/* pull reset signal high */
+
+	/* set data format */
+	slcdc_delay(20000);
+	slcdc_data_ctl();
+	slcdc_delay(1000);
+	slcdc_config(16);
+
+	/* sleep out */
+	slcdc_sleep_out();
+	slcdc_delay(20000);
+
+	for (i = 0; i < 8; i++) {
+		slcdc_volctl();
+		slcdc_delay(2000);
+	}
+	slcdc_delay(0xffff);
+	slcdc_delay(0xffff);
+	slcdc_delay(0xffff);
+
+	slcdc_display_on();
+	slcdc_delay(0xffff);
+	/* set col address */
+	slcdc_col_set();
+	/* set page address */
+	slcdc_page_set();
+	/* set area in screen to be used for scrolling */
+	slcdc_ascset();
+	slcdc_delay(20000);
+	/* set top scroll page within the scroll area */
+	slcdc_scstart();
+	mdelay(4);
+#endif
+#if 0
+
+	//set data format
+	slcdc_config(8);
+	slcdc_delay(0xffff);
+	slcdc_reset(1);		//pull reset signal high
+
+	//set data format
+	slcdc_delay(20000);
+	slcdc_data_ctl();
+	slcdc_delay(1000);
+	slcdc_config(16);
+	//sleep out
+	slcdc_sleep_out();
+	slcdc_delay(0xffff);
+	//set col address
+	slcdc_col_set();
+	//set page address
+	slcdc_page_set();
+	//set area in screen to be used for scrolling
+	slcdc_ascset();
+	slcdc_delay(20000);
+	//set top scroll page within the scroll area
+	slcdc_scstart();
+	slcdc_delay(0xffff);
+	//turn on slcd display
+	slcdc_display_on();
+	slcdc_delay(0xffff);
+	slcdc_delay(0xffff);
+
+	for (i = 0; i < 8; i++) {
+		slcdc_volctl();
+		slcdc_delay(2000);
+	}
+#endif
+}
+
+/**
+ *@brief slcdc ioctl routine
+ *
+ * Function Name: slcdc_ioctl
+ * Description:This routine will implement driver-specific functions
+ *
+ *@param 		inode	:	the pointer to driver-related inode.
+ *@param 		filp	:	the pointer to driver-related file structure.
+ *@param		cmd	:	the command number.
+ *@param		arg:	argument which depends on command.
+ *
+ *@return	int   return status
+ *			@li 0  sucess
+ *			@li 1  failure
+ *
+ * Modification History:
+ * 	Dec,2003			Karen first version for MX21 TO2
+ *
+ **/
+
+static int slcdc_ioctl(struct inode *inode, struct file *filp,
+		       u_int cmd, u_long arg)
+{
+	u16 *databuffer = NULL;
+
+	switch (cmd) {
+	case SLCDC_CMD_DISON:
+		slcdc_display_on();
+		break;
+
+	case SLCDC_CMD_DISOFF:
+		slcdc_display_off();
+		break;
+
+	case SLCDC_CMD_DISNOR:
+		slcdc_display_normal();
+		break;
+
+	case SLCDC_CMD_DISINV:
+		/* put cmd into cmd buffer */
+		databuffer = slcdc_par.v_screen_start_address;
+		*databuffer = SLCDC_CMD_DISINV;
+		/* send cmd */
+		slcdc_send_cmd(1);
+		slcdc_delay(100);
+		break;
+
+	case SLCDC_CMD_DATCTL:
+		break;
+
+	case SLCDC_CMD_RAMWR:
+		/* Causes the MPU to be a data entry mode,allowing it to serite data
+		   in the display memory. Inputting any other cmds other than NOP
+		   cancels the data entry mode. */
+
+		__raw_writel((u32) g_slcdc_cbuffer_phyaddress, IO_ADDRESS(SLCDC_BASE_ADDR + 0x00));	/* _reg_SLCDC_DBADDR */
+
+		/* put cmd into cmd buffer */
+		databuffer = g_slcdc_cbuffer_address;
+		/* put cmd into cmd buffer */
+		*databuffer = SLCDC_CMD_RAMWR;
+		/* send cmd */
+		slcdc_send_cmd(1);
+		slcdc_delay(2000);
+
+		/* this is to display one data per time, it is ok.  */
+		slcdc_delay(0xffff);
+		__raw_writel((u32) slcdc_par.screen_start_address, IO_ADDRESS(SLCDC_BASE_ADDR + 0x00));	/* _reg_SLCDC_DBADDR */
+
+		slcdc_delay(0xffff);
+		slcdc_send_data(SLCDC_MEM_SIZE);
+		slcdc_delay(0xffff);
+
+		break;
+
+	case SLCDC_CMD_RAMRD:
+		break;
+
+	case SLCDC_CMD_PTLIN:
+		/* This command is used to display a partial screen for power saving. */
+		break;
+
+	case SLCDC_CMD_PTLOUT:
+		/* This command is used to exit the partila diaplay mode. */
+		break;
+
+	case SLCDC_CMD_GCP64:
+		/* make 63 pulse position settings of GCP for 64 gray scales. */
+		/* send cmd into cmd buffer
+		   send parameter into data buffer
+		   send cmd
+		   send data  */
+		break;
+
+	case SLCDC_CMD_GCP16:
+		break;
+
+	case SLCDC_CMD_GSSET:
+		break;
+
+	case SLCDC_CMD_ASCSET:
+		/* make partial screen scroll settings. */
+		/* send cmd into cmd buffer
+		   send parameter into data buffer
+		   send cmd
+		   delay
+		   send data
+		   delay */
+		break;
+
+	case SLCDC_CMD_SCSTART:
+		/* set a scroll starting page in the scrolling area.Be sure to send
+		   this cmd after ASCSET . */
+		/* send cmd into cmd buffer
+		   send parameter into data buffer
+		   send cmd
+		   delay
+		   send data
+		   delay */
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static int slcdcfb_ioctl(struct inode *inode, struct file *file,
+			 unsigned int cmd, unsigned long arg,
+			 struct fb_info *info)
+{
+	return slcdc_ioctl(inode, file, cmd, arg);
+}
+
+/**
+ *@brief slcdc close function
+ *
+ * Function Name: slcdc_release
+ *
+ *
+ * Description: This is the release routine for the driver. And this function \n
+ *	   will be called while the module being closed. In this function, it will\n
+ *	   unregister the apm
+ *
+ *@param	inode the pointer to the inode descripter
+ *@param	filp  the pointer to the file descripter
+ *
+ *@return	int   return status
+ *			@li 0  sucessful
+ *			@li other failed
+ * Modification History:
+ * 	Dec,2003			Karen first version
+ *
+ **/
+
+int slcdc_release(struct inode *inode, struct file *filp)
+{
+	TRACE("slcdc_release: ----\n");
+	del_timer_sync(&slcdc_timer);
+	return 0;
+}
+
+/**
+ *@brief slcdc timer call back function
+ *
+ * Function Name: slcdc_timer_func
+ *
+ * Description:This helper routine prepare the SLCDC for data transfer
+ *
+ **/
+static void slcdc_timer_func(unsigned long args)
+{
+	volatile unsigned long reg;
+	/* Causes the MPU to be a data entry mode,allowing it to serite data in the
+	   display memory. Inputting any other cmds other than NOP cancels the data
+	   entry mode. */
+
+	__raw_writel((u32) g_slcdc_cbuffer_phyaddress, IO_ADDRESS(SLCDC_BASE_ADDR + 0x00));	/* _reg_SLCDC_DBADDR */
+
+	/* put cmd into cmd buffer */
+	*g_slcdc_cbuffer_address = SLCDC_CMD_RAMWR;
+	/* send cmd */
+	slcdc_send_cmd(1);
+	slcdc_delay(2000);
+
+	/* this is to display one data per time, it is ok. */
+	slcdc_delay(0xffff);
+	__raw_writel((u32) slcdc_par.screen_start_address, IO_ADDRESS(SLCDC_BASE_ADDR + 0x00));	/* _reg_SLCDC_DBADDR */
+
+	slcdc_delay(0xffff);
+	/* slcdc_send_data( SLCDC_MEM_SIZE); */
+
+	/* enable interrupt */
+#ifdef USING_INTERRUPT_SLCDC
+	reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+						    /*_reg_SLCDC_LCD_CTRL_STAT*/
+	reg |= ~0xffffff7f;
+	__raw_writel(reg, IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+#endif
+	/* set length */
+	__raw_writel(SLCDC_MEM_SIZE, IO_ADDRESS(SLCDC_BASE_ADDR + 0x04));	/* _reg_SLCDC_DBUF_SIZE */
+	/* set automode 01 for data */
+	reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+						    /*_reg_SLCDC_LCD_CTRL_STAT*/
+	reg |= 0x00000800;
+	__raw_writel(reg, IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+
+	/* set GO  */
+	reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+						    /*_reg_SLCDC_LCD_CTRL_STAT*/
+
+	reg |= 0x1;
+	__raw_writel(reg, IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+	slcdc_delay(0xffff);
+
+	return;
+}
+
+/**
+ *@brief slcdc timer initialization
+ *
+ * Function Name: init_slcdc_timer
+ *
+ * Description:This helper routine prepare the SLCDC timer for refreshing the
+ *             screen
+ *
+ **/
+static void init_slcdc_timer(void)
+{
+
+	init_timer(&slcdc_timer);
+	slcdc_timer.expires = jiffies + SLCDC_REFRESH_RATE;
+	slcdc_timer.data = 0;
+	slcdc_timer.function = slcdc_timer_func;
+	add_timer(&slcdc_timer);
+	start_fb_timer_flag = 1;
+}
+
+/**
+ *@brief slcdc open function
+ *
+ * Function Name: slcdc_open
+ *
+ *
+ * Description: This is the open routine for the driver. And this function \n
+ *	   will be called while the module being opened. In this function, it will\n
+ *			@li	configure GPIO for serial/parallel
+ *			@li	slcdc reset
+ *			@li init slcd registers
+ *			@li init waitqueue
+ *			@li get rca, select the card
+ *			@li send some command for panel configuration
+ *
+ *@param	inode the pointer to the inode descripter
+ *@param	filp  the pointer to the file descripter
+ *
+ *@return	int   return status
+ *			@li 0  sucessful
+ *			@li other failed
+ * Modification History:
+ * 	Dec,2003,			Karen first version
+ *  June,2004,			Shirley update for Parallel mode
+ *
+ **/
+
+int slcdc_open(struct inode *inode, struct file *filp)
+{
+	volatile unsigned long reg;
+
+	TRACE("slcdc_open: ----\n");
+
+	/* init dev */
+#ifdef SLCDC_SERIAL_MODE
+	slcdc_gpio_serial();
+#else
+	slcdc_gpio_paralle();
+#endif
+
+	slcdc_init_dev();
+	slcdc_reset(0);		/*pull reset low */
+	/* init slcd registers */
+	slcdc_init_reg();
+
+	/* init waitqueue */
+	init_waitqueue_head(&slcdc_wait);
+	/* send some command for panel configuration */
+	slcdc_config_panel();
+	reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x1C));
+						    /*_reg_SLCDC_LCD_TXCONFIG*/
+	TRACE("TRANS_CONFIG_REG=%x \n", (unsigned int)reg);
+
+	/* init slcdc timer, and start timer */
+	init_slcdc_timer();
+	return 0;
+}
+
+/**
+ *@brief slcdc init function
+ *
+ * Function Name: slcdc_init
+ *
+ *
+ *@return	int   return status
+ *			@li 0  sucess
+ *			@li other failure
+ *
+ * Description: This is the initialization routine for the driver. And this
+ *              function \n will be called while the module being installed.
+ *              In this function, it will \n register char device,request
+ *              slcdc irq, initialize the buffer,register to\npower management.
+ *
+ * Modification History:
+ * 	Dec,2003,			Karen update for MX21 TO2
+ *
+ **/
+
+int __init slcdc_init(void)
+{
+	int tmp, err;
+
+	INFO("SLCDC Driver \n");
+	INFO("Motorola SPS-SuZhou \n");
+
+	_init_fbinfo();
+
+	if (slcdcfb_set_var(&slcdc_fb_info)) ;	/* current_par.allow_modeset = 0; */
+
+	register_framebuffer(&slcdc_fb_info);
+
+	devfs_mk_cdev(slcdc_device_num, S_IFCHR | S_IRUGO | S_IWUSR, "slcdc");
+
+	if (slcdc_major != 0) {
+		/* use user supplied major number */
+		slcdc_device_num = MKDEV(slcdc_major, slcdc_minor);
+
+		err = register_chrdev_region(slcdc_device_num, 1, MODULE_NAME);
+	} else {
+		/* auto create device major number */
+		err =
+		    alloc_chrdev_region(&slcdc_device_num, slcdc_minor, 1,
+					MODULE_NAME);
+	}
+
+	if (err < 0) {
+		TRACE("%s driver: Unable to register chrdev region\n",
+		      MODULE_NAME);
+		return err;
+	}
+
+	cdev_init(&slcdc_dev, &g_slcdc_fops);
+	slcdc_dev.owner = THIS_MODULE;
+	slcdc_dev.ops = &g_slcdc_fops;
+
+	if ((err = cdev_add(&slcdc_dev, slcdc_device_num, 1))) {
+		TRACE
+		    ("%s driver: Unable to create character device. Error code=%d\n",
+		     MODULE_NAME, err);
+		return -ENODEV;
+	}
+
+	/* init interrupt */
+	tmp = request_irq(SLCDC_IRQ,
+			  (void *)slcdc_isr,
+			  SA_INTERRUPT | SA_SHIRQ, MODULE_NAME, MODULE_NAME);
+	if (tmp) {
+		printk("slcdc_init:cannot init major= %d irq=%d\n",
+		       MAJOR(slcdc_device_num), SLCDC_IRQ);
+		devfs_remove(MODULE_NAME);
+		cdev_del(&slcdc_dev);
+		return -1;
+	}
+
+	/* init buffer */
+	/* initialize buffer address */
+	g_slcdc_dbuffer_address = NULL;
+	g_slcdc_dbuffer_phyaddress = NULL;
+	g_slcdc_cbuffer_address = NULL;
+	g_slcdc_cbuffer_phyaddress = NULL;
+	slcdc_init_buffer();
+
+	g_slcdc_status = 0;
+
+	return 0;
+}
+
+/**
+ *@brief slcdc cleanup function
+ *
+ * Function Name: slcdc_cleanup
+ *
+ *@return	None
+ *
+ * Description: This is the cleanup routine for the driver. And this function \n
+ *	 will be called while the module being removed. In this function, it will \n
+ *	 cleanup all the registered entries
+ *
+ * Modification History:
+ * 	Dec 2003,			Karen update for MX21 TO2
+ *
+ **/
+
+void __exit slcdc_cleanup(void)
+{
+
+	unregister_chrdev_region(slcdc_device_num, 1);
+
+	devfs_remove(MODULE_NAME);
+
+	/*Do some cleanup work */
+	free_irq(SLCDC_IRQ, MODULE_NAME);
+
+	unregister_framebuffer(&slcdc_fb_info);
+
+	slcdc_free_buffer();
+
+	cdev_del(&slcdc_dev);
+
+	return;
+}
+
+module_init(slcdc_init);
+module_exit(slcdc_cleanup);
+
+/*////////////// Frame Buffer Suport /////////////////////////////////// */
+
+/**
+ * _check_var - Validates a var passed in.
+ * @var: frame buffer variable screen structure
+ * @info: frame buffer structure that represents a single frame buffer
+ *
+ * Checks to see if the hardware supports the state requested by var passed
+ * in. This function does not alter the hardware state! If the var passed in
+ * is slightly off by what the hardware can support then we alter the var
+ * PASSED in to what we can do. If the hardware doesn't support mode change
+ * a -EINVAL will be returned by the upper layers.
+ *
+ * Returns negative errno on error, or zero on success.
+ */
+static int _check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	const struct slcdcfb_par *par = (const struct slcdcfb_par *)info->par;
+
+	if (var->xres > current_par.max_xres)
+		var->xres = current_par.max_xres;
+	if (var->yres > current_par.max_yres)
+		var->yres = current_par.max_yres;
+
+	var->xres_virtual = var->xres_virtual < par->xres
+	    ? par->xres : var->xres_virtual;
+	var->yres_virtual = var->yres_virtual < par->yres
+	    ? par->yres : var->yres_virtual;
+	var->bits_per_pixel = par->bits_per_pixel;
+
+	switch (var->bits_per_pixel) {
+	case 2:
+	case 4:
+	case 8:
+		var->red.length = 4;
+		var->green = var->red;
+		var->blue = var->red;
+		var->transp.length = 0;
+		break;
+
+	case 12:		/*  RGB 444 */
+	case 16:		/* RGB 565 */
+		TRACE("16->a\n");
+		var->red.length = 4;
+		var->blue.length = 4;
+		var->green.length = 4;
+		var->transp.length = 0;
+#ifdef __LITTLE_ENDIAN
+		TRACE("16->b\n");
+		var->red.offset = 8;
+		var->green.offset = 4;
+		var->blue.offset = 0;
+		var->transp.offset = 0;
+#endif				/* __LITTLE_ENDIAN */
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	/* *var->screen_start_address=(u_char*)((u_long)g_slcdc_dbuffer_phyaddress );
+	 *var->v_screen_start_address=(u_char*)((u_long)g_slcdc_dbuffer_address  ); */
+
+	var->height = -1;
+	var->width = -1;
+	var->grayscale = 0;
+	var->nonstd = 0;
+
+	var->pixclock = -1;
+	var->left_margin = -1;
+	var->right_margin = -1;
+	var->upper_margin = -1;
+	var->lower_margin = -1;
+	var->hsync_len = -1;
+	var->vsync_len = -1;
+
+	var->vmode = FB_VMODE_NONINTERLACED;
+	var->sync = 0;
+
+	return 0;
+}
+
+/**
+ *@brief Use current_par to set a var structure
+ *
+ *@param 	var Input var data
+ *@param	par LCD controller parameters
+ *
+ *@return  If no error, return 0
+ *
+ */
+static int _encode_var(struct fb_var_screeninfo *var, struct slcdcfb_par *par)
+{
+	FUNC_START
+	    /* Don't know if really want to zero var on entry.
+	       Look at set_var to see.  If so, may need to add extra params to par   */
+	    memset(var, 0, sizeof(*var));
+	var->xres = par->xres;
+	TRACE("var->xress=%d\n", var->xres);
+	var->yres = par->yres;
+	TRACE("var->yres=%d\n", var->yres);
+	var->xres_virtual = par->xres_virtual;
+	TRACE("var->xres_virtual=%d\n", var->xres_virtual);
+	var->yres_virtual = par->yres_virtual;
+	TRACE("var->yres_virtual=%d\n", var->yres_virtual);
+
+	var->bits_per_pixel = par->bits_per_pixel;
+	TRACE("var->bits_per_pixel=%d\n", var->bits_per_pixel);
+
+	switch (var->bits_per_pixel) {
+	case 2:
+	case 4:
+	case 8:
+		var->red.length = 4;
+		var->green = var->red;
+		var->blue = var->red;
+		var->transp.length = 0;
+		break;
+	case 12:		/* This case should differ for Active/Passive mode */
+	case 16:
+		TRACE("16->a\n");
+		var->red.length = 4;
+		var->blue.length = 4;
+		var->green.length = 4;
+		var->transp.length = 0;
+#ifdef __LITTLE_ENDIAN
+		TRACE("16->b\n");
+		var->red.offset = 8;
+		var->green.offset = 4;
+		var->blue.offset = 0;
+		var->transp.offset = 0;
+#endif				/* __LITTLE_ENDIAN */
+		break;
+	}
+
+	FUNC_END return 0;
+}
+
+/**
+ *@brief Get the video params out of 'var'. If a value doesn't fit,
+ * 		round it up,if it's too big, return -EINVAL.
+ *
+ *@warning Round up in the following order: bits_per_pixel, xres,
+ * 	yres, xres_virtual, yres_virtual, xoffset, yoffset, grayscale,
+ * 	bitfields, horizontal timing, vertical timing.
+ *
+ *@param 	var Input var data
+ *@param	par LCD controller parameters
+ *
+ *@return If no error, return 0
+ */
+static int _decode_var(struct fb_info *info)
+{
+	struct fb_var_screeninfo *var = &info->var;
+	struct slcdcfb_par par_var;
+	struct slcdcfb_par *par = &par_var;
+
+	FUNC_START *par = current_par;
+
+	if ((par->xres = var->xres) < MIN_XRES)
+		par->xres = MIN_XRES;
+	if ((par->yres = var->yres) < MIN_YRES)
+		par->yres = MIN_YRES;
+	if (par->xres > current_par.max_xres)
+		par->xres = current_par.max_xres;
+	if (par->yres > current_par.max_yres)
+		par->yres = current_par.max_yres;
+	par->xres_virtual = var->xres_virtual < par->xres
+	    ? par->xres : var->xres_virtual;
+	par->yres_virtual = var->yres_virtual < par->yres
+	    ? par->yres : var->yres_virtual;
+	par->bits_per_pixel = var->bits_per_pixel;
+
+	switch (par->bits_per_pixel) {
+
+	case 4:
+		par->visual = FB_VISUAL_PSEUDOCOLOR;
+		par->palette_size = 16;
+		break;
+
+	case 8:
+		par->visual = FB_VISUAL_PSEUDOCOLOR;
+		par->palette_size = 256;
+		break;
+
+	case 12:		/* RGB 444 */
+	case 16:		/* RGB 565 */
+		par->visual = FB_VISUAL_TRUECOLOR;
+		par->palette_size = 0;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	par->screen_start_address =
+	    (u_char *) ((u_long) g_slcdc_dbuffer_phyaddress);
+	par->v_screen_start_address =
+	    (u_char *) ((u_long) g_slcdc_dbuffer_address);
+
+	/* update_lcd ? */
+
+	FUNC_END return 0;
+}
+
+/**
+ *@brief Set current_par by var, also set display data, specially the console
+ * 	   related file operations, then enable the SLCD controller, and set cmap to
+ * 	   hardware.
+ *
+ *@param	var	Iuput data pointer
+ *@param	con	Console ID
+ *@param	info	Frame buffer information
+ *
+ *@return   If no error, return 0.
+ *
+ **/
+static int slcdcfb_set_var(struct fb_info *info)
+{
+	struct display *display;
+	int err;
+	struct slcdcfb_par par;
+	struct fb_var_screeninfo *var = &info->var;
+
+	FUNC_START;
+
+	display = &global_disp;	/* Default display settings */
+
+	/* Decode var contents into a par structure, adjusting any */
+	/* out of range values. */
+	if ((err = _decode_var(info))) {
+		TRACE("decode var error!");
+		return err;
+	}
+
+	/* Store adjusted par values into var structure */
+	_encode_var(var, &par);
+
+	if ((var->activate & FB_ACTIVATE_MASK) == FB_ACTIVATE_TEST)
+		return 0;
+
+	else if (((var->activate & FB_ACTIVATE_MASK) != FB_ACTIVATE_NOW) &&
+		 ((var->activate & FB_ACTIVATE_MASK) != FB_ACTIVATE_NXTOPEN))
+		return -EINVAL;
+
+	display->inverse = 0;
+
+	init_var = *var;	/* TODO:gcc support structure copy? */
+
+	FUNC_END;
+	return 0;
+}
+
+/**
+ *@brief Blank the screen, if blank, disable LCD controller, while if no blank
+ * 		set cmap and enable LCD controller
+ *
+ *@param	blank Blank flag
+ *@param	info	Frame buffer database
+ *
+ *@return  VOID
+ */
+static int slcdcfb_blank(int blank, struct fb_info *info)
+{
+
+	if (blank) {
+		slcdc_display_off();
+	} else {
+		slcdc_display_normal();
+	}
+
+	return 0;
+}
+
+/**
+ *@brief Initialize frame buffer. While 16bpp is used to store a 12 bits pixels
+ *      packet, it is not a really 16bpp system, maybe in-compatiable with
+ * 		other system or GUI.There are some field in var which specify
+ *		the red/green/blue offset in a 16bit word, just little endian is
+ * 		concerned
+ *
+ *@return  VOID
+ **/
+static void __init _init_fbinfo(void)
+{
+	FUNC_START;
+
+	slcdc_fb_info.node = -1;
+	slcdc_fb_info.flags = 0;	/* Low-level driver is not a module */
+	slcdc_fb_info.fbops = &slcdcfb_ops;
+	slcdc_fb_info.monspecs = monspecs;
+
+	strcpy(slcdc_fb_info.fix.id, "SLCDC");
+	/* FIXME... set fix parameters */
+	/*
+	 * * setup initial parameters
+	 * */
+	memset(&init_var, 0, sizeof(init_var));
+	memset(&current_par, 0, sizeof(current_par));
+
+	init_var.transp.length = 0;
+	init_var.nonstd = 0;
+	init_var.activate = FB_ACTIVATE_NOW;
+	init_var.xoffset = 0;
+	init_var.yoffset = 0;
+	init_var.height = -1;
+	init_var.width = -1;
+	init_var.vmode = FB_VMODE_NONINTERLACED;
+
+	/*xres and yres might be set when loading the module, if this driver is
+	   built as module */
+	current_par.max_xres = SLCDC_WIDTH;
+	current_par.max_yres = SLCDC_HIGH;
+
+	current_par.max_bpp = SLCDC_BPP;
+	init_var.red.length = 5;
+	init_var.green.length = 6;
+	init_var.blue.length = 5;
+#ifdef __LITTLE_ENDIAN
+	init_var.red.offset = 11;
+	init_var.green.offset = 5;
+	init_var.blue.offset = 0;
+#endif				/* __LITTLE_ENDIAN */
+	init_var.grayscale = 16;
+	init_var.sync = 0;
+	init_var.pixclock = 171521;
+
+	current_par.screen_start_address = NULL;
+	current_par.v_screen_start_address = NULL;
+	current_par.screen_memory_size = MAX_PIXEL_MEM_SIZE;
+	current_par.currcon = -1;
+
+	init_var.xres = current_par.max_xres;
+	init_var.yres = current_par.max_yres;
+	init_var.xres_virtual = init_var.xres;
+	init_var.yres_virtual = init_var.yres;
+	init_var.bits_per_pixel = current_par.max_bpp;
+
+	current_par.xres = init_var.xres;
+	current_par.yres = init_var.yres;
+	current_par.xres_virtual = init_var.xres;
+	current_par.yres_virtual = init_var.yres;
+
+	/* initialize current screen information */
+	memcpy(&slcdc_fb_info.var, &init_var, sizeof(init_var));
+
+	FUNC_END;
+}
+
+/**
+ *@brief slcdc framebuffer open call
+ *
+ * Function Name: slcdcfb_open
+ *
+ * Description  : This function is called by the framebuffer when the
+ *                application requests.
+ *
+ *@return		0 on success any other value for failure
+ **/
+static int slcdcfb_open(struct fb_info *info, int user)
+{
+	return slcdc_open(NULL, 0);
+}
+
+/**
+ *@brief slcdc framebuffer release call
+ *
+ * Function Name: slcdcfb_release
+ *
+ * Description  : This function is called by the framebuffer when the
+ *                application closes the link to framebuffer.
+ *
+ *@return		0 on success any other value for failure
+ **/
+static int slcdcfb_release(struct fb_info *info, int user)
+{
+	start_fb_timer_flag = 0;
+	return slcdc_release(NULL, 0);
+}
+
+/*\@}*/
+
+MODULE_PARM(irq_mask, "i");
+MODULE_PARM(irq_list, "1-4i");
+MODULE_LICENSE("GPL");
Index: linux-2.6.18/drivers/video/mxc/mxcfb_modedb.c
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/video/mxc/mxcfb_modedb.c
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2006-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <asm/arch/mxcfb.h>
+
+const struct fb_videomode mxcfb_modedb[] = {
+	[0] = {
+	       /* 240x320 @ 60 Hz */
+	       "Sharp-QVGA", 60, 240, 320, 185925, 9, 16, 7, 9, 1, 1,
+	       FB_SYNC_HOR_HIGH_ACT | FB_SYNC_SHARP_MODE |
+	       FB_SYNC_CLK_INVERT | FB_SYNC_DATA_INVERT | FB_SYNC_CLK_IDLE_EN,
+	       FB_VMODE_NONINTERLACED,
+	       0,
+	       },
+	[1] = {
+	       /* 640x480 @ 60 Hz */
+	       "NEC-VGA", 60, 640, 480, 38255, 144, 0, 34, 40, 1, 1,
+	       FB_SYNC_VERT_HIGH_ACT | FB_SYNC_OE_ACT_HIGH,
+	       FB_VMODE_NONINTERLACED,
+	       0,
+	       },
+	[2] = {
+	       /* NTSC TV output */
+	       "TV-NTSC", 60, 640, 480, 37538,
+	       38, 858 - 640 - 38 - 3,
+	       36, 518 - 480 - 36 - 1,
+	       3, 1,
+	       0,
+	       FB_VMODE_NONINTERLACED,
+	       0,
+	       },
+	[3] = {
+	       /* PAL TV output */
+	       "TV-PAL", 50, 640, 480, 37538,
+	       38, 960 - 640 - 38 - 32,
+	       32, 555 - 480 - 32 - 3,
+	       32, 3,
+	       0,
+	       FB_VMODE_NONINTERLACED,
+	       0,
+	       },
+	[4] = {
+	       /* TV output VGA mode, 640x480 @ 65 Hz */
+	       "TV-VGA", 60, 640, 480, 40574, 35, 45, 9, 1, 46, 5,
+	       0, FB_VMODE_NONINTERLACED, 0,
+	       },
+};
+
+int mxcfb_modedb_sz = ARRAY_SIZE(mxcfb_modedb);
+EXPORT_SYMBOL(mxcfb_modedb);
+EXPORT_SYMBOL(mxcfb_modedb_sz);
Index: linux-2.6.18/include/asm-arm/arch-mxc/mxcfb.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/asm-arm/arch-mxc/mxcfb.h
@@ -0,0 +1,70 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+/*
+ * @file arch-mxc/   mxcfb.h
+ *
+ * @brief Global header file for the MXC Frame buffer
+ *
+ * @ingroup Framebuffer
+ */
+#ifndef __ASM_ARCH_MXCFB_H__
+#define __ASM_ARCH_MXCFB_H__
+
+#include <linux/fb.h>
+
+#define FB_SYNC_OE_ACT_HIGH	0x80000000
+#define FB_SYNC_CLK_INVERT	0x40000000
+#define FB_SYNC_DATA_INVERT	0x20000000
+#define FB_SYNC_CLK_IDLE_EN	0x10000000
+#define FB_SYNC_SHARP_MODE	0x08000000
+#define FB_SYNC_SWAP_RGB	0x04000000
+
+struct mxcfb_gbl_alpha {
+	int enable;
+	int alpha;
+};
+
+struct mxcfb_color_key {
+	int enable;
+	__u32 color_key;
+};
+
+#define MXCFB_WAIT_FOR_VSYNC	_IOW('F', 0x20, u_int32_t)
+#define MXCFB_SET_GBL_ALPHA     _IOW('F', 0x21, struct mxcfb_gbl_alpha)
+#define MXCFB_SET_CLR_KEY       _IOW('F', 0x22, struct mxcfb_color_key)
+#define MXCFB_SET_BRIGHTNESS    _IOW('F', 0x23, __u8)
+
+#ifdef __KERNEL__
+
+extern const struct fb_videomode mxcfb_modedb[];
+extern int mxcfb_modedb_sz;
+
+enum {
+	MXCFB_REFRESH_OFF,
+	MXCFB_REFRESH_AUTO,
+	MXCFB_REFRESH_PARTIAL,
+};
+
+struct mxcfb_rect {
+	u32 top;
+	u32 left;
+	u32 width;
+	u32 height;
+};
+
+int mxcfb_set_refresh_mode(struct fb_info *fbi, int mode,
+			   struct mxcfb_rect *update_region);
+
+#endif				/* __KERNEL__ */
+#endif
Index: linux-2.6.18/mvl_patches/pro50-0113.c
===================================================================
--- /dev/null
+++ linux-2.6.18/mvl_patches/pro50-0113.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(113);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

