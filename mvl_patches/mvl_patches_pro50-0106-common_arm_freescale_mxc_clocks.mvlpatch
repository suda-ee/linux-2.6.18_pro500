#! /usr/bin/env bash
# Patch: -common_arm_freescale_mxc_clocks
# Date: Wed Aug 29 07:23:39 2007

PATCHNUM=106
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Index: linux-2.6.18/arch/arm/mach-mx2/Makefile
===================================================================
--- linux-2.6.18.orig/arch/arm/mach-mx2/Makefile
+++ linux-2.6.18/arch/arm/mach-mx2/Makefile
@@ -4,5 +4,5 @@
 
 # Object file lists.
 
-obj-y		:= mm.o time.o
+obj-y		:= mm.o time.o clock.o cpu.o
 obj-$(CONFIG_MACH_MX27ADS)	+= mx27ads.o
Index: linux-2.6.18/arch/arm/mach-mx2/clock.c
===================================================================
--- /dev/null
+++ linux-2.6.18/arch/arm/mach-mx2/clock.c
@@ -0,0 +1,1553 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/clk.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include "crm_regs.h"
+
+#define CKIH_CLK_FREQ           26000000	/* 26M reference clk */
+#define CKIH_CLK_FREQ_27MHZ     27000000
+#define CKIL_CLK_FREQ           32768	/* 32.768k oscillator in */
+#define CKIH_27MHZ_BIT_SET      (1 << 3)
+
+extern void mxc_cpu_common_init(void);
+
+static struct clk ckil_clk;
+static struct clk mpll_clk;
+static struct clk mpll_main_clk[];
+static struct clk spll_clk;
+
+static int _clk_enable(struct clk *clk)
+{
+	unsigned long reg;
+
+	reg = __raw_readl(clk->enable_reg);
+	reg |= 1 << clk->enable_shift;
+	__raw_writel(reg, clk->enable_reg);
+
+	return 0;
+}
+
+static void _clk_disable(struct clk *clk)
+{
+	unsigned long reg;
+
+	reg = __raw_readl(clk->enable_reg);
+	reg &= ~(1 << clk->enable_shift);
+	__raw_writel(reg, clk->enable_reg);
+}
+
+static int _clk_spll_enable(struct clk *clk)
+{
+	unsigned long reg;
+
+	reg = __raw_readl(CCM_CSCR);
+	reg |= CCM_CSCR_SPEN;
+	__raw_writel(reg, CCM_CSCR);
+
+	while ((__raw_readl(CCM_SPCTL1) & CCM_SPCTL1_LF) == 0) ;
+
+	return 0;
+}
+
+static void _clk_spll_disable(struct clk *clk)
+{
+	unsigned long reg;
+
+	reg = __raw_readl(CCM_CSCR);
+	reg &= ~CCM_CSCR_SPEN;
+	__raw_writel(reg, CCM_CSCR);
+}
+
+static void _clk_pccr01_enable(unsigned long mask0, unsigned long mask1)
+{
+	unsigned long reg;
+
+	reg = __raw_readl(CCM_PCCR0);
+	reg |= mask0;
+	__raw_writel(reg, CCM_PCCR0);
+
+	reg = __raw_readl(CCM_PCCR1);
+	reg |= mask1;
+	__raw_writel(reg, CCM_PCCR1);
+
+}
+
+static void _clk_pccr01_disable(unsigned long mask0, unsigned long mask1)
+{
+	unsigned long reg;
+
+	reg = __raw_readl(CCM_PCCR0);
+	reg &= ~mask0;
+	__raw_writel(reg, CCM_PCCR0);
+
+	reg = __raw_readl(CCM_PCCR1);
+	reg &= ~mask1;
+	__raw_writel(reg, CCM_PCCR1);
+}
+
+static void _clk_pccr10_enable(unsigned long mask1, unsigned long mask0)
+{
+	unsigned long reg;
+
+	reg = __raw_readl(CCM_PCCR1);
+	reg |= mask1;
+	__raw_writel(reg, CCM_PCCR1);
+
+	reg = __raw_readl(CCM_PCCR0);
+	reg |= mask0;
+	__raw_writel(reg, CCM_PCCR0);
+}
+
+static void _clk_pccr10_disable(unsigned long mask1, unsigned long mask0)
+{
+	unsigned long reg;
+
+	reg = __raw_readl(CCM_PCCR1);
+	reg &= ~mask1;
+	__raw_writel(reg, CCM_PCCR1);
+
+	reg = __raw_readl(CCM_PCCR0);
+	reg &= ~mask0;
+	__raw_writel(reg, CCM_PCCR0);
+}
+
+static int _clk_dma_enable(struct clk *clk)
+{
+	_clk_pccr01_enable(CCM_PCCR0_DMA_MASK, CCM_PCCR1_HCLK_DMA_MASK);
+
+	return 0;
+}
+
+static void _clk_dma_disable(struct clk *clk)
+{
+	_clk_pccr01_disable(CCM_PCCR0_DMA_MASK, CCM_PCCR1_HCLK_DMA_MASK);
+}
+
+static int _clk_rtic_enable(struct clk *clk)
+{
+	_clk_pccr01_enable(CCM_PCCR0_RTIC_MASK, CCM_PCCR1_HCLK_RTIC_MASK);
+
+	return 0;
+}
+
+static void _clk_rtic_disable(struct clk *clk)
+{
+	_clk_pccr01_disable(CCM_PCCR0_RTIC_MASK, CCM_PCCR1_HCLK_RTIC_MASK);
+}
+
+static int _clk_emma_enable(struct clk *clk)
+{
+	_clk_pccr01_enable(CCM_PCCR0_EMMA_MASK, CCM_PCCR1_HCLK_EMMA_MASK);
+
+	return 0;
+}
+
+static void _clk_emma_disable(struct clk *clk)
+{
+	_clk_pccr01_disable(CCM_PCCR0_EMMA_MASK, CCM_PCCR1_HCLK_EMMA_MASK);
+}
+
+static int _clk_slcdc_enable(struct clk *clk)
+{
+	_clk_pccr01_enable(CCM_PCCR0_SLCDC_MASK, CCM_PCCR1_HCLK_SLCDC_MASK);
+
+	return 0;
+}
+
+static void _clk_slcdc_disable(struct clk *clk)
+{
+	_clk_pccr01_disable(CCM_PCCR0_SLCDC_MASK, CCM_PCCR1_HCLK_SLCDC_MASK);
+}
+
+static int _clk_fec_enable(struct clk *clk)
+{
+	_clk_pccr01_enable(CCM_PCCR0_FEC_MASK, CCM_PCCR1_HCLK_FEC_MASK);
+
+	return 0;
+}
+
+static void _clk_fec_disable(struct clk *clk)
+{
+	_clk_pccr01_disable(CCM_PCCR0_FEC_MASK, CCM_PCCR1_HCLK_FEC_MASK);
+}
+
+static int _clk_vpu_enable(struct clk *clk)
+{
+	unsigned long reg;
+
+	reg = __raw_readl(CCM_PCCR1);
+	reg |= CCM_PCCR1_VPU_BAUD_MASK | CCM_PCCR1_HCLK_VPU_MASK;
+	__raw_writel(reg, CCM_PCCR1);
+
+	return 0;
+}
+
+static void _clk_vpu_disable(struct clk *clk)
+{
+	unsigned long reg;
+
+	reg = __raw_readl(CCM_PCCR1);
+	reg &= ~(CCM_PCCR1_VPU_BAUD_MASK | CCM_PCCR1_HCLK_VPU_MASK);
+	__raw_writel(reg, CCM_PCCR1);
+}
+
+static int _clk_sahara2_enable(struct clk *clk)
+{
+	_clk_pccr01_enable(CCM_PCCR0_SAHARA_MASK, CCM_PCCR1_HCLK_SAHARA_MASK);
+
+	return 0;
+}
+
+static void _clk_sahara2_disable(struct clk *clk)
+{
+	_clk_pccr01_disable(CCM_PCCR0_SAHARA_MASK, CCM_PCCR1_HCLK_SAHARA_MASK);
+}
+
+static int _clk_mstick1_enable(struct clk *clk)
+{
+	_clk_pccr10_enable(CCM_PCCR1_MSHC_BAUD_MASK, CCM_PCCR0_MSHC_MASK);
+
+	return 0;
+}
+
+static void _clk_mstick1_disable(struct clk *clk)
+{
+	_clk_pccr10_disable(CCM_PCCR1_MSHC_BAUD_MASK, CCM_PCCR0_MSHC_MASK);
+}
+
+#define CSCR() (__raw_readl(CCM_CSCR))
+#define PCDR0() (__raw_readl(CCM_PCDR0))
+#define PCDR1() (__raw_readl(CCM_PCDR1))
+
+static void _clk_pll_recalc(struct clk *clk)
+{
+	unsigned long mfi = 0, mfn = 0, mfd = 0, pdf = 0;
+	unsigned long ref_clk;
+	unsigned long reg;
+	unsigned long long temp;
+
+	ref_clk = clk->parent->rate;
+	if (clk->parent == &ckil_clk) {
+		ref_clk *= 1024;
+	}
+
+	if (clk == &mpll_clk) {
+		reg = __raw_readl(CCM_MPCTL0);
+		pdf = (reg & CCM_MPCTL0_PD_MASK) >> CCM_MPCTL0_PD_OFFSET;
+		mfd = (reg & CCM_MPCTL0_MFD_MASK) >> CCM_MPCTL0_MFD_OFFSET;
+		mfi = (reg & CCM_MPCTL0_MFI_MASK) >> CCM_MPCTL0_MFI_OFFSET;
+		mfn = (reg & CCM_MPCTL0_MFN_MASK) >> CCM_MPCTL0_MFN_OFFSET;
+	} else if (clk == &spll_clk) {
+		reg = __raw_readl(CCM_SPCTL0);
+		/*TODO: This is TO2 Bug */
+		if (cpu_is_mx27_rev(CHIP_REV_2_0) == 1) {
+			__raw_writel(reg, CCM_SPCTL0);
+		}
+		pdf = (reg & CCM_SPCTL0_PD_MASK) >> CCM_SPCTL0_PD_OFFSET;
+		mfd = (reg & CCM_SPCTL0_MFD_MASK) >> CCM_SPCTL0_MFD_OFFSET;
+		mfi = (reg & CCM_SPCTL0_MFI_MASK) >> CCM_SPCTL0_MFI_OFFSET;
+		mfn = (reg & CCM_SPCTL0_MFN_MASK) >> CCM_SPCTL0_MFN_OFFSET;
+	} else {
+		BUG();		/* oops */
+	}
+
+	mfi = (mfi <= 5) ? 5 : mfi;
+	temp = 2LL * ref_clk * mfn;
+	do_div(temp, mfd + 1);
+	temp = 2LL * ref_clk * mfi + temp;
+	do_div(temp, pdf + 1);
+
+	clk->rate = temp;
+}
+
+static void _clk_mpll_main_recalc(struct clk *clk)
+{
+	/* i.MX27 TO2:
+	 * clk->id == 0: arm clock source path 1 which is from 2*MPLL/DIV_2
+	 * clk->id == 1: arm clock source path 2 which is from 2*MPLL/DIV_3
+	 */
+	switch (clk->id) {
+	case 0:
+		clk->rate = clk->parent->rate;
+		break;
+	case 1:
+		clk->rate = 2 * clk->parent->rate / 3;
+	}
+}
+
+static int _clk_cpu_set_parent(struct clk *clk, struct clk *parent)
+{
+	int cscr = CSCR();
+
+	if (clk->parent == parent)
+		return 0;
+
+	if (cpu_is_mx27_rev(CHIP_REV_2_0) > 0) {
+		if (parent == &mpll_main_clk[0]) {
+			cscr |= CCM_CSCR_ARM_SRC;
+		} else {
+			if (parent == &mpll_main_clk[1]) {
+				cscr &= ~CCM_CSCR_ARM_SRC;
+			} else {
+				return -EINVAL;
+			}
+		}
+		__raw_writel(CCM_CSCR, cscr);
+	} else {
+		return -ENODEV;
+	}
+	clk->parent = parent;
+	return 0;
+}
+
+static unsigned long _clk_cpu_round_rate(struct clk *clk, unsigned long rate)
+{
+	int div;
+	div = clk->parent->rate / rate;
+	if (clk->parent->rate % rate) {
+		div++;
+	}
+
+	if (div > 4) {
+		div = 4;
+	}
+	return clk->parent->rate / div;
+}
+
+static int _clk_cpu_set_rate(struct clk *clk, unsigned long rate)
+{
+	int div, reg;
+	div = clk->parent->rate / rate;
+
+	if (div > 4 || div < 1 || ((clk->parent->rate / div) != rate)) {
+		return -EINVAL;
+	}
+	div--;
+
+	reg = (CSCR() & ~CCM_CSCR_ARM_MASK) | (div << CCM_CSCR_ARM_OFFSET);
+	__raw_writel(CCM_CSCR, reg);
+	clk->rate = rate;
+	return 0;
+}
+
+static void _clk_cpu_recalc(struct clk *clk)
+{
+	unsigned long div;
+
+	if (cpu_is_mx27_rev(CHIP_REV_2_0) > 0) {
+		div = (CSCR() & CCM_CSCR_ARM_MASK) >> CCM_CSCR_ARM_OFFSET;
+	} else {
+		div = (CSCR() & CCM_CSCR_PRESC_MASK) >> CCM_CSCR_PRESC_OFFSET;
+	}
+
+	clk->rate = clk->parent->rate / (div + 1);
+}
+
+static void _clk_ahb_recalc(struct clk *clk)
+{
+	unsigned long bclk_pdf;
+
+	if (cpu_is_mx27_rev(CHIP_REV_2_0) > 0) {
+		bclk_pdf = (CSCR() & CCM_CSCR_AHB_MASK) >> CCM_CSCR_AHB_OFFSET;
+	} else {
+		bclk_pdf =
+		    (CSCR() & CCM_CSCR_BCLK_MASK) >> CCM_CSCR_BCLK_OFFSET;
+	}
+	clk->rate = clk->parent->rate / (bclk_pdf + 1);
+}
+
+static void _clk_perclkx_recalc(struct clk *clk)
+{
+	unsigned long perclk_pdf;
+
+	if (clk->id < 0 || clk->id > 3)
+		return;
+
+	perclk_pdf = (PCDR1() >> (clk->id << 3)) & CCM_PCDR1_PERDIV1_MASK;
+
+	clk->rate = clk->parent->rate / (perclk_pdf + 1);
+}
+
+static unsigned long _clk_perclkx_round_rate(struct clk *clk,
+					     unsigned long rate)
+{
+	u32 div;
+
+	div = clk->parent->rate / rate;
+	if (clk->parent->rate % rate)
+		div++;
+
+	if (div > 64) {
+		div = 64;
+	}
+
+	return clk->parent->rate / div;
+}
+
+static int _clk_perclkx_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg;
+	u32 div;
+
+	if (clk->id < 0 || clk->id > 3)
+		return -EINVAL;
+
+	div = clk->parent->rate / rate;
+	if (div > 64 || div < 1 || ((clk->parent->rate / div) != rate)) {
+		return -EINVAL;
+	}
+	div--;
+
+	reg =
+	    __raw_readl(CCM_PCDR1) & ~(CCM_PCDR1_PERDIV1_MASK <<
+				       (clk->id << 3));
+	reg |= div << (clk->id << 3);
+	__raw_writel(reg, CCM_PCDR1);
+
+	clk->rate = rate;
+
+	return 0;
+}
+
+static void _clk_usb_recalc(struct clk *clk)
+{
+	unsigned long usb_pdf;
+
+	usb_pdf = (CSCR() & CCM_CSCR_USB_MASK) >> CCM_CSCR_USB_OFFSET;
+
+	clk->rate = clk->parent->rate / (usb_pdf + 1);
+}
+
+static void _clk_ssi1_recalc(struct clk *clk)
+{
+	unsigned long ssi1_pdf;
+
+	ssi1_pdf = (PCDR0() & CCM_PCDR0_SSI1BAUDDIV_MASK) >>
+	    CCM_PCDR0_SSI1BAUDDIV_OFFSET;
+
+	if (cpu_is_mx27_rev(CHIP_REV_2_0) > 0) {
+		ssi1_pdf += 4;
+	} else {
+		ssi1_pdf = (ssi1_pdf < 2) ? 124 : ssi1_pdf;
+	}
+
+	clk->rate = 2 * clk->parent->rate / ssi1_pdf;
+}
+
+static void _clk_ssi2_recalc(struct clk *clk)
+{
+	unsigned long ssi2_pdf;
+
+	ssi2_pdf = (PCDR0() & CCM_PCDR0_SSI2BAUDDIV_MASK) >>
+	    CCM_PCDR0_SSI2BAUDDIV_OFFSET;
+
+	if (cpu_is_mx27_rev(CHIP_REV_2_0) > 0) {
+		ssi2_pdf += 4;
+	} else {
+		ssi2_pdf = (ssi2_pdf < 2) ? 124 : ssi2_pdf;
+	}
+
+	clk->rate = 2 * clk->parent->rate / ssi2_pdf;
+}
+
+static void _clk_nfc_recalc(struct clk *clk)
+{
+	unsigned long nfc_pdf;
+
+	if (cpu_is_mx27_rev(CHIP_REV_2_0) > 0) {
+		nfc_pdf =
+		    (PCDR0() & CCM_PCDR0_NFCDIV2_MASK) >>
+		    CCM_PCDR0_NFCDIV2_OFFSET;
+	} else {
+		nfc_pdf =
+		    (PCDR0() & CCM_PCDR0_NFCDIV_MASK) >>
+		    CCM_PCDR0_NFCDIV_OFFSET;
+	}
+
+	clk->rate = clk->parent->rate / (nfc_pdf + 1);
+}
+
+static void _clk_vpu_recalc(struct clk *clk)
+{
+	unsigned long vpu_pdf;
+
+	if (cpu_is_mx27_rev(CHIP_REV_2_0) > 0) {
+		vpu_pdf =
+		    (PCDR0() & CCM_PCDR0_VPUDIV2_MASK) >>
+		    CCM_PCDR0_VPUDIV2_OFFSET;
+		vpu_pdf += 4;
+	} else {
+		vpu_pdf =
+		    (PCDR0() & CCM_PCDR0_VPUDIV_MASK) >>
+		    CCM_PCDR0_VPUDIV_OFFSET;
+		vpu_pdf = (vpu_pdf < 2) ? 124 : vpu_pdf;
+	}
+	clk->rate = 2 * clk->parent->rate / vpu_pdf;
+}
+
+static void _clk_ipg_recalc(struct clk *clk)
+{
+	unsigned long ipg_pdf;
+
+	if (cpu_is_mx27_rev(CHIP_REV_2_0) > 0) {
+		ipg_pdf = 1;
+	} else {
+		ipg_pdf = (CSCR() & CCM_CSCR_IPDIV) >> CCM_CSCR_IPDIV_OFFSET;
+	}
+
+	clk->rate = clk->parent->rate / (ipg_pdf + 1);
+}
+
+static unsigned long _clk_parent_round_rate(struct clk *clk, unsigned long rate)
+{
+	return clk->parent->round_rate(clk->parent, rate);
+}
+
+static int _clk_parent_set_rate(struct clk *clk, unsigned long rate)
+{
+	int ret;
+
+	ret = clk->parent->set_rate(clk->parent, rate);
+	if (ret == 0)
+		clk->rate = rate;
+	return ret;
+}
+
+static struct clk ckih_clk = {
+	.name = "ckih",
+	.rate = 0,		/* determined at boot time (26 or 27 MHz) */
+};
+
+static struct clk ckil_clk = {
+	.name = "ckil",
+	.rate = CKIL_CLK_FREQ,
+};
+
+static struct clk mpll_clk = {
+	.name = "mpll",
+	.parent = &ckih_clk,
+	.recalc = _clk_pll_recalc,
+};
+
+static struct clk mpll_main_clk[] = {
+	{
+	 /* For i.MX27 TO2, it is the MPLL path 1 of ARM core
+	  * It provide the clock source whose rate is same as MPLL
+	  */
+	 .name = "mpll_main",
+	 .id = 0,
+	 .parent = &mpll_clk,
+	 .recalc = _clk_mpll_main_recalc,},
+	{
+	 /* For i.MX27 TO2, it is the MPLL path 1 of ARM core
+	  * It provide the clock source whose rate is same as MPLL
+	  */
+	 .name = "mpll_main",
+	 .id = 1,
+	 .parent = &mpll_clk,
+	 .recalc = _clk_mpll_main_recalc,}
+};
+
+static struct clk spll_clk = {
+	.name = "spll",
+	.parent = &ckih_clk,
+	.recalc = _clk_pll_recalc,
+	.enable = _clk_spll_enable,
+	.disable = _clk_spll_disable,
+};
+
+static struct clk cpu_clk = {
+	.name = "cpu_clk",
+	.parent = &mpll_main_clk[1],
+	.set_parent = _clk_cpu_set_parent,
+	.round_rate = _clk_cpu_round_rate,
+	.set_rate = _clk_cpu_set_rate,
+	.recalc = _clk_cpu_recalc,
+};
+
+static struct clk ahb_clk = {
+	.name = "ahb_clk",
+	.parent = &mpll_main_clk[1],
+	.recalc = _clk_ahb_recalc,
+};
+
+static struct clk ipg_clk = {
+	.name = "ipg_clk",
+	.parent = &ahb_clk,
+	.recalc = _clk_ipg_recalc,
+};
+
+static struct clk per_clk[] = {
+	{
+	 .name = "per_clk",
+	 .id = 0,
+	 .parent = &mpll_main_clk[1],
+	 .recalc = _clk_perclkx_recalc,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR1,
+	 .enable_shift = CCM_PCCR1_PERCLK1_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "per_clk",
+	 .id = 1,
+	 .parent = &mpll_main_clk[1],
+	 .recalc = _clk_perclkx_recalc,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR1,
+	 .enable_shift = CCM_PCCR1_PERCLK2_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "per_clk",
+	 .id = 2,
+	 .parent = &mpll_main_clk[1],
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .recalc = _clk_perclkx_recalc,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR1,
+	 .enable_shift = CCM_PCCR1_PERCLK3_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "per_clk",
+	 .id = 3,
+	 .parent = &mpll_main_clk[1],
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .recalc = _clk_perclkx_recalc,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR1,
+	 .enable_shift = CCM_PCCR1_PERCLK4_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk uart1_clk[] = {
+	{
+	 .name = "uart_clk",
+	 .id = 0,
+	 .parent = &per_clk[0],
+	 .secondary = &uart1_clk[1],},
+	{
+	 .name = "uart_ipg_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR1,
+	 .enable_shift = CCM_PCCR1_UART1_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk uart2_clk[] = {
+	{
+	 .name = "uart_clk",
+	 .id = 1,
+	 .parent = &per_clk[0],
+	 .secondary = &uart2_clk[1],},
+	{
+	 .name = "uart_ipg_clk",
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR1,
+	 .enable_shift = CCM_PCCR1_UART2_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk uart3_clk[] = {
+	{
+	 .name = "uart_clk",
+	 .id = 2,
+	 .parent = &per_clk[0],
+	 .secondary = &uart3_clk[1],},
+	{
+	 .name = "uart_ipg_clk",
+	 .id = 2,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR1,
+	 .enable_shift = CCM_PCCR1_UART3_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk uart4_clk[] = {
+	{
+	 .name = "uart_clk",
+	 .id = 3,
+	 .parent = &per_clk[0],
+	 .secondary = &uart4_clk[1],},
+	{
+	 .name = "uart_ipg_clk",
+	 .id = 3,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR1,
+	 .enable_shift = CCM_PCCR1_UART4_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk uart5_clk[] = {
+	{
+	 .name = "uart_clk",
+	 .id = 4,
+	 .parent = &per_clk[0],
+	 .secondary = &uart5_clk[1],},
+	{
+	 .name = "uart_ipg_clk",
+	 .id = 4,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR1,
+	 .enable_shift = CCM_PCCR1_UART5_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk uart6_clk[] = {
+	{
+	 .name = "uart_clk",
+	 .id = 5,
+	 .parent = &per_clk[0],
+	 .secondary = &uart6_clk[1],},
+	{
+	 .name = "uart_ipg_clk",
+	 .id = 5,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR1,
+	 .enable_shift = CCM_PCCR1_UART6_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk gpt1_clk[] = {
+	{
+	 .name = "gpt_clk",
+	 .id = 0,
+	 .parent = &per_clk[0],
+	 .secondary = &gpt1_clk[1],},
+	{
+	 .name = "gpt_ipg_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR0,
+	 .enable_shift = CCM_PCCR0_GPT1_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk gpt2_clk[] = {
+	{
+	 .name = "gpt_clk",
+	 .id = 1,
+	 .parent = &per_clk[0],
+	 .secondary = &gpt2_clk[1],},
+	{
+	 .name = "gpt_ipg_clk",
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR0,
+	 .enable_shift = CCM_PCCR0_GPT2_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk gpt3_clk[] = {
+	{
+	 .name = "gpt_clk",
+	 .id = 2,
+	 .parent = &per_clk[0],
+	 .secondary = &gpt3_clk[1],},
+	{
+	 .name = "gpt_ipg_clk",
+	 .id = 2,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR0,
+	 .enable_shift = CCM_PCCR0_GPT3_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk gpt4_clk[] = {
+	{
+	 .name = "gpt_clk",
+	 .id = 3,
+	 .parent = &per_clk[0],
+	 .secondary = &gpt4_clk[1],},
+	{
+	 .name = "gpt_ipg_clk",
+	 .id = 3,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR0,
+	 .enable_shift = CCM_PCCR0_GPT4_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk gpt5_clk[] = {
+	{
+	 .name = "gpt_clk",
+	 .id = 4,
+	 .parent = &per_clk[0],
+	 .secondary = &gpt5_clk[1],},
+	{
+	 .name = "gpt_ipg_clk",
+	 .id = 4,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR0,
+	 .enable_shift = CCM_PCCR0_GPT5_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk gpt6_clk[] = {
+	{
+	 .name = "gpt_clk",
+	 .id = 5,
+	 .parent = &per_clk[0],
+	 .secondary = &gpt6_clk[1],},
+	{
+	 .name = "gpt_ipg_clk",
+	 .id = 5,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR0,
+	 .enable_shift = CCM_PCCR0_GPT6_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk pwm_clk[] = {
+	{
+	 .name = "pwm_clk",
+	 .parent = &per_clk[0],
+	 .secondary = &pwm_clk[1],},
+	{
+	 .name = "pwm_clk",
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR0,
+	 .enable_shift = CCM_PCCR0_PWM_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk sdhc1_clk[] = {
+	{
+	 .name = "sdhc_clk",
+	 .id = 0,
+	 .parent = &per_clk[1],
+	 .secondary = &sdhc1_clk[1],},
+	{
+	 .name = "sdhc_ipg_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR0,
+	 .enable_shift = CCM_PCCR0_SDHC1_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk sdhc2_clk[] = {
+	{
+	 .name = "sdhc_clk",
+	 .id = 1,
+	 .parent = &per_clk[1],
+	 .secondary = &sdhc2_clk[1],},
+	{
+	 .name = "sdhc_ipg_clk",
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR0,
+	 .enable_shift = CCM_PCCR0_SDHC2_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk sdhc3_clk[] = {
+	{
+	 .name = "sdhc_clk",
+	 .id = 2,
+	 .parent = &per_clk[1],
+	 .secondary = &sdhc3_clk[1],},
+	{
+	 .name = "sdhc_ipg_clk",
+	 .id = 2,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR0,
+	 .enable_shift = CCM_PCCR0_SDHC3_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk cspi1_clk[] = {
+	{
+	 .name = "cspi_clk",
+	 .id = 0,
+	 .parent = &per_clk[1],
+	 .secondary = &cspi1_clk[1],},
+	{
+	 .name = "cspi_ipg_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR0,
+	 .enable_shift = CCM_PCCR0_CSPI1_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk cspi2_clk[] = {
+	{
+	 .name = "cspi_clk",
+	 .id = 1,
+	 .parent = &per_clk[1],
+	 .secondary = &cspi2_clk[1],},
+	{
+	 .name = "cspi_ipg_clk",
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR0,
+	 .enable_shift = CCM_PCCR0_CSPI2_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk cspi3_clk[] = {
+	{
+	 .name = "cspi_clk",
+	 .id = 2,
+	 .parent = &per_clk[1],
+	 .secondary = &cspi3_clk[1],},
+	{
+	 .name = "cspi_ipg_clk",
+	 .id = 2,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR0,
+	 .enable_shift = CCM_PCCR0_CSPI3_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk lcdc_clk[] = {
+	{
+	 .name = "lcdc_clk",
+	 .parent = &per_clk[2],
+	 .secondary = &lcdc_clk[1],
+	 .round_rate = _clk_parent_round_rate,
+	 .set_rate = _clk_parent_set_rate,},
+	{
+	 .name = "lcdc_ipg_clk",
+	 .parent = &ipg_clk,
+	 .secondary = &lcdc_clk[2],
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR0,
+	 .enable_shift = CCM_PCCR0_LCDC_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "lcdc_ahb_clk",
+	 .parent = &ahb_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR1,
+	 .enable_shift = CCM_PCCR1_HCLK_LCDC_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk csi_clk[] = {
+	{
+	 .name = "csi_perclk",
+	 .parent = &per_clk[3],
+	 .secondary = &csi_clk[1],
+	 .round_rate = _clk_parent_round_rate,
+	 .set_rate = _clk_parent_set_rate,},
+	{
+	 .name = "csi_ahb_clk",
+	 .parent = &ahb_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR1,
+	 .enable_shift = CCM_PCCR1_HCLK_CSI_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk usb_clk[] = {
+	{
+	 .name = "usb_clk",
+	 .parent = &spll_clk,
+	 .recalc = _clk_usb_recalc,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR1,
+	 .enable_shift = CCM_PCCR1_USBOTG_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "usb_ahb_clk",
+	 .parent = &ahb_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR1,
+	 .enable_shift = CCM_PCCR1_HCLK_USBOTG_OFFSET,
+	 .disable = _clk_disable,}
+};
+
+static struct clk ssi1_clk[] = {
+	{
+	 .name = "ssi_clk",
+	 .id = 0,
+	 .parent = &mpll_main_clk[1],
+	 .secondary = &ssi1_clk[1],
+	 .recalc = _clk_ssi1_recalc,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR1,
+	 .enable_shift = CCM_PCCR1_SSI1_BAUD_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "ssi_ipg_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR0,
+	 .enable_shift = CCM_PCCR0_SSI1_IPG_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk ssi2_clk[] = {
+	{
+	 .name = "ssi_clk",
+	 .id = 1,
+	 .parent = &mpll_main_clk[1],
+	 .secondary = &ssi2_clk[1],
+	 .recalc = _clk_ssi2_recalc,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR1,
+	 .enable_shift = CCM_PCCR1_SSI2_BAUD_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "ssi_ipg_clk",
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR0,
+	 .enable_shift = CCM_PCCR0_SSI2_IPG_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk nfc_clk = {
+	.name = "nfc_clk",
+	.parent = &cpu_clk,
+	.recalc = _clk_nfc_recalc,
+	.enable = _clk_enable,
+	.enable_reg = CCM_PCCR1,
+	.enable_shift = CCM_PCCR1_NFC_BAUD_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk vpu_clk = {
+	.name = "vpu_clk",
+	.parent = &mpll_main_clk[1],
+	.recalc = _clk_vpu_recalc,
+	.enable = _clk_vpu_enable,
+	.disable = _clk_vpu_disable,
+};
+
+static struct clk dma_clk = {
+	.name = "dma_clk",
+	.parent = &ahb_clk,
+	.enable = _clk_dma_enable,
+	.disable = _clk_dma_disable,
+};
+
+static struct clk rtic_clk = {
+	.name = "rtic_clk",
+	.parent = &ahb_clk,
+	.enable = _clk_rtic_enable,
+	.disable = _clk_rtic_disable,
+};
+
+static struct clk brom_clk = {
+	.name = "brom_clk",
+	.parent = &ahb_clk,
+	.enable = _clk_enable,
+	.enable_reg = CCM_PCCR1,
+	.enable_shift = CCM_PCCR1_HCLK_BROM_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk emma_clk = {
+	.name = "emma_clk",
+	.parent = &ahb_clk,
+	.enable = _clk_emma_enable,
+	.disable = _clk_emma_disable,
+};
+
+static struct clk slcdc_clk = {
+	.name = "slcdc_clk",
+	.parent = &ahb_clk,
+	.enable = _clk_slcdc_enable,
+	.disable = _clk_slcdc_disable,
+};
+
+static struct clk fec_clk = {
+	.name = "fec_clk",
+	.parent = &ahb_clk,
+	.enable = _clk_fec_enable,
+	.disable = _clk_fec_disable,
+};
+
+static struct clk emi_clk = {
+	.name = "emi_clk",
+	.parent = &ahb_clk,
+	.enable = _clk_enable,
+	.enable_reg = CCM_PCCR1,
+	.enable_shift = CCM_PCCR1_HCLK_EMI_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk sahara2_clk = {
+	.name = "sahara_clk",
+	.parent = &ahb_clk,
+	.enable = _clk_sahara2_enable,
+	.disable = _clk_sahara2_disable,
+};
+
+static struct clk ata_clk = {
+	.name = "ata_clk",
+	.parent = &ahb_clk,
+	.enable = _clk_enable,
+	.enable_reg = CCM_PCCR1,
+	.enable_shift = CCM_PCCR1_HCLK_ATA_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk mstick1_clk = {
+	.name = "mstick1_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_mstick1_enable,
+	.disable = _clk_mstick1_disable,
+};
+
+static struct clk wdog_clk = {
+	.name = "wdog_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = CCM_PCCR1,
+	.enable_shift = CCM_PCCR1_WDT_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk gpio_clk = {
+	.name = "gpio_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = CCM_PCCR1,
+	.enable_shift = CCM_PCCR0_GPIO_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk i2c_clk[] = {
+	{
+	 .name = "i2c_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR0,
+	 .enable_shift = CCM_PCCR0_I2C1_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "i2c_clk",
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR0,
+	 .enable_shift = CCM_PCCR0_I2C2_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk iim_clk = {
+	.name = "iim_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = CCM_PCCR0,
+	.enable_shift = CCM_PCCR0_IIM_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk kpp_clk = {
+	.name = "kpp_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = CCM_PCCR0,
+	.enable_shift = CCM_PCCR0_KPP_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk owire_clk = {
+	.name = "owire_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = CCM_PCCR0,
+	.enable_shift = CCM_PCCR0_OWIRE_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk rtc_clk = {
+	.name = "rtc_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = CCM_PCCR0,
+	.enable_shift = CCM_PCCR0_RTC_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk scc_clk = {
+	.name = "scc_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = CCM_PCCR0,
+	.enable_shift = CCM_PCCR0_SCC_OFFSET,
+	.disable = _clk_disable,
+};
+
+static unsigned long _clk_clko_round_rate(struct clk *clk, unsigned long rate)
+{
+	u32 div;
+
+	div = clk->parent->rate / rate;
+	if (clk->parent->rate % rate)
+		div++;
+
+	if (div > 8) {
+		div = 8;
+	}
+
+	return clk->parent->rate / div;
+}
+
+static int _clk_clko_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg;
+	u32 div;
+
+	div = clk->parent->rate / rate;
+
+	if (div > 8 || div < 1 || ((clk->parent->rate / div) != rate)) {
+		return -EINVAL;
+	}
+	div--;
+
+	reg = __raw_readl(CCM_PCDR0) & ~CCM_PCDR0_CLKODIV_MASK;
+	reg |= div << CCM_PCDR0_CLKODIV_OFFSET;
+	__raw_writel(reg, CCM_PCDR0);
+
+	clk->rate = rate;
+
+	return 0;
+}
+
+static void _clk_clko_recalc(struct clk *clk)
+{
+	u32 div;
+
+	div = __raw_readl(CCM_PCDR0) & CCM_PCDR0_CLKODIV_MASK >>
+	    CCM_PCDR0_CLKODIV_OFFSET;
+	div++;
+
+	clk->rate = clk->parent->rate / div;
+}
+
+static int _clk_clko_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	reg = __raw_readl(CCM_CCSR) & ~CCM_CCSR_CLKOSEL_MASK;
+
+	if (parent == &ckil_clk) {
+		reg |= 0 << CCM_CCSR_CLKOSEL_OFFSET;
+	} else if (parent == &ckih_clk) {
+		reg |= 2 << CCM_CCSR_CLKOSEL_OFFSET;
+	} else if (parent == mpll_clk.parent) {
+		reg |= 3 << CCM_CCSR_CLKOSEL_OFFSET;
+	} else if (parent == spll_clk.parent) {
+		reg |= 4 << CCM_CCSR_CLKOSEL_OFFSET;
+	} else if (parent == &mpll_clk) {
+		reg |= 5 << CCM_CCSR_CLKOSEL_OFFSET;
+	} else if (parent == &spll_clk) {
+		reg |= 6 << CCM_CCSR_CLKOSEL_OFFSET;
+	} else if (parent == &cpu_clk) {
+		reg |= 7 << CCM_CCSR_CLKOSEL_OFFSET;
+	} else if (parent == &ahb_clk) {
+		reg |= 8 << CCM_CCSR_CLKOSEL_OFFSET;
+	} else if (parent == &ipg_clk) {
+		reg |= 9 << CCM_CCSR_CLKOSEL_OFFSET;
+	} else if (parent == &per_clk[0]) {
+		reg |= 0xA << CCM_CCSR_CLKOSEL_OFFSET;
+	} else if (parent == &per_clk[1]) {
+		reg |= 0xB << CCM_CCSR_CLKOSEL_OFFSET;
+	} else if (parent == &per_clk[2]) {
+		reg |= 0xC << CCM_CCSR_CLKOSEL_OFFSET;
+	} else if (parent == &per_clk[3]) {
+		reg |= 0xD << CCM_CCSR_CLKOSEL_OFFSET;
+	} else if (parent == &ssi1_clk[0]) {
+		reg |= 0xE << CCM_CCSR_CLKOSEL_OFFSET;
+	} else if (parent == &ssi2_clk[0]) {
+		reg |= 0xF << CCM_CCSR_CLKOSEL_OFFSET;
+	} else if (parent == &nfc_clk) {
+		reg |= 0x10 << CCM_CCSR_CLKOSEL_OFFSET;
+	} else if (parent == &mstick1_clk) {
+		reg |= 0x11 << CCM_CCSR_CLKOSEL_OFFSET;
+	} else if (parent == &vpu_clk) {
+		reg |= 0x12 << CCM_CCSR_CLKOSEL_OFFSET;
+	} else if (parent == &usb_clk[0]) {
+		reg |= 0x15 << CCM_CCSR_CLKOSEL_OFFSET;
+	} else {
+		return -EINVAL;
+	}
+
+	__raw_writel(reg, CCM_CCSR);
+
+	return 0;
+}
+
+static int _clk_clko_enable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(CCM_PCDR0) | CCM_PCDR0_CLKO_EN;
+	__raw_writel(reg, CCM_PCDR0);
+
+	return 0;
+}
+
+static void _clk_clko_disable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(CCM_PCDR0) & ~CCM_PCDR0_CLKO_EN;
+	__raw_writel(reg, CCM_PCDR0);
+}
+
+static struct clk clko_clk = {
+	.name = "clko_clk",
+	.recalc = _clk_clko_recalc,
+	.set_rate = _clk_clko_set_rate,
+	.round_rate = _clk_clko_round_rate,
+	.set_parent = _clk_clko_set_parent,
+	.enable = _clk_clko_enable,
+	.disable = _clk_clko_disable,
+};
+
+static struct clk *mxc_clks[] = {
+	&ckih_clk,
+	&ckil_clk,
+	&mpll_clk,
+	&mpll_main_clk[0],
+	&mpll_main_clk[1],
+	&spll_clk,
+	&cpu_clk,
+	&ahb_clk,
+	&ipg_clk,
+	&per_clk[0],
+	&per_clk[1],
+	&per_clk[2],
+	&per_clk[3],
+	&clko_clk,
+	&uart1_clk[0],
+	&uart1_clk[1],
+	&uart2_clk[0],
+	&uart2_clk[1],
+	&uart3_clk[0],
+	&uart3_clk[1],
+	&uart4_clk[0],
+	&uart4_clk[1],
+	&uart5_clk[0],
+	&uart5_clk[1],
+	&uart6_clk[0],
+	&uart6_clk[1],
+	&gpt1_clk[0],
+	&gpt1_clk[1],
+	&gpt2_clk[0],
+	&gpt2_clk[1],
+	&gpt3_clk[0],
+	&gpt3_clk[1],
+	&gpt4_clk[0],
+	&gpt4_clk[1],
+	&gpt5_clk[0],
+	&gpt5_clk[1],
+	&gpt6_clk[0],
+	&gpt6_clk[1],
+	&pwm_clk[0],
+	&pwm_clk[1],
+	&sdhc1_clk[0],
+	&sdhc1_clk[1],
+	&sdhc2_clk[0],
+	&sdhc2_clk[1],
+	&sdhc3_clk[0],
+	&sdhc3_clk[1],
+	&cspi1_clk[0],
+	&cspi1_clk[1],
+	&cspi2_clk[0],
+	&cspi2_clk[1],
+	&cspi3_clk[0],
+	&cspi3_clk[1],
+	&lcdc_clk[0],
+	&lcdc_clk[1],
+	&lcdc_clk[2],
+	&csi_clk[0],
+	&csi_clk[1],
+	&usb_clk[0],
+	&usb_clk[1],
+	&ssi1_clk[0],
+	&ssi1_clk[1],
+	&ssi2_clk[0],
+	&ssi2_clk[1],
+	&nfc_clk,
+	&vpu_clk,
+	&dma_clk,
+	&rtic_clk,
+	&brom_clk,
+	&emma_clk,
+	&slcdc_clk,
+	&fec_clk,
+	&emi_clk,
+	&sahara2_clk,
+	&ata_clk,
+	&mstick1_clk,
+	&wdog_clk,
+	&gpio_clk,
+	&i2c_clk[0],
+	&i2c_clk[1],
+	&iim_clk,
+	&kpp_clk,
+	&owire_clk,
+	&rtc_clk,
+	&scc_clk,
+};
+
+static void probe_mxc_clocks(void)
+{
+	int i;
+
+	if (cpu_is_mx27_rev(CHIP_REV_2_0) > 0) {
+		if (CSCR() & 0x8000) {
+			cpu_clk.parent = &mpll_main_clk[0];
+		}
+
+		if (!(CSCR() & 0x00800000)) {
+			ssi2_clk[0].parent = &spll_clk;
+		}
+
+		if (!(CSCR() & 0x00400000)) {
+			ssi1_clk[0].parent = &spll_clk;
+		}
+
+		if (!(CSCR() & 0x00200000)) {
+			vpu_clk.parent = &spll_clk;
+		}
+	} else {
+		cpu_clk.parent = &mpll_clk;
+		cpu_clk.set_parent = NULL;
+		cpu_clk.round_rate = NULL;
+		cpu_clk.set_rate = NULL;
+		ahb_clk.parent = &mpll_clk;
+
+		for (i = 0; i < sizeof(per_clk) / sizeof(per_clk[0]); i++) {
+			per_clk[i].parent = &mpll_clk;
+		}
+
+		ssi1_clk[0].parent = &mpll_clk;
+		ssi2_clk[0].parent = &mpll_clk;
+
+		vpu_clk.parent = &mpll_clk;
+	}
+}
+
+/*!
+ * Function to get timer clock rate early in boot process before clock tree is
+ * initialized.
+ *
+ * @return	Clock rate for timer
+ */
+unsigned long __init clk_early_get_timer_rate(void)
+{
+	mxc_cpu_common_init();
+
+	if (CSCR() & CCM_CSCR_MCU) {
+		mpll_clk.parent = &ckih_clk;
+	} else {
+		mpll_clk.parent = &ckil_clk;
+	}
+
+	/* Determine which high frequency clock source is coming in */
+	if ((__raw_readw(PBC_VERSION_REG) & CKIH_27MHZ_BIT_SET) == 0) {
+		ckih_clk.rate = CKIH_CLK_FREQ_27MHZ;
+	} else {
+		ckih_clk.rate = CKIH_CLK_FREQ;
+	}
+	probe_mxc_clocks();
+	mpll_clk.recalc(&mpll_clk);
+	if (cpu_is_mx27_rev(CHIP_REV_2_0) > 0) {
+		mpll_main_clk[0].recalc(&mpll_main_clk[0]);
+		mpll_main_clk[1].recalc(&mpll_main_clk[1]);
+	}
+	per_clk[0].recalc(&per_clk[0]);
+	per_clk[0].enable(&per_clk[0]);
+	gpt1_clk[1].enable(&gpt1_clk[1]);
+	return per_clk[0].rate;
+}
+
+extern void propagate_rate(struct clk *tclk);
+
+int __init mxc_clocks_init(void)
+{
+	u32 cscr;
+	struct clk **clkp;
+
+	for (clkp = mxc_clks; clkp < mxc_clks + ARRAY_SIZE(mxc_clks); clkp++) {
+		if (*clkp == &mpll_main_clk[0] || *clkp == &mpll_main_clk[1]) {
+			if (cpu_is_mx27_rev(CHIP_REV_1_0) == 1)
+				continue;
+		}
+		clk_register(*clkp);
+	}
+
+	/* Turn off all possible clocks */
+	__raw_writel(CCM_PCCR0_GPT1_MASK, CCM_PCCR0);
+	__raw_writel(CCM_PCCR1_PERCLK1_MASK | CCM_PCCR1_HCLK_EMI_MASK,
+		     CCM_PCCR1);
+	spll_clk.disable(&spll_clk);
+
+	cscr = CSCR();
+	if (cscr & CCM_CSCR_MCU) {
+		mpll_clk.parent = &ckih_clk;
+	} else {
+		mpll_clk.parent = &ckil_clk;
+	}
+	if (cscr & CCM_CSCR_SP) {
+		spll_clk.parent = &ckih_clk;
+	} else {
+		spll_clk.parent = &ckil_clk;
+	}
+
+	/* Determine which high frequency clock source is coming in */
+	if ((__raw_readw(PBC_VERSION_REG) & CKIH_27MHZ_BIT_SET) == 0) {
+		ckih_clk.rate = CKIH_CLK_FREQ_27MHZ;
+	} else {
+		ckih_clk.rate = CKIH_CLK_FREQ;
+	}
+	pr_info("Clock input source is %ld\n", ckih_clk.rate);
+
+	/* This will propagate to all children and init all the clock rates */
+	propagate_rate(&ckih_clk);
+	propagate_rate(&ckil_clk);
+
+	clk_enable(&emi_clk);
+	clk_enable(&gpio_clk);
+	clk_enable(&iim_clk);
+	clk_enable(&gpt1_clk[0]);
+
+	return 0;
+}
Index: linux-2.6.18/arch/arm/mach-mx2/cpu.c
===================================================================
--- /dev/null
+++ linux-2.6.18/arch/arm/mach-mx2/cpu.c
@@ -0,0 +1,104 @@
+/*
+ * Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+/*!
+ * @file cpu.c
+ *
+ * @brief This file contains the CPU initialization code.
+ *
+ * @ingroup System
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <asm/setup.h>
+#include <asm/arch/hardware.h>
+#include <asm/io.h>
+
+#define SYS_CHIP_ID		(IO_ADDRESS(SYSCTRL_BASE_ADDR) + 0x0)
+#define SYS_CHIP_VERSION_OFFSET 28
+#define SYS_CHIP_VERSION_MASK   (0xF<<28)
+
+static const u32 system_rev_tbl[SYSTEM_REV_NUM][2] = {
+	/* SREV, own defined ver */
+	{0x00, CHIP_REV_1_0},	/* MX27 TO1 */
+	{0x01, CHIP_REV_2_0},	/* MX27 TO2 */
+};
+
+static int system_rev_updated;	/* = 0 */
+
+static void __init system_rev_setup(char **p)
+{
+	system_rev = simple_strtoul(*p, NULL, 16);
+	system_rev_updated = 1;
+}
+
+/* system_rev=0x00 for TO1; 0x01 for TO2; etc */
+__early_param("system_rev=", system_rev_setup);
+
+/*
+ * FIXME: i.MX27 TO2 has the private rule to indicate the version of chip
+ * This functions reads the CHIP ID register and returns the system revision
+ * number.
+ */
+static u32 read_system_rev(void)
+{
+	u32 val;
+	u32 i;
+
+	val = __raw_readl(SYS_CHIP_ID);
+	val = (val & SYS_CHIP_VERSION_MASK) >> SYS_CHIP_VERSION_OFFSET;
+	for (i = 0; i < SYSTEM_REV_NUM; i++) {
+		if (val == system_rev_tbl[i][0]) {
+			return system_rev_tbl[i][1];
+		}
+	}
+	if (i == SYSTEM_REV_NUM) {
+		val = system_rev_tbl[SYSTEM_REV_NUM - 1][1];
+		printk(KERN_ALERT "WARNING: Can't find valid system rev\n");
+		printk(KERN_ALERT "Assuming last known system_rev=0x%x\n", val);
+		return val;
+	}
+	return 0;
+}
+
+/*
+ * Update the system_rev value.
+ * If no system_rev is passed in through the command line, it gets the value
+ * from the IIM module. Otherwise, it uses the pass-in value.
+ */
+static void system_rev_update(void)
+{
+	int i;
+
+	if (!system_rev_updated) {
+		/* means NO value passed-in through command line */
+		system_rev = read_system_rev();
+		pr_info("system_rev is: 0x%x\n", system_rev);
+	} else {
+		pr_info("Command line passed system_rev: 0x%x\n", system_rev);
+		for (i = 0; i < SYSTEM_REV_NUM; i++) {
+			if (system_rev == system_rev_tbl[i][1]) {
+				break;
+			}
+		}
+		/* Reach here only the SREV value unknown.
+		 * Maybe due to new tapeout? */
+		if (i == SYSTEM_REV_NUM) {
+			panic("Command system_rev is unknown\n");
+		}
+	}
+}
+
+void mxc_cpu_common_init(void)
+{
+	system_rev_update();
+}
Index: linux-2.6.18/arch/arm/mach-mx2/crm_regs.h
===================================================================
--- /dev/null
+++ linux-2.6.18/arch/arm/mach-mx2/crm_regs.h
@@ -0,0 +1,258 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ARCH_ARM_MACH_MX2_CRM_REGS_H__
+#define __ARCH_ARM_MACH_MX2_CRM_REGS_H__
+
+#include <asm/arch/hardware.h>
+
+/* Register offsets */
+#define CCM_CSCR                (IO_ADDRESS(CCM_BASE_ADDR) + 0x0)
+#define CCM_MPCTL0              (IO_ADDRESS(CCM_BASE_ADDR) + 0x4)
+#define CCM_MPCTL1              (IO_ADDRESS(CCM_BASE_ADDR) + 0x8)
+#define CCM_SPCTL0              (IO_ADDRESS(CCM_BASE_ADDR) + 0xC)
+#define CCM_SPCTL1              (IO_ADDRESS(CCM_BASE_ADDR) + 0x10)
+#define CCM_OSC26MCTL           (IO_ADDRESS(CCM_BASE_ADDR) + 0x14)
+#define CCM_PCDR0               (IO_ADDRESS(CCM_BASE_ADDR) + 0x18)
+#define CCM_PCDR1               (IO_ADDRESS(CCM_BASE_ADDR) + 0x1c)
+#define CCM_PCCR0               (IO_ADDRESS(CCM_BASE_ADDR) + 0x20)
+#define CCM_PCCR1               (IO_ADDRESS(CCM_BASE_ADDR) + 0x24)
+#define CCM_CCSR                (IO_ADDRESS(CCM_BASE_ADDR) + 0x28)
+#define CCM_PMCTL               (IO_ADDRESS(CCM_BASE_ADDR) + 0x2c)
+#define CCM_PMCOUNT             (IO_ADDRESS(CCM_BASE_ADDR) + 0x30)
+#define CCM_WKGDCTL             (IO_ADDRESS(CCM_BASE_ADDR) + 0x34)
+
+#define CCM_CSCR_USB_OFFSET     28
+#define CCM_CSCR_USB_MASK       (0x7 << 28)
+#define CCM_CSCR_SD_OFFSET      24
+#define CCM_CSCR_SD_MASK        (0x3 << 24)
+#define CCM_CSCR_SSI2           (1 << 23)
+#define CCM_CSCR_SSI2_OFFSET    23
+#define CCM_CSCR_SSI1           (1 << 22)
+#define CCM_CSCR_SSI1_OFFSET    22
+#define CCM_CSCR_VPU            (1 << 21)
+#define CCM_CSCR_VPU_OFFSET     21
+#define CCM_CSCR_MSHC           (1 << 20)
+#define CCM_CSCR_SPLLRES        (1 << 19)
+#define CCM_CSCR_MPLLRES        (1 << 18)
+#define CCM_CSCR_SP             (1 << 17)
+#define CCM_CSCR_MCU            (1 << 16)
+#define CCM_CSCR_ARM_SRC        (1 << 15)
+#define CCM_CSCR_ARM_OFFSET     12
+#define CCM_CSCR_ARM_MASK       (0x3 << 12)
+#define CCM_CSCR_PRESC_OFFSET   13
+#define CCM_CSCR_PRESC_MASK     (0x7 << 13)
+#define CCM_CSCR_BCLK_OFFSET    9
+#define CCM_CSCR_BCLK_MASK      (0xf << 9)
+#define CCM_CSCR_IPDIV_OFFSET   8
+#define CCM_CSCR_IPDIV          (1 << 8)
+#define CCM_CSCR_AHB_OFFSET     8
+#define CCM_CSCR_AHB_MASK       (0x3 << 8)
+#define CCM_CSCR_OSC26MDIV      (1 << 4)
+#define CCM_CSCR_OSC26M         (1 << 3)
+#define CCM_CSCR_FPM            (1 << 2)
+#define CCM_CSCR_SPEN           (1 << 1)
+#define CCM_CSCR_MPEN           1
+
+#define CCM_MPCTL0_CPLM         (1 << 31)
+#define CCM_MPCTL0_PD_OFFSET    26
+#define CCM_MPCTL0_PD_MASK      (0xf << 26)
+#define CCM_MPCTL0_MFD_OFFSET   16
+#define CCM_MPCTL0_MFD_MASK     (0x3ff << 16)
+#define CCM_MPCTL0_MFI_OFFSET   10
+#define CCM_MPCTL0_MFI_MASK     (0xf << 10)
+#define CCM_MPCTL0_MFN_OFFSET   0
+#define CCM_MPCTL0_MFN_MASK     0x3ff
+
+#define CCM_MPCTL1_LF           (1 << 15)
+#define CCM_MPCTL1_BRMO         (1 << 6)
+
+#define CCM_SPCTL0_CPLM         (1 << 31)
+#define CCM_SPCTL0_PD_OFFSET    26
+#define CCM_SPCTL0_PD_MASK      (0xf << 26)
+#define CCM_SPCTL0_MFD_OFFSET   16
+#define CCM_SPCTL0_MFD_MASK     (0x3ff << 16)
+#define CCM_SPCTL0_MFI_OFFSET   10
+#define CCM_SPCTL0_MFI_MASK     (0xf << 10)
+#define CCM_SPCTL0_MFN_OFFSET   0
+#define CCM_SPCTL0_MFN_MASK     0x3ff
+
+#define CCM_SPCTL1_LF           (1 << 15)
+#define CCM_SPCTL1_BRMO         (1 << 6)
+
+#define CCM_OSC26MCTL_PEAK_OFFSET       16
+#define CCM_OSC26MCTL_PEAK_MASK         (0x3 << 16)
+#define CCM_OSC26MCTL_AGC_OFFSET        8
+#define CCM_OSC26MCTL_AGC_MASK          (0x3f << 8)
+#define CCM_OSC26MCTL_ANATEST_OFFSET    0
+#define CCM_OSC26MCTL_ANATEST_MASK      0x3f
+
+#define CCM_PCDR0_SSI2BAUDDIV_OFFSET    26
+#define CCM_PCDR0_SSI2BAUDDIV_MASK      (0x3f << 26)
+#define CCM_PCDR0_CLKO_EN               25
+#define CCM_PCDR0_CLKODIV_OFFSET        22
+#define CCM_PCDR0_CLKODIV_MASK          (0x7 << 22)
+#define CCM_PCDR0_SSI1BAUDDIV_OFFSET    16
+#define CCM_PCDR0_SSI1BAUDDIV_MASK      (0x3f << 16)
+#define CCM_PCDR0_VPUDIV2_OFFSET        10
+#define CCM_PCDR0_VPUDIV2_MASK          (0x3f << 10)
+#define CCM_PCDR0_NFCDIV2_OFFSET        6
+#define CCM_PCDR0_NFCDIV2_MASK          (0xf << 6)
+#define CCM_PCDR0_MSHCDIV2_MASK         0x3f
+#define CCM_PCDR0_NFCDIV_OFFSET         12
+#define CCM_PCDR0_NFCDIV_MASK           (0xf << 12)
+#define CCM_PCDR0_VPUDIV_OFFSET         8
+#define CCM_PCDR0_VPUDIV_MASK           (0xf << 8)
+#define CCM_PCDR0_MSHCDIV_OFFSET        0
+#define CCM_PCDR0_MSHCDIV_MASK          0x1f
+
+#define CCM_PCDR1_PERDIV4_OFFSET        24
+#define CCM_PCDR1_PERDIV4_MASK          (0x3f << 24)
+#define CCM_PCDR1_PERDIV3_OFFSET        16
+#define CCM_PCDR1_PERDIV3_MASK          (0x3f << 16)
+#define CCM_PCDR1_PERDIV2_OFFSET        8
+#define CCM_PCDR1_PERDIV2_MASK          (0x3f << 8)
+#define CCM_PCDR1_PERDIV1_OFFSET        0
+#define CCM_PCDR1_PERDIV1_MASK          0x3f
+
+#define CCM_PCCR0_CSPI1_OFFSET          31
+#define CCM_PCCR0_CSPI1_MASK            (1 << 31)
+#define CCM_PCCR0_CSPI2_OFFSET          30
+#define CCM_PCCR0_CSPI2_MASK            (1 << 30)
+#define CCM_PCCR0_CSPI3_OFFSET          29
+#define CCM_PCCR0_CSPI3_MASK            (1 << 29)
+#define CCM_PCCR0_DMA_OFFSET            28
+#define CCM_PCCR0_DMA_MASK              (1 << 28)
+#define CCM_PCCR0_EMMA_OFFSET           27
+#define CCM_PCCR0_EMMA_MASK             (1 << 27)
+#define CCM_PCCR0_FEC_OFFSET            26
+#define CCM_PCCR0_FEC_MASK              (1 << 26)
+#define CCM_PCCR0_GPIO_OFFSET           25
+#define CCM_PCCR0_GPIO_MASK             (1 << 25)
+#define CCM_PCCR0_GPT1_OFFSET           24
+#define CCM_PCCR0_GPT1_MASK             (1 << 24)
+#define CCM_PCCR0_GPT2_OFFSET           23
+#define CCM_PCCR0_GPT2_MASK             (1 << 23)
+#define CCM_PCCR0_GPT3_OFFSET           22
+#define CCM_PCCR0_GPT3_MASK             (1 << 22)
+#define CCM_PCCR0_GPT4_OFFSET           21
+#define CCM_PCCR0_GPT4_MASK             (1 << 21)
+#define CCM_PCCR0_GPT5_OFFSET           20
+#define CCM_PCCR0_GPT5_MASK             (1 << 20)
+#define CCM_PCCR0_GPT6_OFFSET           19
+#define CCM_PCCR0_GPT6_MASK             (1 << 19)
+#define CCM_PCCR0_I2C1_OFFSET           18
+#define CCM_PCCR0_I2C1_MASK             (1 << 18)
+#define CCM_PCCR0_I2C2_OFFSET           17
+#define CCM_PCCR0_I2C2_MASK             (1 << 17)
+#define CCM_PCCR0_IIM_OFFSET            16
+#define CCM_PCCR0_IIM_MASK              (1 << 16)
+#define CCM_PCCR0_KPP_OFFSET            15
+#define CCM_PCCR0_KPP_MASK              (1 << 15)
+#define CCM_PCCR0_LCDC_OFFSET           14
+#define CCM_PCCR0_LCDC_MASK             (1 << 14)
+#define CCM_PCCR0_MSHC_OFFSET           13
+#define CCM_PCCR0_MSHC_MASK             (1 << 13)
+#define CCM_PCCR0_OWIRE_OFFSET          12
+#define CCM_PCCR0_OWIRE_MASK            (1 << 12)
+#define CCM_PCCR0_PWM_OFFSET            11
+#define CCM_PCCR0_PWM_MASK              (1 << 11)
+#define CCM_PCCR0_RTC_OFFSET            9
+#define CCM_PCCR0_RTC_MASK              (1 << 9)
+#define CCM_PCCR0_RTIC_OFFSET           8
+#define CCM_PCCR0_RTIC_MASK             (1 << 8)
+#define CCM_PCCR0_SAHARA_OFFSET         7
+#define CCM_PCCR0_SAHARA_MASK           (1 << 7)
+#define CCM_PCCR0_SCC_OFFSET            6
+#define CCM_PCCR0_SCC_MASK              (1 << 6)
+#define CCM_PCCR0_SDHC1_OFFSET          5
+#define CCM_PCCR0_SDHC1_MASK            (1 << 5)
+#define CCM_PCCR0_SDHC2_OFFSET          4
+#define CCM_PCCR0_SDHC2_MASK            (1 << 4)
+#define CCM_PCCR0_SDHC3_OFFSET          3
+#define CCM_PCCR0_SDHC3_MASK            (1 << 3)
+#define CCM_PCCR0_SLCDC_OFFSET          2
+#define CCM_PCCR0_SLCDC_MASK            (1 << 2)
+#define CCM_PCCR0_SSI1_IPG_OFFSET       1
+#define CCM_PCCR0_SSI1_IPG_MASK         (1 << 1)
+#define CCM_PCCR0_SSI2_IPG_OFFSET       0
+#define CCM_PCCR0_SSI2_IPG_MASK         (1 << 0)
+
+#define CCM_PCCR1_UART1_OFFSET          31
+#define CCM_PCCR1_UART1_MASK            (1 << 31)
+#define CCM_PCCR1_UART2_OFFSET          30
+#define CCM_PCCR1_UART2_MASK            (1 << 30)
+#define CCM_PCCR1_UART3_OFFSET          29
+#define CCM_PCCR1_UART3_MASK            (1 << 29)
+#define CCM_PCCR1_UART4_OFFSET          28
+#define CCM_PCCR1_UART4_MASK            (1 << 28)
+#define CCM_PCCR1_UART5_OFFSET          27
+#define CCM_PCCR1_UART5_MASK            (1 << 27)
+#define CCM_PCCR1_UART6_OFFSET          26
+#define CCM_PCCR1_UART6_MASK            (1 << 26)
+#define CCM_PCCR1_USBOTG_OFFSET         25
+#define CCM_PCCR1_USBOTG_MASK           (1 << 25)
+#define CCM_PCCR1_WDT_OFFSET            24
+#define CCM_PCCR1_WDT_MASK              (1 << 24)
+#define CCM_PCCR1_HCLK_ATA_OFFSET       23
+#define CCM_PCCR1_HCLK_ATA_MASK         (1 << 23)
+#define CCM_PCCR1_HCLK_BROM_OFFSET      22
+#define CCM_PCCR1_HCLK_BROM_MASK        (1 << 22)
+#define CCM_PCCR1_HCLK_CSI_OFFSET       21
+#define CCM_PCCR1_HCLK_CSI_MASK         (1 << 21)
+#define CCM_PCCR1_HCLK_DMA_OFFSET       20
+#define CCM_PCCR1_HCLK_DMA_MASK         (1 << 20)
+#define CCM_PCCR1_HCLK_EMI_OFFSET       19
+#define CCM_PCCR1_HCLK_EMI_MASK         (1 << 19)
+#define CCM_PCCR1_HCLK_EMMA_OFFSET      18
+#define CCM_PCCR1_HCLK_EMMA_MASK        (1 << 18)
+#define CCM_PCCR1_HCLK_FEC_OFFSET       17
+#define CCM_PCCR1_HCLK_FEC_MASK         (1 << 17)
+#define CCM_PCCR1_HCLK_VPU_OFFSET       16
+#define CCM_PCCR1_HCLK_VPU_MASK         (1 << 16)
+#define CCM_PCCR1_HCLK_LCDC_OFFSET      15
+#define CCM_PCCR1_HCLK_LCDC_MASK        (1 << 15)
+#define CCM_PCCR1_HCLK_RTIC_OFFSET      14
+#define CCM_PCCR1_HCLK_RTIC_MASK        (1 << 14)
+#define CCM_PCCR1_HCLK_SAHARA_OFFSET    13
+#define CCM_PCCR1_HCLK_SAHARA_MASK      (1 << 13)
+#define CCM_PCCR1_HCLK_SLCDC_OFFSET     12
+#define CCM_PCCR1_HCLK_SLCDC_MASK       (1 << 12)
+#define CCM_PCCR1_HCLK_USBOTG_OFFSET    11
+#define CCM_PCCR1_HCLK_USBOTG_MASK      (1 << 11)
+#define CCM_PCCR1_PERCLK1_OFFSET        10
+#define CCM_PCCR1_PERCLK1_MASK          (1 << 10)
+#define CCM_PCCR1_PERCLK2_OFFSET        9
+#define CCM_PCCR1_PERCLK2_MASK          (1 << 9)
+#define CCM_PCCR1_PERCLK3_OFFSET        8
+#define CCM_PCCR1_PERCLK3_MASK          (1 << 8)
+#define CCM_PCCR1_PERCLK4_OFFSET        7
+#define CCM_PCCR1_PERCLK4_MASK          (1 << 7)
+#define CCM_PCCR1_VPU_BAUD_OFFSET       6
+#define CCM_PCCR1_VPU_BAUD_MASK         (1 << 6)
+#define CCM_PCCR1_SSI1_BAUD_OFFSET      5
+#define CCM_PCCR1_SSI1_BAUD_MASK        (1 << 5)
+#define CCM_PCCR1_SSI2_BAUD_OFFSET      4
+#define CCM_PCCR1_SSI2_BAUD_MASK        (1 << 4)
+#define CCM_PCCR1_NFC_BAUD_OFFSET       3
+#define CCM_PCCR1_NFC_BAUD_MASK         (1 << 3)
+#define CCM_PCCR1_MSHC_BAUD_OFFSET      2
+#define CCM_PCCR1_MSHC_BAUD_MASK        (1 << 2)
+
+#define CCM_CCSR_32KSR			(1 << 15)
+#define CCM_CCSR_CLKMODE1		(1 << 9)
+#define CCM_CCSR_CLKMODE0		(1 << 8)
+#define CCM_CCSR_CLKOSEL_OFFSET		0
+#define CCM_CCSR_CLKOSEL_MASK		0x1f
+
+#endif
Index: linux-2.6.18/arch/arm/mach-mx2/mx27ads.c
===================================================================
--- linux-2.6.18.orig/arch/arm/mach-mx2/mx27ads.c
+++ linux-2.6.18/arch/arm/mach-mx2/mx27ads.c
@@ -98,6 +98,7 @@ static void __init mx27ads_board_init(vo
 {
 	pr_info("AIPI VA base: 0x%x\n", IO_ADDRESS(AIPI_BASE_ADDR));
 
+	mxc_clocks_init();
 	mxc_init_extuart();
 }
 
Index: linux-2.6.18/arch/arm/mach-mx2/time.c
===================================================================
--- linux-2.6.18.orig/arch/arm/mach-mx2/time.c
+++ linux-2.6.18/arch/arm/mach-mx2/time.c
@@ -39,6 +39,8 @@
 #define MXC_GPT_TPRER_TICK		MXC_GPT_TPRER(MXC_TIMER_GPT1)
 #define MXC_GPT_TCN_TICK		MXC_GPT_TCN(MXC_TIMER_GPT1)
 
+extern unsigned long clk_early_get_timer_rate(void);
+
 /*!
  * This is the timer interrupt service routine to do required tasks.
  *
@@ -94,8 +96,7 @@ void mxc_init_time(void)
 
 	__raw_writel(reg, MXC_GPT_TCTL_TICK);
 
-	/* TODO: get timer rate from clk driver */
-	v = 13300000;
+	v = clk_early_get_timer_rate();
 
 	if ((v % CLOCK_TICK_RATE) != 0) {
 		pr_info("\nWARNING: Can't generate CLOCK_TICK_RATE at %d Hz\n",
Index: linux-2.6.18/arch/arm/plat-mxc/Makefile
===================================================================
--- linux-2.6.18.orig/arch/arm/plat-mxc/Makefile
+++ linux-2.6.18/arch/arm/plat-mxc/Makefile
@@ -3,4 +3,4 @@
 #
 
 # Common support
-obj-y := irq.o
+obj-y := irq.o clock.o
Index: linux-2.6.18/arch/arm/plat-mxc/clock.c
===================================================================
--- /dev/null
+++ linux-2.6.18/arch/arm/plat-mxc/clock.c
@@ -0,0 +1,489 @@
+/*
+ * Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+/*
+ *  Based on arch/arm/plat-omap/clock.c
+ *
+ *  Copyright (C) 2004 - 2005 Nokia corporation
+ *  Written by Tuukka Tikkanen <tuukka.tikkanen@elektrobit.com>
+ *  Modified for omap shared clock framework by Tony Lindgren <tony@atomide.com>
+ */
+/*!
+ * @file plat-mxc/clock.c
+ *
+ * @brief clk API implementation for MXC clocks.
+ *
+ * This file contains API defined in include/linux/clk.h for setting up and
+ * retrieving clocks.
+ *
+ * @ingroup CLOCKS
+ */
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/string.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/proc_fs.h>
+
+#include <asm/io.h>
+#include <asm/semaphore.h>
+
+#include <asm/arch/clock.h>
+
+static LIST_HEAD(clocks);
+static DEFINE_MUTEX(clocks_mutex);
+static DEFINE_SPINLOCK(clockfw_lock);
+
+/*-------------------------------------------------------------------------
+ * Standard clock functions defined in include/linux/clk.h
+ *-------------------------------------------------------------------------*/
+
+/*!
+ * @brief Function to retrieve a clock by name.
+ *
+ * Note that we first try to use device id on the bus
+ * and clock name. If this fails, we try to use "<name>.<id>". If this fails,
+ * we try to use clock name only.
+ *
+ * The reference count to the clock's module owner ref count is incremented.
+ *
+ * @param dev 	Device structure to get bus device id.
+ * @param id	Clock name string
+ *
+ * @return	Returns handle to clock on success or -ENOENT on failure.
+ */
+struct clk *clk_get(struct device *dev, const char *id)
+{
+	struct clk *p, *clk = ERR_PTR(-ENOENT);
+	int idno;
+	char *str;
+
+	if (id == NULL)
+		return clk;
+
+	if (dev == NULL || dev->bus != &platform_bus_type)
+		idno = -1;
+	else
+		idno = to_platform_device(dev)->id;
+
+	mutex_lock(&clocks_mutex);
+
+	list_for_each_entry(p, &clocks, node) {
+		if (p->id == idno &&
+		    strcmp(id, p->name) == 0 && try_module_get(p->owner)) {
+			clk = p;
+			goto found;
+		}
+	}
+
+	str = strrchr(id, '.');
+	if (str) {
+		str[0] = '\0';
+		str++;
+		idno = simple_strtol(str, NULL, 10);
+		list_for_each_entry(p, &clocks, node) {
+			if (p->id == idno &&
+			    strcmp(id, p->name) == 0 &&
+			    try_module_get(p->owner)) {
+				clk = p;
+				goto found;
+			}
+		}
+	}
+
+	list_for_each_entry(p, &clocks, node) {
+		if (strcmp(id, p->name) == 0 && try_module_get(p->owner)) {
+			clk = p;
+			goto found;
+		}
+	}
+
+	printk(KERN_WARNING "clk: Unable to get requested clock: %s\n", id);
+
+found:
+	mutex_unlock(&clocks_mutex);
+
+	return clk;
+}
+EXPORT_SYMBOL(clk_get);
+
+static void __clk_disable(struct clk *clk)
+{
+	if (clk->usecount > 0 && !(--clk->usecount)) {
+		if (clk->disable != NULL) {
+			clk->disable(clk);
+		}
+		if (likely((u32) clk->parent))
+			__clk_disable(clk->parent);
+		if (unlikely((u32) clk->secondary))
+			__clk_disable(clk->secondary);
+	}
+}
+
+static int __clk_enable(struct clk *clk)
+{
+	int ret = 0;
+
+	if (clk->usecount++ == 0) {
+		if (likely((u32) clk->parent)) {
+			ret = __clk_enable(clk->parent);
+
+			if (unlikely(ret != 0)) {
+				goto err1;
+			}
+		}
+
+		if (unlikely((u32) clk->secondary)) {
+			ret = __clk_enable(clk->secondary);
+
+			if (unlikely(ret != 0)) {
+				goto err2;
+			}
+		}
+
+		if (clk->enable) {
+			ret = clk->enable(clk);
+		}
+
+		if (unlikely(ret != 0)) {
+			goto err3;
+		}
+	}
+	return 0;
+
+err3:
+	if (clk->secondary)
+		__clk_disable(clk->secondary);
+err2:
+	if (clk->parent)
+		__clk_disable(clk->parent);
+err1:
+	clk->usecount--;
+	return ret;
+}
+
+/*!
+ * @brief Function to enable a clock.
+ *
+ * This function increments the reference count on the clock and enables the
+ * clock if not already enabled. The parent clock tree is recursively enabled.
+ *
+ * @param clk 	Handle to clock to enable.
+ *
+ * @return	Returns 0 on success or error code on failure.
+ */
+int clk_enable(struct clk *clk)
+{
+	unsigned long flags;
+	int ret = 0;
+
+	if (clk == NULL || IS_ERR(clk))
+		return -EINVAL;
+
+	spin_lock_irqsave(&clockfw_lock, flags);
+
+	ret = __clk_enable(clk);
+
+	spin_unlock_irqrestore(&clockfw_lock, flags);
+
+	return ret;
+}
+EXPORT_SYMBOL(clk_enable);
+
+/*!
+ * @brief Function to disable a clock.
+ *
+ * This function decrements the reference count on the clock and disables the
+ * clock when reference count is 0. The parent clock tree is recursively
+ * disabled.
+ *
+ * @param clk 	Handle to clock to disable.
+ *
+ */
+void clk_disable(struct clk *clk)
+{
+	unsigned long flags;
+
+	if (clk == NULL || IS_ERR(clk))
+		return;
+
+	spin_lock_irqsave(&clockfw_lock, flags);
+
+	__clk_disable(clk);
+
+	spin_unlock_irqrestore(&clockfw_lock, flags);
+}
+EXPORT_SYMBOL(clk_disable);
+
+/*!
+ * @brief Function to get the usage count for the requested clock.
+ *
+ * This function returns the reference count for the clock.
+ *
+ * @param clk 	Handle to clock to disable.
+ *
+ * @return Returns the usage count for the requested clock.
+ */
+int clk_get_usecount(struct clk *clk)
+{
+	if (clk == NULL || IS_ERR(clk))
+		return 0;
+
+	return clk->usecount;
+}
+EXPORT_SYMBOL(clk_get_usecount);
+
+/*!
+ * @brief Function to retrieve the clock rate for a clock.
+ *
+ * @param clk 	Handle to clock to retrieve.
+ *
+ * @return	Returns the clock's rate in Hz.
+ *
+ */
+unsigned long clk_get_rate(struct clk *clk)
+{
+	if (clk == NULL || IS_ERR(clk))
+		return 0;
+
+	return clk->rate;
+}
+EXPORT_SYMBOL(clk_get_rate);
+
+/*!
+ * @brief Function to decrement the clock's module reference count.
+ *
+ * @param clk 	Handle to clock to put.
+ *
+ */
+void clk_put(struct clk *clk)
+{
+	if (clk && !IS_ERR(clk))
+		module_put(clk->owner);
+}
+EXPORT_SYMBOL(clk_put);
+
+/*!
+ * @brief Function to round the requested clock rate to the nearest supported
+ * rate that is less than or equal to the requested rate. This is dependent on
+ * the clock's current parent.
+ *
+ * @param clk 	Handle to clock to retrieve.
+ * @param rate	Desired clock rate in Hz.
+ *
+ * @return	Returns the nearest supported rate in Hz.
+ *
+ */
+long clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	if (clk == NULL || IS_ERR(clk) || !clk->round_rate)
+		return 0;
+
+	return clk->round_rate(clk, rate);
+}
+EXPORT_SYMBOL(clk_round_rate);
+
+/* Propagate rate to children */
+void propagate_rate(struct clk *tclk)
+{
+	struct clk *clkp;
+
+	if (tclk == NULL || IS_ERR(tclk))
+		return;
+
+	pr_debug("mxc clock: finding children of %s-%d\n", tclk->name,
+		 tclk->id);
+	list_for_each_entry(clkp, &clocks, node) {
+		if (likely(clkp->parent != tclk))
+			continue;
+		pr_debug("mxc clock: %s-%d: recalculating rate: old = %lu, ",
+			 clkp->name, clkp->id, clkp->rate);
+		if (likely((u32) clkp->recalc))
+			clkp->recalc(clkp);
+		else
+			clkp->rate = tclk->rate;
+		pr_debug("new = %lu\n", clkp->rate);
+		propagate_rate(clkp);
+	}
+}
+
+/*!
+ * @brief Function to set the clock to the requested clock rate. The rate must
+ * match a supported rate exactly based on what clk_round_rate returns.
+ *
+ * @param clk 	Handle to clock to retrieve.
+ * @param rate	Desired clock rate in Hz.
+ *
+ * @return	Returns 0 on success, negative error code on failure.
+ *
+ */
+int clk_set_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long flags;
+	int ret = -EINVAL;
+
+	if (clk == NULL || IS_ERR(clk) || clk->set_rate == NULL || rate == 0)
+		return ret;
+
+	spin_lock_irqsave(&clockfw_lock, flags);
+
+	ret = clk->set_rate(clk, rate);
+	if (likely(ret == 0))
+		propagate_rate(clk);
+
+	spin_unlock_irqrestore(&clockfw_lock, flags);
+
+	return ret;
+}
+EXPORT_SYMBOL(clk_set_rate);
+
+/*!
+ * @brief Function to set the clock's parent to another clock source.
+ *
+ * @param clk 	Handle to clock to retrieve.
+ * @param parent Desired parent clock input for the clock.
+ *
+ * @return	Returns 0 on success, negative error code on failure.
+ *
+ */
+int clk_set_parent(struct clk *clk, struct clk *parent)
+{
+	unsigned long flags;
+	int ret = -EINVAL;
+
+	if (clk == NULL || IS_ERR(clk) || parent == NULL ||
+	    IS_ERR(parent) || clk->set_parent == NULL)
+		return ret;
+
+	spin_lock_irqsave(&clockfw_lock, flags);
+	ret = clk->set_parent(clk, parent);
+	if (ret == 0) {
+		clk->parent = parent;
+		if (clk->recalc) {
+			clk->recalc(clk);
+		} else {
+			clk->rate = parent->rate;
+		}
+		propagate_rate(clk);
+	}
+	spin_unlock_irqrestore(&clockfw_lock, flags);
+
+	return ret;
+}
+EXPORT_SYMBOL(clk_set_parent);
+
+/*!
+ * @brief Function to retrieve the clock's parent clock source.
+ *
+ * @param clk 	Handle to clock to retrieve.
+ *
+ * @return	Returns parent clk on success, NULL on failure.
+ *
+ */
+struct clk *clk_get_parent(struct clk *clk)
+{
+	struct clk *ret = NULL;
+
+	if (clk == NULL || IS_ERR(clk))
+		return ret;
+
+	return clk->parent;
+}
+EXPORT_SYMBOL(clk_get_parent);
+
+/*!
+ * @brief Function to add a new clock to the clock tree.
+ *
+ * @param clk 	Handle to clock to add.
+ *
+ * @return	Returns 0 on success, negative error code on failure.
+ *
+ */
+int clk_register(struct clk *clk)
+{
+	if (clk == NULL || IS_ERR(clk))
+		return -EINVAL;
+
+	mutex_lock(&clocks_mutex);
+	list_add(&clk->node, &clocks);
+	mutex_unlock(&clocks_mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL(clk_register);
+
+/*!
+ * @brief Function to remove a clock from the clock tree.
+ *
+ * @param clk 	Handle to clock to add.
+ *
+ */
+void clk_unregister(struct clk *clk)
+{
+	if (clk == NULL || IS_ERR(clk))
+		return;
+
+	mutex_lock(&clocks_mutex);
+	list_del(&clk->node);
+	mutex_unlock(&clocks_mutex);
+}
+EXPORT_SYMBOL(clk_unregister);
+
+#ifdef CONFIG_PROC_FS
+static int mxc_clock_read_proc(char *page, char **start, off_t off,
+			       int count, int *eof, void *data)
+{
+	struct clk *clkp;
+	char *p = page;
+	int len;
+
+	list_for_each_entry(clkp, &clocks, node) {
+		p += sprintf(p, "%s-%d:\t\t%lu, %d",
+			     clkp->name, clkp->id, clkp->rate, clkp->usecount);
+		if (clkp->parent)
+			p += sprintf(p, ", %s-%d\n", clkp->parent->name,
+				     clkp->parent->id);
+		else
+			p += sprintf(p, "\n");
+	}
+
+	len = (p - page) - off;
+	if (len < 0)
+		len = 0;
+
+	*eof = (len <= count) ? 1 : 0;
+	*start = page + off;
+
+	return len;
+}
+
+static int __init mxc_setup_proc_entry(void)
+{
+	struct proc_dir_entry *res;
+
+	res = create_proc_read_entry("cpu/clocks", 0, NULL,
+				     mxc_clock_read_proc, NULL);
+	if (!res) {
+		printk(KERN_ERR "Failed to create proc/cpu/clocks\n");
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+late_initcall(mxc_setup_proc_entry);
+#endif
Index: linux-2.6.18/include/asm-arm/arch-mxc/clock.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/asm-arm/arch-mxc/clock.h
@@ -0,0 +1,81 @@
+/*
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_CLOCK_H__
+#define __ASM_ARCH_MXC_CLOCK_H__
+
+/*!
+ * @defgroup CLOCKS Clock Control API
+ */
+/*!
+ * @file arch-mxc/clock.h
+ *
+ * @brief API for setting up and retrieving clocks.
+ *
+ * This file contains API for setting up and retrieving clocks.
+ *
+ * @ingroup CLOCKS
+ */
+#ifndef __ASSEMBLY__
+#include <linux/list.h>
+
+struct module;
+
+/*!
+ * MXC specific struct for defining and controlling a single clock.
+ *
+ * This structure should not be accessed directly. Use clk_xxx API all
+ * clock accesses.
+ */
+struct clk {
+	struct list_head node;
+	struct module *owner;
+	const char *name;
+	int id;
+	/*! Source clock this clk depends on */
+	struct clk *parent;
+	/*! Secondary clock to enable/disable with this clock */
+	struct clk *secondary;
+	/*! Current clock rate */
+	unsigned long rate;
+	/*! Reference count of clock enable/disable */
+	__s8 usecount;
+	/*! Register bit position for clock's enable/disable control. */
+	u8 enable_shift;
+	/*! Register address for clock's enable/disable control. */
+	u32 enable_reg;
+	/*! Function ptr to recalculate the clock's rate based on parent
+	   clock's rate */
+	void (*recalc) (struct clk *);
+	/*! Function ptr to set the clock to a new rate. The rate must match a
+	   supported rate returned from round_rate. Leave blank if clock is not
+	   programmable */
+	int (*set_rate) (struct clk *, unsigned long);
+	/*! Function ptr to round the requested clock rate to the nearest
+	   supported rate that is less than or equal to the requested rate. */
+	unsigned long (*round_rate) (struct clk *, unsigned long);
+	/*! Function ptr to enable the clock. Leave blank if clock can not
+	   be gated. */
+	int (*enable) (struct clk *);
+	/*! Function ptr to disable the clock. Leave blank if clock can not
+	   be gated. */
+	void (*disable) (struct clk *);
+	/*! Function ptr to set the parent clock of the clock. */
+	int (*set_parent) (struct clk *, struct clk *);
+};
+
+extern int clk_register(struct clk *clk);
+extern void clk_unregister(struct clk *clk);
+
+#endif				/* __ASSEMBLY__ */
+#endif				/* __ASM_ARCH_MXC_CLOCK_H__ */
Index: linux-2.6.18/include/asm-arm/arch-mxc/common.h
===================================================================
--- linux-2.6.18.orig/include/asm-arm/arch-mxc/common.h
+++ linux-2.6.18/include/asm-arm/arch-mxc/common.h
@@ -15,6 +15,7 @@ struct sys_timer;
 
 extern void mxc_map_io(void);
 extern void mxc_init_irq(void);
+extern void mxc_clocks_init(void);
 extern struct sys_timer mxc_timer;
 
 #endif
Index: linux-2.6.18/include/asm-arm/arch-mxc/hardware.h
===================================================================
--- linux-2.6.18.orig/include/asm-arm/arch-mxc/hardware.h
+++ linux-2.6.18/include/asm-arm/arch-mxc/hardware.h
@@ -28,6 +28,53 @@
 #define MXC_MAX_GPIO_LINES      (GPIO_NUM_PIN * GPIO_PORT_NUM)
 
 /*
+ * Processor specific defines
+ * ---------------------------------------------------------------------------
+ */
+#define CHIP_REV_1_0		0x10
+#define CHIP_REV_1_1		0x11
+#define CHIP_REV_1_2		0x12
+#define CHIP_REV_1_3		0x13
+#define CHIP_REV_2_0		0x20
+#define CHIP_REV_2_1		0x21
+#define CHIP_REV_2_2		0x22
+#define CHIP_REV_2_3		0x23
+#define CHIP_REV_3_0		0x30
+#define CHIP_REV_3_1		0x31
+#define CHIP_REV_3_2		0x32
+
+#ifndef cpu_is_mx27
+#define cpu_is_mx27()		(0)
+#endif
+
+#if !defined(__ASSEMBLY__) && !defined(__MXC_BOOT_UNCOMPRESS)
+
+/*
+ * Create inline functions to test for cpu revision
+ * Function name is cpu_is_<cpu name>_rev(rev)
+ *
+ * Returns:
+ *	 0 - not the cpu queried
+ *	 1 - cpu and revision match
+ *	 2 - cpu matches, but cpu revision is greater than queried rev
+ *	-1 - cpu matches, but cpu revision is less than queried rev
+ */
+
+extern unsigned int system_rev;
+#define _is_rev(rev) ((system_rev == rev) ? 1 : ((system_rev < rev) ? -1 : 2))
+
+#define MXC_REV(type)				\
+static inline int type## _rev (int rev)		\
+{						\
+	return (type() ? _is_rev(rev) : 0);	\
+}
+
+MXC_REV(cpu_is_mx27);
+
+#endif
+
+/*
+ * ---------------------------------------------------------------------------
  * ---------------------------------------------------------------------------
  * Board specific defines
  * ---------------------------------------------------------------------------
Index: linux-2.6.18/include/asm-arm/arch-mxc/mx27.h
===================================================================
--- linux-2.6.18.orig/include/asm-arm/arch-mxc/mx27.h
+++ linux-2.6.18/include/asm-arm/arch-mxc/mx27.h
@@ -286,4 +286,9 @@
 #define GPT_CTRL_MASK           0xFFFFFFF1
 #define GPT_CTRL_OFFSET	    	1
 
+#define SYSTEM_REV_MIN          CHIP_REV_0_0
+#define SYSTEM_REV_NUM          2
+
+#define cpu_is_mx27()		(1)
+
 #endif				/* __ASM_ARCH_MXC_MX27_H__ */
Index: linux-2.6.18/mvl_patches/pro50-0106.c
===================================================================
--- /dev/null
+++ linux-2.6.18/mvl_patches/pro50-0106.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(106);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

