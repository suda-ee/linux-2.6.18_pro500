#! /usr/bin/env bash
# Patch: -POWERPC_Fix_interrupt_routing_and_setup_of_ULI_M15
# Date: Fri Oct 26 08:42:31 2007
# Source: Kernel.org
# MR: 25195
# Type: Enhancement
# Disposition: merged from Kernel.org
# Signed-off-by: Randy Vinson <rvinson@mvista.com>
# Description:
# From b66510cb9992d204f216049e9c01d432c7635f6c Mon Sep 17 00:00:00 2001
# From: Kumar Gala <galak@kernel.crashing.org>
# Date: Thu, 16 Aug 2007 23:55:55 -0500
# Subject: [PATCH] [POWERPC] Fix interrupt routing and setup of ULI M1575 on FSL boards
# 
# The interrupt routing in the device trees for the ULI M1575 was
# inproperly using the interrupt line field as pci function.  Fixed
# up the device tree's to actual conform for to specification and
# changed the interrupt mapping code so it just uses a static mapping
# setup as follows:
# 
# PIRQA - IRQ9
# PIRQB - IRQ10
# PIRQC - IRQ11
# PIRQD - IRQ12
# USB 1.1 OCHI (1c.0) - IRQ12
# USB 1.1 OCHI (1c.1) - IRQ9
# USB 1.1 OCHI (1c.2) - IRQ10
# USB 1.1 ECHI (1c.3) - IRQ11
# LAN (1b.0) - IRQ6
# AC97 (1d.0) - IRQ6
# Modem (1d.1) - IRQ6
# HD Audio (1d.2) - IRQ6
# SATA (1f.1) - IRQ5
# SMB (1e.1) - IRQ7
# PMU (1e.2) - IRQ7
# PATA (1f.0) - IRQ14/15
# 
# Took the oppurtunity to refactor the code into a single file so we
# don't have to duplicate these fixes on the two current boards in the
# tree and several forth coming boards that will also need the code.
# 
# Fixed RTC support that requires a dummy memory read on the P2P bridge
# to unlock the RTC and setup the default of the RTC alarm registers to
# match with a basic x86 style CMOS RTC.
# 
# Moved code that poked ISA registers to a FIXUP_FINAL quirk to ensure
# the PCI IO space has been setup properly before we start poking ISA
# registers at random locations.
# 
# Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
# 
# NOTE: This patch interferes with the 8641 keyboard and mouse support
# added to the internal tree. This support is not in the community and
# is not a required feature for the release. If it is needed, it will
# be added by a follow on patch.
# 

PATCHNUM=548
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Source: Kernel.org
MR: 25195
Type: Enhancement
Disposition: merged from Kernel.org
Signed-off-by: Randy Vinson <rvinson@mvista.com>
Description:
From b66510cb9992d204f216049e9c01d432c7635f6c Mon Sep 17 00:00:00 2001
From: Kumar Gala <galak@kernel.crashing.org>
Date: Thu, 16 Aug 2007 23:55:55 -0500
Subject: [PATCH] [POWERPC] Fix interrupt routing and setup of ULI M1575 on FSL boards

The interrupt routing in the device trees for the ULI M1575 was
inproperly using the interrupt line field as pci function.  Fixed
up the device tree's to actual conform for to specification and
changed the interrupt mapping code so it just uses a static mapping
setup as follows:

PIRQA - IRQ9
PIRQB - IRQ10
PIRQC - IRQ11
PIRQD - IRQ12
USB 1.1 OCHI (1c.0) - IRQ12
USB 1.1 OCHI (1c.1) - IRQ9
USB 1.1 OCHI (1c.2) - IRQ10
USB 1.1 ECHI (1c.3) - IRQ11
LAN (1b.0) - IRQ6
AC97 (1d.0) - IRQ6
Modem (1d.1) - IRQ6
HD Audio (1d.2) - IRQ6
SATA (1f.1) - IRQ5
SMB (1e.1) - IRQ7
PMU (1e.2) - IRQ7
PATA (1f.0) - IRQ14/15

Took the oppurtunity to refactor the code into a single file so we
don't have to duplicate these fixes on the two current boards in the
tree and several forth coming boards that will also need the code.

Fixed RTC support that requires a dummy memory read on the P2P bridge
to unlock the RTC and setup the default of the RTC alarm registers to
match with a basic x86 style CMOS RTC.

Moved code that poked ISA registers to a FIXUP_FINAL quirk to ensure
the PCI IO space has been setup properly before we start poking ISA
registers at random locations.

Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

NOTE: This patch interferes with the 8641 keyboard and mouse support
added to the internal tree. This support is not in the community and
is not a required feature for the release. If it is needed, it will
be added by a follow on patch.

Index: linux-2.6.18/arch/powerpc/boot/dts/mpc8544ds.dts
===================================================================
--- linux-2.6.18.orig/arch/powerpc/boot/dts/mpc8544ds.dts
+++ linux-2.6.18/arch/powerpc/boot/dts/mpc8544ds.dts
@@ -44,8 +44,18 @@
 		#size-cells = <1>;
 		#interrupt-cells = <2>;
 		device_type = "soc";
-		ranges = <0 e0000000 00100000>;
-		reg = <e0000000 00100000>;	// CCSRBAR 1M
+
+
+		ranges = <00001000 e0001000 000ff000
+			  80000000 80000000 20000000
+			  a0000000 a0000000 10000000
+			  b0000000 b0000000 00100000
+			  c0000000 c0000000 20000000
+			  b0100000 b0100000 00100000
+			  e1000000 e1000000 00010000
+			  e1010000 e1010000 00010000
+			  e1020000 e1020000 00010000>;
+		reg = <e0000000 00001000>;	// CCSRBAR 1M
 		bus-frequency = <0>;		// Filled out by uboot.
 
 		memory-controller@2000 {
@@ -159,8 +169,8 @@
 			interrupt-parent = <&mpic>;
 			interrupts = <18 2>;
 			bus-range = <0 ff>;
-			ranges = <02000000 0 80000000 80000000 0 10000000
-				  01000000 0 00000000 e2000000 0 00800000>;
+			ranges = <02000000 0 c0000000 c0000000 0 20000000
+				  01000000 0 00000000 e1000000 0 00010000>;
 			clock-frequency = <3f940aa>;
 			#interrupt-cells = <1>;
 			#size-cells = <2>;
@@ -176,8 +186,8 @@
 			#address-cells = <3>;
 			reg = <9000 1000>;
 			bus-range = <0 ff>;
-			ranges = <02000000 0 90000000 90000000 0 10000000
-				  01000000 0 00000000 e3000000 0 00800000>;
+			ranges = <02000000 0 80000000 80000000 0 20000000
+				  01000000 0 00000000 e1010000 0 00010000>;
 			clock-frequency = <1fca055>;
 			interrupt-parent = <&mpic>;
 			interrupts = <1a 2>;
@@ -200,7 +210,7 @@
 			reg = <a000 1000>;
 			bus-range = <0 ff>;
 			ranges = <02000000 0 a0000000 a0000000 0 10000000
-				  01000000 0 00000000 e2800000 0 00800000>;
+				  01000000 0 00000000 e1020000 0 00010000>;
 			clock-frequency = <1fca055>;
 			interrupt-parent = <&mpic>;
 			interrupts = <19 2>;
@@ -222,49 +232,29 @@
 			#address-cells = <3>;
 			reg = <b000 1000>;
 			bus-range = <0 ff>;
-			ranges = <02000000 0 b0000000 b0000000 0 10000000
-				  01000000 0 00000000 e3800000 0 00800000>;
+			ranges = <02000000 0 b0000000 b0000000 0 00100000
+				  01000000 0 00000000 b0100000 0 00100000>;
 			clock-frequency = <1fca055>;
 			interrupt-parent = <&mpic>;
 			interrupts = <1b 2>;
-			interrupt-map-mask = <f800 0 0 7>;
+			interrupt-map-mask = <fb00 0 0 0>;
 			interrupt-map = <
-
-				// IDSEL 0x1a
-				d000 0 0 1 &i8259 6 2
-				d000 0 0 2 &i8259 3 2
-				d000 0 0 3 &i8259 4 2
-				d000 0 0 4 &i8259 5 2
-
-				// IDSEL 0x1b
-				d800 0 0 1 &i8259 5 2
-				d800 0 0 2 &i8259 0 0
-				d800 0 0 3 &i8259 0 0
-				d800 0 0 4 &i8259 0 0
-
 				// IDSEL 0x1c  USB
-				e000 0 0 1 &i8259 9 2
-				e000 0 0 2 &i8259 a 2
-				e000 0 0 3 &i8259 c 2
-				e000 0 0 4 &i8259 7 2
+				e000 0 0 0 &i8259 c 2
+				e100 0 0 0 &i8259 9 2
+				e200 0 0 0 &i8259 a 2
+				e300 0 0 0 &i8259 b 2
 
 				// IDSEL 0x1d  Audio
-				e800 0 0 1 &i8259 9 2
-				e800 0 0 2 &i8259 a 2
-				e800 0 0 3 &i8259 b 2
-				e800 0 0 4 &i8259 0 0
+				e800 0 0 0 &i8259 6 2
 
 				// IDSEL 0x1e Legacy
-				f000 0 0 1 &i8259 c 2
-				f000 0 0 2 &i8259 0 0
-				f000 0 0 3 &i8259 0 0
-				f000 0 0 4 &i8259 0 0
+				f000 0 0 0 &i8259 7 2
+				f100 0 0 0 &i8259 7 2
 
 				// IDSEL 0x1f IDE/SATA
-				f800 0 0 1 &i8259 6 2
-				f800 0 0 2 &i8259 0 0
-				f800 0 0 3 &i8259 0 0
-				f800 0 0 4 &i8259 0 0
+				f800 0 0 0 &i8259 e 2
+				f900 0 0 0 &i8259 5 2
 			>;
 			uli1575@0 {
 				reg = <0 0 0 0 0>;
@@ -272,10 +262,10 @@
 				#address-cells = <3>;
 				ranges = <02000000 0 b0000000
 					  02000000 0 b0000000
-					  0 10000000
+					  0 00100000
 					  01000000 0 00000000
 					  01000000 0 00000000
-					  0 00080000>;
+					  0 00100000>;
 
 				pci_bridge@0 {
 					reg = <0 0 0 0 0>;
@@ -283,7 +273,7 @@
 					#address-cells = <3>;
 					ranges = <02000000 0 b0000000
 						  02000000 0 b0000000
-						  0 20000000
+						  0 00100000
 						  01000000 0 00000000
 						  01000000 0 00000000
 						  0 00100000>;
@@ -294,7 +284,8 @@
 						#size-cells = <1>;
 						#address-cells = <2>;
 						reg = <f000 0 0 0 0>;
-						ranges = <1 0 01000000 0 0
+						ranges = <1 0
+							  01000000 0 0
 							  00001000>;
 						interrupt-parent = <&i8259>;
 
@@ -310,8 +301,7 @@
 							built-in;
 							compatible = "chrp,iic";
 							interrupts = <9 2>;
-							interrupt-parent =
-								<&mpic>;
+							interrupt-parent = <&mpic>;
 						};
 
 						i8042@60 {
@@ -319,8 +309,7 @@
 							#address-cells = <1>;
 							reg = <1 60 1 1 64 1>;
 							interrupts = <1 3 c 3>;
-							interrupt-parent =
-								<&i8259>;
+							interrupt-parent = <&i8259>;
 
 							keyboard@0 {
 								reg = <0>;
@@ -334,8 +323,7 @@
 						};
 
 						rtc@70 {
-							compatible =
-								"pnpPNP,b00";
+							compatible = "pnpPNP,b00";
 							reg = <1 70 2>;
 						};
 
Index: linux-2.6.18/arch/powerpc/boot/dts/mpc8641_hpcn.dts
===================================================================
--- linux-2.6.18.orig/arch/powerpc/boot/dts/mpc8641_hpcn.dts
+++ linux-2.6.18/arch/powerpc/boot/dts/mpc8641_hpcn.dts
@@ -221,98 +221,36 @@
 			clock-frequency = <1fca055>;
 			interrupt-parent = <&mpic>;
 			interrupts = <18 2>;
-			interrupt-map-mask = <f800 0 0 7>;
+			interrupt-map-mask = <fb00 0 0 0>;
 			interrupt-map = <
 				/* IDSEL 0x11 */
-				8800 0 0 1 &i8259 3 2
-				8800 0 0 2 &i8259 4 2
-				8800 0 0 3 &i8259 5 2
-				8800 0 0 4 &i8259 6 2
+				8800 0 0 1 &i8259 9 2
+				8800 0 0 2 &i8259 a 2
+				8800 0 0 3 &i8259 b 2
+				8800 0 0 4 &i8259 c 2
 
 				/* IDSEL 0x12 */
-				9000 0 0 1 &i8259 4 2
-				9000 0 0 2 &i8259 5 2
-				9000 0 0 3 &i8259 6 2
-				9000 0 0 4 &i8259 3 2
-
-				/* IDSEL 0x13 */
-				9800 0 0 1 &i8259 0 0
-				9800 0 0 2 &i8259 0 0
-				9800 0 0 3 &i8259 0 0
-				9800 0 0 4 &i8259 0 0
-
-				/* IDSEL 0x14 */
-				a000 0 0 1 &i8259 0 0
-				a000 0 0 2 &i8259 0 0
-				a000 0 0 3 &i8259 0 0
-				a000 0 0 4 &i8259 0 0
-
-				/* IDSEL 0x15 */
-				a800 0 0 1 &i8259 0 0
-				a800 0 0 2 &i8259 0 0
-				a800 0 0 3 &i8259 0 0
-				a800 0 0 4 &i8259 0 0
-
-				/* IDSEL 0x16 */
-				b000 0 0 1 &i8259 0 0
-				b000 0 0 2 &i8259 0 0
-				b000 0 0 3 &i8259 0 0
-				b000 0 0 4 &i8259 0 0
-
-				/* IDSEL 0x17 */
-				b800 0 0 1 &i8259 0 0
-				b800 0 0 2 &i8259 0 0
-				b800 0 0 3 &i8259 0 0
-				b800 0 0 4 &i8259 0 0
-
-				/* IDSEL 0x18 */
-				c000 0 0 1 &i8259 0 0
-				c000 0 0 2 &i8259 0 0
-				c000 0 0 3 &i8259 0 0
-				c000 0 0 4 &i8259 0 0
-
-				/* IDSEL 0x19 */
-				c800 0 0 1 &i8259 0 0
-				c800 0 0 2 &i8259 0 0
-				c800 0 0 3 &i8259 0 0
-				c800 0 0 4 &i8259 0 0
-
-				/* IDSEL 0x1a */
-				d000 0 0 1 &i8259 6 2
-				d000 0 0 2 &i8259 3 2
-				d000 0 0 3 &i8259 4 2
-				d000 0 0 4 &i8259 5 2
-
-
-				/* IDSEL 0x1b */
-				d800 0 0 1 &i8259 5 2
-				d800 0 0 2 &i8259 0 0
-				d800 0 0 3 &i8259 0 0
-				d800 0 0 4 &i8259 0 0
-
-				/* IDSEL 0x1c */
-				e000 0 0 1 &i8259 9 2
-				e000 0 0 2 &i8259 a 2
-				e000 0 0 3 &i8259 b 2
-				e000 0 0 4 &i8259 7 2
-
-				/* IDSEL 0x1d */
-				e800 0 0 1 &i8259 9 2
-				e800 0 0 2 &i8259 a 2
-				e800 0 0 3 &i8259 b 2
-				e800 0 0 4 &i8259 0 0
-
-				/* IDSEL 0x1e */
-				f000 0 0 1 &i8259 b 2
-				f000 0 0 2 &i8259 0 0
-				f000 0 0 3 &i8259 0 0
-				f000 0 0 4 &i8259 0 0
-
-				/* IDSEL 0x1f */
-				f800 0 0 1 &i8259 6 2
-				f800 0 0 2 &i8259 0 0
-				f800 0 0 3 &i8259 0 0
-				f800 0 0 4 &i8259 0 0
+				9000 0 0 1 &i8259 a 2
+				9000 0 0 2 &i8259 b 2
+				9000 0 0 3 &i8259 c 2
+				9000 0 0 4 &i8259 9 2
+
+				// IDSEL 0x1c  USB
+				e000 0 0 0 &i8259 c 2
+				e100 0 0 0 &i8259 9 2
+				e200 0 0 0 &i8259 a 2
+				e300 0 0 0 &i8259 b 2
+
+				// IDSEL 0x1d  Audio
+				e800 0 0 0 &i8259 6 2
+
+				// IDSEL 0x1e Legacy
+				f000 0 0 0 &i8259 7 2
+				f100 0 0 0 &i8259 7 2
+
+				// IDSEL 0x1f IDE/SATA
+				f800 0 0 0 &i8259 e 2
+				f900 0 0 0 &i8259 5 2
 				>;
 			uli1575@0 {
 				reg = <0 0 0 0 0>;
Index: linux-2.6.18/arch/powerpc/platforms/85xx/Kconfig
===================================================================
--- linux-2.6.18.orig/arch/powerpc/platforms/85xx/Kconfig
+++ linux-2.6.18/arch/powerpc/platforms/85xx/Kconfig
@@ -33,6 +33,7 @@ config MPC8544_DS
 	bool "Freescale MPC8544 DS"
 	select PPC_I8259
 	select DEFAULT_UIMAGE
+	select FSL_ULI1575
 	help
 	  This option enables support for the MPC8544 DS board
 
Index: linux-2.6.18/arch/powerpc/platforms/85xx/mpc8544_ds.c
===================================================================
--- linux-2.6.18.orig/arch/powerpc/platforms/85xx/mpc8544_ds.c
+++ linux-2.6.18/arch/powerpc/platforms/85xx/mpc8544_ds.c
@@ -115,211 +115,25 @@ void __init mpc8544_ds_pic_init(void)
 }
 
 #ifdef CONFIG_PCI
-enum pirq { PIRQA = 8, PIRQB, PIRQC, PIRQD, PIRQE, PIRQF, PIRQG, PIRQH };
+extern int uses_fsl_uli_m1575;
+extern int uli_exclude_device(struct pci_controller *hose,
+				u_char bus, u_char devfn);
 
-/*
- * Value in  table -- IRQ number
- */
-const unsigned char uli1575_irq_route_table[16] = {
-	0,		/* 0: Reserved */
-	0x8,
-	0,		/* 2: Reserved */
-	0x2,
-	0x4,
-	0x5,
-	0x7,
-	0x6,
-	0,		/* 8: Reserved */
-	0x1,
-	0x3,
-	0x9,
-	0xb,
-	0,		/* 13: Reserved */
-	0xd,
-	0xf,
-};
-
-static int __devinit
-get_pci_irq_from_of(struct pci_controller *hose, int slot, int pin)
+static int mpc85xx_exclude_device(struct pci_controller *hose,
+				   u_char bus, u_char devfn)
 {
-	struct of_irq oirq;
-	u32 laddr[3];
-	struct device_node *hosenode = hose ? hose->arch_data : NULL;
-
-	if (!hosenode)
-		return -EINVAL;
-
-	laddr[0] = (hose->first_busno << 16) | (PCI_DEVFN(slot, 0) << 8);
-	laddr[1] = laddr[2] = 0;
-	of_irq_map_raw(hosenode, &pin, 1, laddr, &oirq);
-	DBG("mpc8544_ds: pci irq addr %x, slot %d, pin %d, irq %d\n",
-	    laddr[0], slot, pin, oirq.specifier[0]);
-	return oirq.specifier[0];
-}
+	struct device_node* node;
+	struct resource rsrc;
 
-/*8259*/
-static void __devinit quirk_uli1575(struct pci_dev *dev)
-{
-	unsigned short temp;
-	struct pci_controller *hose = pci_bus_to_host(dev->bus);
-	unsigned char irq2pin[16];
-	unsigned long pirq_map_word = 0;
-	u32 irq;
-	int i;
-
-	/*
-	 * ULI1575 interrupts route setup
-	 */
-	memset(irq2pin, 0, 16);	/* Initialize default value 0 */
-
-	irq2pin[6]=PIRQA+3;	/* enabled mapping for IRQ6 to PIRQD, used by SATA */
-
-	/*
-	 * PIRQE -> PIRQF mapping set manually
-	 *
-	 * IRQ pin   IRQ#
-	 * PIRQE ---- 9
-	 * PIRQF ---- 10
-	 * PIRQG ---- 11
-	 * PIRQH ---- 12
-	 */
-	for (i = 0; i < 4; i++)
-		irq2pin[i + 9] = PIRQE + i;
-
-	/* Set IRQ-PIRQ Mapping to ULI1575 */
-	for (i = 0; i < 16; i++)
-		if (irq2pin[i])
-			pirq_map_word |= (uli1575_irq_route_table[i] & 0xf)
-			    << ((irq2pin[i] - PIRQA) * 4);
-
-	pirq_map_word |= 1<<26;	/* disable INTx in EP mode*/
-
-	/* ULI1575 IRQ mapping conf register default value is 0xb9317542 */
-	DBG("Setup ULI1575 IRQ mapping configuration register value = 0x%x\n",
-		(int)pirq_map_word);
-	pci_write_config_dword(dev, 0x48, pirq_map_word);
-
-#define ULI1575_SET_DEV_IRQ(slot, pin, reg)				\
-	do {								\
-		int irq;						\
-		irq = get_pci_irq_from_of(hose, slot, pin);		\
-		if (irq > 0 && irq < 16) 				\
-			pci_write_config_byte(dev, reg, irq2pin[irq]);	\
-		else							\
-			printk(KERN_WARNING "ULI1575 device"		\
-				"(slot %d, pin %d) irq %d is invalid.\n", \
-				slot, pin, irq);			\
-	} while(0)
-
-	/* USB 1.1 OHCI controller 1, slot 28, pin 1 */
-	ULI1575_SET_DEV_IRQ(28, 1, 0x86);
-
-	/* USB 1.1 OHCI controller 2, slot 28, pin 2 */
-	ULI1575_SET_DEV_IRQ(28, 2, 0x87);
-
-	/* USB 1.1 OHCI controller 3, slot 28, pin 3 */
-	ULI1575_SET_DEV_IRQ(28, 3, 0x88);
-
-	/* USB 2.0 controller, slot 28, pin 4 */
-	irq = get_pci_irq_from_of(hose, 28, 4);
-	if (irq >= 0 && irq <= 15)
-		pci_write_config_dword(dev, 0x74, uli1575_irq_route_table[irq]);
-
-	/* Audio controller, slot 29, pin 1 */
-	ULI1575_SET_DEV_IRQ(29, 1, 0x8a);
-
-	/* Modem controller, slot 29, pin 2 */
-	ULI1575_SET_DEV_IRQ(29, 2, 0x8b);
-
-	/* HD audio controller, slot 29, pin 3 */
-	ULI1575_SET_DEV_IRQ(29, 3, 0x8c);
-
-	/* SMB interrupt: slot 30, pin 1 */
-	ULI1575_SET_DEV_IRQ(30, 1, 0x8e);
-
-	/* PMU ACPI SCI interrupt: slot 30, pin 2 */
-	ULI1575_SET_DEV_IRQ(30, 2, 0x8f);
-
-	/* Serial ATA interrupt: slot 31, pin 1 */
-	ULI1575_SET_DEV_IRQ(31, 1, 0x8d);
-
-	/* Primary PATA IDE IRQ: 14
-	 * Secondary PATA IDE IRQ: 15
-	 */
-	pci_write_config_byte(dev, 0x44, 0x30 | uli1575_irq_route_table[14]);
-	pci_write_config_byte(dev, 0x75, uli1575_irq_route_table[15]);
-
-	/* Set IRQ14 and IRQ15 to legacy IRQs */
-	pci_read_config_word(dev, 0x46, &temp);
-	temp |= 0xc000;
-	pci_write_config_word(dev, 0x46, temp);
-
-	/* Set i8259 interrupt trigger
-	 * IRQ 3:  Level
-	 * IRQ 4:  Level
-	 * IRQ 5:  Level
-	 * IRQ 6:  Level
-	 * IRQ 7:  Level
-	 * IRQ 9:  Level
-	 * IRQ 10: Level
-	 * IRQ 11: Level
-	 * IRQ 12: Level
-	 * IRQ 14: Edge
-	 * IRQ 15: Edge
-	 */
-	outb(0xfa, 0x4d0);
-	outb(0x1e, 0x4d1);
-
-#undef ULI1575_SET_DEV_IRQ
-}
+	node = (struct device_node *)hose->arch_data;
+	of_address_to_resource(node, 0, &rsrc);
 
-/* SATA */
-static void __devinit quirk_uli5288(struct pci_dev *dev)
-{
-	unsigned char c;
-
-	pci_read_config_byte(dev, 0x83, &c);
-	c |= 0x80;		/* read/write lock */
-	pci_write_config_byte(dev, 0x83, c);
-
-	pci_write_config_byte(dev, 0x09, 0x01);	/* Base class code: storage */
-	pci_write_config_byte(dev, 0x0a, 0x06);	/* IDE disk */
-
-	pci_read_config_byte(dev, 0x83, &c);
-	c &= 0x7f;
-	pci_write_config_byte(dev, 0x83, c);
-
-	pci_read_config_byte(dev, 0x84, &c);
-	c |= 0x01;				/* emulated PATA mode enabled */
-	pci_write_config_byte(dev, 0x84, c);
-}
-
-/* PATA */
-static void __devinit quirk_uli5229(struct pci_dev *dev)
-{
-	unsigned short temp;
-	pci_write_config_word(dev, 0x04, 0x0405);	/* MEM IO MSI */
-	pci_read_config_word(dev, 0x4a, &temp);
-	temp |= 0x1000;				/* Enable Native IRQ 14/15 */
-	pci_write_config_word(dev, 0x4a, temp);
-}
+	if ((rsrc.start & 0xfffff) == 0xb000) {
+		return uli_exclude_device(hose, bus, devfn);
+	}
 
-/*Bridge*/
-static void __devinit early_uli5249(struct pci_dev *dev)
-{
-	unsigned char temp;
-	pci_write_config_word(dev, 0x04, 0x0007);	/* mem access */
-	pci_read_config_byte(dev, 0x7c, &temp);
-	pci_write_config_byte(dev, 0x7c, 0x80);	/* R/W lock control */
-	pci_write_config_byte(dev, 0x09, 0x01);	/* set as pci-pci bridge */
-	pci_write_config_byte(dev, 0x7c, temp);	/* restore pci bus debug control */
-	dev->class |= 0x1;
+	return PCIBIOS_SUCCESSFUL;
 }
-
-DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_AL, 0x1575, quirk_uli1575);
-DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_AL, 0x5288, quirk_uli5288);
-DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_AL, 0x5229, quirk_uli5229);
-DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_AL, 0x5249, early_uli5249);
 #endif	/* CONFIG_PCI */
 
 /*
@@ -343,6 +157,8 @@ static void __init mpc8544_ds_setup_arch
 		else
 			fsl_add_bridge(np, 0);
 	}
+	uses_fsl_uli_m1575 = 1;
+	ppc_md.pci_exclude_device = mpc85xx_exclude_device;
 #endif
 
 	printk("MPC8544 DS board from Freescale Semiconductor\n");
Index: linux-2.6.18/arch/powerpc/platforms/86xx/Kconfig
===================================================================
--- linux-2.6.18.orig/arch/powerpc/platforms/86xx/Kconfig
+++ linux-2.6.18/arch/powerpc/platforms/86xx/Kconfig
@@ -7,6 +7,7 @@ config MPC8641_HPCN
 	bool "Freescale MPC8641 HPCN"
 	select PPC_I8259
 	select DEFAULT_UIMAGE
+	select FSL_ULI1575
 	help
 	  This option enables support for the MPC8641 HPCN board.
 
Index: linux-2.6.18/arch/powerpc/platforms/86xx/mpc86xx_hpcn.c
===================================================================
--- linux-2.6.18.orig/arch/powerpc/platforms/86xx/mpc86xx_hpcn.c
+++ linux-2.6.18/arch/powerpc/platforms/86xx/mpc86xx_hpcn.c
@@ -143,287 +143,25 @@ static inline u8 __init sio_read(u8 inde
 	return inb(sio_res.start + 1);
 }
 
-enum pirq{PIRQA = 8, PIRQB, PIRQC, PIRQD, PIRQE, PIRQF, PIRQG, PIRQH};
-const unsigned char uli1575_irq_route_table[16] = {
-	0, 	/* 0: Reserved */
-	0x8, 	/* 1: 0b1000 */
-	0, 	/* 2: Reserved */
-	0x2,	/* 3: 0b0010 */
-	0x4,	/* 4: 0b0100 */
-	0x5, 	/* 5: 0b0101 */
-	0x7,	/* 6: 0b0111 */
-	0x6,	/* 7: 0b0110 */
-	0, 	/* 8: Reserved */
-	0x1,	/* 9: 0b0001 */
-	0x3,	/* 10: 0b0011 */
-	0x9,	/* 11: 0b1001 */
-	0,	/* 12: Reserved */
-	0, 	/* 13: Reserved */
-	0xd,	/* 14, 0b1101 */
-	0xf,	/* 15, 0b1111 */
-};
-
-static int __devinit
-get_pci_irq_from_of(struct pci_controller *hose, int slot, int pin)
-{
-	struct of_irq oirq;
-	u32 laddr[3];
-	struct device_node *hosenode = hose ? hose->arch_data : NULL;
-
-	if (!hosenode) return -EINVAL;
-
-	laddr[0] = (hose->first_busno << 16) | (PCI_DEVFN(slot, 0) << 8);
-	laddr[1] = laddr[2] = 0;
-	of_irq_map_raw(hosenode, &pin, 1, laddr, &oirq);
-	DBG("mpc86xx_hpcn: pci irq addr %x, slot %d, pin %d, irq %d\n",
-			laddr[0], slot, pin, oirq.specifier[0]);
-	return oirq.specifier[0];
-}
+extern int uses_fsl_uli_m1575;
+extern int uli_exclude_device(struct pci_controller *hose,
+		u_char bus, u_char devfn);
 
-static void __devinit quirk_uli1575(struct pci_dev *dev)
+static int mpc86xx_exclude_device(struct pci_controller *hose,
+		u_char bus, u_char devfn)
 {
-	unsigned short temp;
-	struct pci_controller *hose = pci_bus_to_host(dev->bus);
-	unsigned char irq2pin[16], c;
-	unsigned long pirq_map_word = 0;
-	u32 irq;
-	int i;
-	struct device_node *np;
-
-	/*
-	 * ULI1575 interrupts route setup
-	 */
-	memset(irq2pin, 0, 16); /* Initialize default value 0 */
-
-	/*
-	 * PIRQA -> PIRQD mapping read from OF-tree
-	 *
-	 * interrupts for PCI slot0 -- PIRQA / PIRQB / PIRQC / PIRQD
-	 *                PCI slot1 -- PIRQB / PIRQC / PIRQD / PIRQA
-	 */
-	for (i = 0; i < 4; i++){
-		irq = get_pci_irq_from_of(hose, 17, i + 1);
-		if (irq > 0 && irq < 16)
-			irq2pin[irq] = PIRQA + i;
-		else
-			printk(KERN_WARNING "ULI1575 device"
-			    "(slot %d, pin %d) irq %d is invalid.\n",
-			    17, i, irq);
-	}
-
-	/*
-	 * PIRQE -> PIRQF mapping set manually
-	 *
-	 * IRQ pin   IRQ#
-	 * PIRQE ---- 9
-	 * PIRQF ---- 10
-	 * PIRQG ---- 11
-	 * PIRQH ---- 12
-	 */
-	for (i = 0; i < 4; i++) irq2pin[i + 9] = PIRQE + i;
-
-	/* Set IRQ-PIRQ Mapping to ULI1575 */
-	for (i = 0; i < 16; i++)
-		if (irq2pin[i])
-			pirq_map_word |= (uli1575_irq_route_table[i] & 0xf)
-				<< ((irq2pin[i] - PIRQA) * 4);
-
-	/* ULI1575 IRQ mapping conf register default value is 0x09317542 */
-	DBG("Setup ULI1575 IRQ mapping configuration register value = 0x%x\n",
-			pirq_map_word);
-	pci_write_config_dword(dev, 0x48, pirq_map_word);
-
-#define ULI1575_SET_DEV_IRQ(slot, pin, reg) 				\
-	do { 								\
-		int irq; 						\
-		irq = get_pci_irq_from_of(hose, slot, pin); 		\
-		if (irq > 0 && irq < 16) 				\
-			pci_write_config_byte(dev, reg, irq2pin[irq]); 	\
-		else							\
-			printk(KERN_WARNING "ULI1575 device"		\
-			    "(slot %d, pin %d) irq %d is invalid.\n",	\
-			    slot, pin, irq);				\
-	} while(0)
-
-	/* USB 1.1 OHCI controller 1, slot 28, pin 1 */
-	ULI1575_SET_DEV_IRQ(28, 1, 0x86);
-
-	/* USB 1.1 OHCI controller 2, slot 28, pin 2 */
-	ULI1575_SET_DEV_IRQ(28, 2, 0x87);
-
-	/* USB 1.1 OHCI controller 3, slot 28, pin 3 */
-	ULI1575_SET_DEV_IRQ(28, 3, 0x88);
-
-	/* USB 2.0 controller, slot 28, pin 4 */
-	irq = get_pci_irq_from_of(hose, 28, 4);
-	if (irq >= 0 && irq <=15)
-		pci_write_config_dword(dev, 0x74, uli1575_irq_route_table[irq]);
-
-	/* Audio controller, slot 29, pin 1 */
-	ULI1575_SET_DEV_IRQ(29, 1, 0x8a);
-
-	/* Modem controller, slot 29, pin 2 */
-	ULI1575_SET_DEV_IRQ(29, 2, 0x8b);
-
-	/* HD audio controller, slot 29, pin 3 */
-	ULI1575_SET_DEV_IRQ(29, 3, 0x8c);
-
-	/* SMB interrupt: slot 30, pin 1 */
-	ULI1575_SET_DEV_IRQ(30, 1, 0x8e);
-
-	/* PMU ACPI SCI interrupt: slot 30, pin 2 */
-	ULI1575_SET_DEV_IRQ(30, 2, 0x8f);
-
-	/* Serial ATA interrupt: slot 31, pin 1 */
-	ULI1575_SET_DEV_IRQ(31, 1, 0x8d);
-
-	/* Primary PATA IDE IRQ: 14
-	 * Secondary PATA IDE IRQ: 15
-	 */
-	pci_write_config_byte(dev, 0x44, 0x30 | uli1575_irq_route_table[14]);
-	pci_write_config_byte(dev, 0x75, uli1575_irq_route_table[15]);
-
-	/* Set IRQ1, IRQ12, IRQ14 and IRQ15 to legacy IRQs */
-	pci_read_config_word(dev, 0x46, &temp);
-	temp |= 0xd002;
-	pci_write_config_word(dev, 0x46, temp);
-
-	/* Set i8259 interrupt trigger
-	 * IRQ 3:  Level
-	 * IRQ 4:  Level
-	 * IRQ 5:  Level
-	 * IRQ 6:  Level
-	 * IRQ 7:  Level
-	 * IRQ 9:  Level
-	 * IRQ 10: Level
-	 * IRQ 11: Level
-	 * IRQ 12: Edge
-	 * IRQ 14: Edge
-	 * IRQ 15: Edge
-	 */
-	outb(0xf8, 0x4d0);
-	outb(0x0e, 0x4d1);
-
-#undef ULI1575_SET_DEV_IRQ
-
-	/* Disable the HD interface and enable the AC97 interface. */
-	pci_read_config_byte(dev, 0xb8, &c);
-	c &= 0x7f;
-	pci_write_config_byte(dev, 0xb8, c);
-
-	/* Enable superio and keyboard/mouse address decoding */
-	pci_write_config_byte(dev, 0x63, 0x90);
-
-	/* Configure superio keyboard/mouse */
-	if (!(np = of_find_compatible_node(NULL, NULL, "pnpPNP,303")))
-		np = of_find_compatible_node(NULL, NULL, "pnpPNP,f03");
-	if (np) {
-		struct device_node *sio, *parent;
-
-		parent = of_get_parent(np);
-		of_node_put(np);
-		if (parent) {
+	struct device_node* node;
+	struct resource rsrc;
 
-			sio = find_sio_node(parent);
+	node = (struct device_node *)hose->arch_data;
+	of_address_to_resource(node, 0, &rsrc);
 
-			if (sio) {
-				const u32 * ints;
-				if ((ints = get_property(parent,
-							 "interrupts",
-							 NULL))) {
-					/*
-					 * Activate keyboard (device 0x7) and
-					 * write IRQ's from device tree.
-					 */
-					sio_read(0x55); /* enter config mode */
-
-					sio_write(0x07, 0x07);
-					sio_write(0x01, 0x30);
-					sio_write(ints[0], 0x70);
-					sio_write(ints[2], 0x72);
-
-					sio_read(0xaa);	/* exit sio cfg mode */
-				}
-
-				of_node_put(sio);
-			}
-			of_node_put(parent);
-		}
+	if ((rsrc.start & 0xfffff) == 0x8000) {
+		return uli_exclude_device(hose, bus, devfn);
 	}
 
-	/* Configure superio runtime registers for gpio in pci i/o space */
-	if ((np = of_find_compatible_node(NULL, NULL, "smsc,lpc47m192-gpio"))) {
-		struct device_node *sio;
-
-		if ((sio = find_sio_node(np))) {
-			const u32 * regs;
-
-			if ((regs = get_property(np, "reg", NULL))) {
-				/*
-				 * Activate runtime regs (device 0xa) and write
-				 * address from device tree.
-				 */
-				sio_read(0x55);	/* enter config mode */
-
-				sio_write(0x0a, 0x07);
-				sio_write(0x01, 0x30);
-				sio_write((regs[1] & 0xff00) >> 8, 0x60);
-				sio_write((regs[1] & 0xff) | 0x1, 0x61);
-
-				sio_read(0xaa);	/* exit config mode */
-			}
-
-			of_node_put(sio);
-		}
-		of_node_put(np);
-	}
+	return PCIBIOS_SUCCESSFUL;
 }
-
-static void __devinit quirk_uli5288(struct pci_dev *dev)
-{
-	unsigned char c;
-
-	pci_read_config_byte(dev,0x83,&c);
-	c |= 0x80;
-	pci_write_config_byte(dev, 0x83, c);
-
-	pci_write_config_byte(dev, 0x09, 0x01);
-	pci_write_config_byte(dev, 0x0a, 0x06);
-
-	pci_read_config_byte(dev,0x83,&c);
-	c &= 0x7f;
-	pci_write_config_byte(dev, 0x83, c);
-
-	pci_read_config_byte(dev,0x84,&c);
-	c |= 0x01;
-	pci_write_config_byte(dev, 0x84, c);
-}
-
-static void __devinit quirk_uli5229(struct pci_dev *dev)
-{
-	unsigned short temp;
-	pci_write_config_word(dev, 0x04, 0x0405);
-	dev->class &= ~0x5;
-	pci_read_config_word(dev, 0x4a, &temp);
-	temp |= 0x1000;
-	pci_write_config_word(dev, 0x4a, temp);
-}
-
-static void __devinit early_uli5249(struct pci_dev *dev)
-{
-	unsigned char temp;
-	pci_write_config_word(dev, 0x04, 0x0007);
-	pci_read_config_byte(dev, 0x7c, &temp);
-	pci_write_config_byte(dev, 0x7c, 0x80);
-	pci_write_config_byte(dev, 0x09, 0x01);
-	pci_write_config_byte(dev, 0x7c, temp);
-	dev->class |= 0x1;
-}
-
-DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_AL, 0x1575, quirk_uli1575);
-DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_AL, 0x5288, quirk_uli5288);
-DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_AL, 0x5229, quirk_uli5229);
-DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_AL, 0x5249, early_uli5249);
 #endif /* CONFIG_PCI */
 
 
@@ -456,6 +194,9 @@ mpc86xx_hpcn_setup_arch(void)
 		else
 			fsl_add_bridge(np, 0);
 	}
+	uses_fsl_uli_m1575 = 1;
+	ppc_md.pci_exclude_device = mpc86xx_exclude_device;
+
 #endif
 
 	printk("MPC86xx HPCN board from Freescale Semiconductor\n");
Index: linux-2.6.18/arch/powerpc/platforms/Kconfig
===================================================================
--- linux-2.6.18.orig/arch/powerpc/platforms/Kconfig
+++ linux-2.6.18/arch/powerpc/platforms/Kconfig
@@ -384,4 +384,12 @@ config CPM2
 	  you wish to build a kernel for a machine with a CPM2 coprocessor
 	  on it (826x, 827x, 8560).
 
+config FSL_ULI1575
+	bool
+	default n
+	help
+	  Supports for the ULI1575 PCIe south bridge that exists on some
+	  Freescale reference boards. The boards all use the ULI in pretty
+	  much the same way.
+
 endmenu
Index: linux-2.6.18/arch/powerpc/platforms/Makefile
===================================================================
--- linux-2.6.18.orig/arch/powerpc/platforms/Makefile
+++ linux-2.6.18/arch/powerpc/platforms/Makefile
@@ -1,3 +1,6 @@
+
+obj-$(CONFIG_FSL_ULI1575)	+= fsl_uli1575.o
+
 ifeq ($(CONFIG_PPC_MERGE),y)
 obj-$(CONFIG_PPC_PMAC)		+= powermac/
 else
Index: linux-2.6.18/arch/powerpc/platforms/fsl_uli1575.c
===================================================================
--- /dev/null
+++ linux-2.6.18/arch/powerpc/platforms/fsl_uli1575.c
@@ -0,0 +1,255 @@
+/*
+ * ULI M1575 setup code - specific to Freescale boards
+ *
+ * Copyright 2007 Freescale Semiconductor Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/stddef.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/mc146818rtc.h>
+
+#include <asm/system.h>
+#include <asm/pci-bridge.h>
+
+#define ULI_PIRQA	0x08
+#define ULI_PIRQB	0x09
+#define ULI_PIRQC	0x0a
+#define ULI_PIRQD	0x0b
+#define ULI_PIRQE	0x0c
+#define ULI_PIRQF	0x0d
+#define ULI_PIRQG	0x0e
+
+#define ULI_8259_NONE	0x00
+#define ULI_8259_IRQ1	0x08
+#define ULI_8259_IRQ3	0x02
+#define ULI_8259_IRQ4	0x04
+#define ULI_8259_IRQ5	0x05
+#define ULI_8259_IRQ6	0x07
+#define ULI_8259_IRQ7	0x06
+#define ULI_8259_IRQ9	0x01
+#define ULI_8259_IRQ10	0x03
+#define ULI_8259_IRQ11	0x09
+#define ULI_8259_IRQ12	0x0b
+#define ULI_8259_IRQ14	0x0d
+#define ULI_8259_IRQ15	0x0f
+
+u8 uli_pirq_to_irq[8] = {
+	ULI_8259_IRQ9,		/* PIRQA */
+	ULI_8259_IRQ10,		/* PIRQB */
+	ULI_8259_IRQ11,		/* PIRQC */
+	ULI_8259_IRQ12,		/* PIRQD */
+	ULI_8259_IRQ5,		/* PIRQE */
+	ULI_8259_IRQ6,		/* PIRQF */
+	ULI_8259_IRQ7,		/* PIRQG */
+	ULI_8259_NONE,		/* PIRQH */
+};
+
+/* set in board code if you want this quirks to do something */
+int uses_fsl_uli_m1575;
+
+/* Bridge */
+static void __devinit early_uli5249(struct pci_dev *dev)
+{
+	unsigned char temp;
+
+	if (!uses_fsl_uli_m1575)
+		return;
+
+	pci_write_config_word(dev, PCI_COMMAND, PCI_COMMAND_IO |
+		 PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER);
+
+	/* read/write lock */
+	pci_read_config_byte(dev, 0x7c, &temp);
+	pci_write_config_byte(dev, 0x7c, 0x80);
+
+	/* set as P2P bridge */
+	pci_write_config_byte(dev, PCI_CLASS_PROG, 0x01);
+	dev->class |= 0x1;
+
+	/* restore lock */
+	pci_write_config_byte(dev, 0x7c, temp);
+}
+
+
+static void __devinit quirk_uli1575(struct pci_dev *dev)
+{
+	int i;
+
+	if (!uses_fsl_uli_m1575)
+		return;
+
+	/*
+	 * ULI1575 interrupts route setup
+	 */
+
+	/* ULI1575 IRQ mapping conf register maps PIRQx to IRQn */
+	for (i = 0; i < 4; i++) {
+		u8 val = uli_pirq_to_irq[i*2] | (uli_pirq_to_irq[i*2+1] << 4);
+		pci_write_config_byte(dev, 0x48 + i, val);
+	}
+
+	/* USB 1.1 OHCI controller 1: dev 28, func 0 - IRQ12 */
+	pci_write_config_byte(dev, 0x86, ULI_PIRQD);
+
+	/* USB 1.1 OHCI controller 2: dev 28, func 1 - IRQ9 */
+	pci_write_config_byte(dev, 0x87, ULI_PIRQA);
+
+	/* USB 1.1 OHCI controller 3: dev 28, func 2 - IRQ10 */
+	pci_write_config_byte(dev, 0x88, ULI_PIRQB);
+
+	/* Lan controller: dev 27, func 0 - IRQ6 */
+	pci_write_config_byte(dev, 0x89, ULI_PIRQF);
+
+	/* AC97 Audio controller: dev 29, func 0 - IRQ6 */
+	pci_write_config_byte(dev, 0x8a, ULI_PIRQF);
+
+	/* Modem controller: dev 29, func 1 - IRQ6 */
+	pci_write_config_byte(dev, 0x8b, ULI_PIRQF);
+
+	/* HD Audio controller: dev 29, func 2 - IRQ6 */
+	pci_write_config_byte(dev, 0x8c, ULI_PIRQF);
+
+	/* SATA controller: dev 31, func 1 - IRQ5 */
+	pci_write_config_byte(dev, 0x8d, ULI_PIRQE);
+
+	/* SMB interrupt: dev 30, func 1 - IRQ7 */
+	pci_write_config_byte(dev, 0x8e, ULI_PIRQG);
+
+	/* PMU ACPI SCI interrupt: dev 30, func 2 - IRQ7 */
+	pci_write_config_byte(dev, 0x8f, ULI_PIRQG);
+
+	/* USB 2.0 controller: dev 28, func 3 */
+	pci_write_config_byte(dev, 0x74, ULI_8259_IRQ11);
+
+	/* Primary PATA IDE IRQ: 14
+	 * Secondary PATA IDE IRQ: 15
+	 */
+	pci_write_config_byte(dev, 0x44, 0x30 | ULI_8259_IRQ14);
+	pci_write_config_byte(dev, 0x75, ULI_8259_IRQ15);
+}
+
+static void __devinit quirk_final_uli1575(struct pci_dev *dev)
+{
+	/* Set i8259 interrupt trigger
+	 * IRQ 3:  Level
+	 * IRQ 4:  Level
+	 * IRQ 5:  Level
+	 * IRQ 6:  Level
+	 * IRQ 7:  Level
+	 * IRQ 9:  Level
+	 * IRQ 10: Level
+	 * IRQ 11: Level
+	 * IRQ 12: Level
+	 * IRQ 14: Edge
+	 * IRQ 15: Edge
+	 */
+	if (!uses_fsl_uli_m1575)
+		return;
+
+	outb(0xfa, 0x4d0);
+	outb(0x1e, 0x4d1);
+
+	/* setup RTC */
+	CMOS_WRITE(RTC_SET, RTC_CONTROL);
+	CMOS_WRITE(RTC_24H, RTC_CONTROL);
+
+	/* ensure month, date, and week alarm fields are ignored */
+	CMOS_WRITE(0, RTC_VALID);
+
+	outb_p(0x7c, 0x72);
+	outb_p(RTC_ALARM_DONT_CARE, 0x73);
+
+	outb_p(0x7d, 0x72);
+	outb_p(RTC_ALARM_DONT_CARE, 0x73);
+}
+
+/* SATA */
+static void __devinit quirk_uli5288(struct pci_dev *dev)
+{
+	unsigned char c;
+	unsigned int d;
+
+	if (!uses_fsl_uli_m1575)
+		return;
+
+	/* read/write lock */
+	pci_read_config_byte(dev, 0x83, &c);
+	pci_write_config_byte(dev, 0x83, c|0x80);
+
+	pci_read_config_dword(dev, PCI_CLASS_REVISION, &d);
+	d = (d & 0xff) | (PCI_CLASS_STORAGE_SATA_AHCI << 8);
+	pci_write_config_dword(dev, PCI_CLASS_REVISION, d);
+
+	/* restore lock */
+	pci_write_config_byte(dev, 0x83, c);
+
+	/* disable emulated PATA mode enabled */
+	pci_read_config_byte(dev, 0x84, &c);
+	pci_write_config_byte(dev, 0x84, c & ~0x01);
+}
+
+/* PATA */
+static void __devinit quirk_uli5229(struct pci_dev *dev)
+{
+	unsigned short temp;
+
+	if (!uses_fsl_uli_m1575)
+		return;
+
+	pci_write_config_word(dev, PCI_COMMAND, PCI_COMMAND_INTX_DISABLE |
+		PCI_COMMAND_MASTER | PCI_COMMAND_IO);
+
+	/* Enable Native IRQ 14/15 */
+	pci_read_config_word(dev, 0x4a, &temp);
+	pci_write_config_word(dev, 0x4a, temp | 0x1000);
+}
+
+/* We have to do a dummy read on the P2P for the RTC to work, WTF */
+static void __devinit quirk_final_uli5249(struct pci_dev *dev)
+{
+	int i;
+	u8 *dummy;
+	struct pci_bus *bus = dev->bus;
+
+	for (i = 0; i < PCI_BUS_NUM_RESOURCES; i++) {
+		if ((bus->resource[i]) &&
+			(bus->resource[i]->flags & IORESOURCE_MEM)) {
+			dummy = ioremap(bus->resource[i]->start, 0x4);
+			if (dummy) {
+				in_8(dummy);
+				iounmap(dummy);
+			}
+			break;
+		}
+	}
+}
+
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_AL, 0x5249, early_uli5249);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_AL, 0x1575, quirk_uli1575);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_AL, 0x5288, quirk_uli5288);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_AL, 0x5229, quirk_uli5229);
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AL, 0x5249, quirk_final_uli5249);
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AL, 0x1575, quirk_final_uli1575);
+
+int uli_exclude_device(struct pci_controller *hose,
+			u_char bus, u_char devfn)
+{
+	if (bus == (hose->first_busno + 2)) {
+		/* exclude Modem controller */
+		if ((PCI_SLOT(devfn) == 29) && (PCI_FUNC(devfn) == 1))
+			return PCIBIOS_DEVICE_NOT_FOUND;
+
+		/* exclude HD Audio controller */
+		if ((PCI_SLOT(devfn) == 29) && (PCI_FUNC(devfn) == 2))
+			return PCIBIOS_DEVICE_NOT_FOUND;
+	}
+
+	return PCIBIOS_SUCCESSFUL;
+}
Index: linux-2.6.18/mvl_patches/pro50-0548.c
===================================================================
--- /dev/null
+++ linux-2.6.18/mvl_patches/pro50-0548.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(548);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

