#! /usr/bin/env bash
# Patch: -common_arm_freescale_mx27ads_usb_sync
# Date: Tue Mar 11 17:36:22 2008
# Source:  http://opensource.freescale.com/pub/scm/linux-2.6-mx.git    
# MR: 26885
# Type: Integration    
# Disposition:  merged from bsp-imx27ads-rel3 branch of opensource.freescale.com/pub/scm/linux-2.6-mx.git
# Signed-off-by:  Aleksey Makarov <amakarov@ru.mvista.com>    
# Description:    
# 	USB sync with bsp-imx27ads-rel3
# 

PATCHNUM=977
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Source:  http://opensource.freescale.com/pub/scm/linux-2.6-mx.git    
MR: 26885
Type: Integration    
Disposition:  merged from bsp-imx27ads-rel3 branch of opensource.freescale.com/pub/scm/linux-2.6-mx.git
Signed-off-by:  Aleksey Makarov <amakarov@ru.mvista.com>    
Description:    
	USB sync with bsp-imx27ads-rel3

Index: linux-2.6.18/arch/arm/mach-mx2/Kconfig
===================================================================
--- linux-2.6.18.orig/arch/arm/mach-mx2/Kconfig
+++ linux-2.6.18/arch/arm/mach-mx2/Kconfig
@@ -15,93 +15,5 @@ config ARCH_MXC_HAS_NFC_V1
 	  This selects the Freescale MXC Nand Flash Controller Hardware Version 1
 	  If unsure, say N.
 
-config USB_MXC_H1_PORT
-	bool "Enable USB Host1 port (FS only)"
-	depends on USB_EHCI_HCD
-	select USB_EHCI_ROOT_HUB_TT
-	default y
-	help
-	  Enable Host1 port on USB ARC controller.
-
-config USB_MXC_H2_PORT
-	bool "Enable USB Host2 port (HS/FS)"
-	depends on USB_EHCI_HCD
-	select USB_EHCI_ROOT_HUB_TT
-	default y
-	select ISP1504_MXC
-	help
-	  Enable Host2 port on USB ARC controller.
-
-config USB_MXC_OTG_PORT
-	bool "Enable USB OTG port"
-	depends on USB_EHCI_HCD || USB_GADGET_ARC
-	default y
-	help
-	  Enable Host2 port on USB ARC controller.
-
-choice
-	prompt "USB OTG port mode"
-	depends on USB_MXC_OTG_PORT
-	help
-	  Select operation mode of ARC USB OTG port.
-
-	  OTG port of may work as USB host, as USB gadget, or both (USB OTG).
-
-config USB_MXC_OTG_PORT_HOST
-	bool "USB host"
-	depends on USB_EHCI_HCD
-	select USB_EHCI_ROOT_HUB_TT
-	help
-	  Configure ARC USB OTG port to work as USB host.
-
-config USB_MXC_OTG_PORT_GADGET
-	bool "USB gadget"
-	depends on USB_GADGET_ARC
-	help
-	  Configure ARC USB OTG port to work as USB gadget.
-
-config USB_MXC_OTG_PORT_OTG
-	bool "USB OTG"
-	depends on USB_EHCI_HCD && USB_GADGET_ARC
-	select USB_EHCI_ROOT_HUB_TT
-	select ARCH_MXC_OTG
-	select USB_OTG
-	help
-	  Enable OTG support on ARC USB OTG port.
-
-endchoice
-
-choice
-	prompt "Transceiver for USB OTG port"
-	depends on USB_MXC_OTG_PORT
-	help
-	  Select either full speed or high speed transciever to use with
-	  ARC USB OTG port.
-
-config USB_MXC_OTG_PORT_FS
-	bool "Full Speed"
-	depends on !USB_MXC_OTG_PORT_OTG
-	select ISP1301_MXC
-	help
-	  Select this to use ISP1301 Full Speed transceiver.
-
-config USB_MXC_OTG_PORT_HS
-	bool "High Speed"
-	select ISP1504_MXC
-	help
-	  Select this to use ISP1504 High Speed transceiver.
-
-endchoice
-
 endmenu
 
-config ISP1301_MXC
-	bool
-	select I2C_MXC
-
-config ISP1504_MXC
-	bool
-
-config ARCH_MXC_OTG
-	bool
-
Index: linux-2.6.18/arch/arm/mach-mx2/Makefile
===================================================================
--- linux-2.6.18.orig/arch/arm/mach-mx2/Makefile
+++ linux-2.6.18/arch/arm/mach-mx2/Makefile
@@ -6,4 +6,3 @@
 
 obj-y		:= mm.o time.o clock.o cpu.o dma.o gpio_mux.o devices.o usb.o
 obj-$(CONFIG_MACH_MX27ADS)	+= mx27ads.o mx27ads_gpio.o
-obj-$(CONFIG_ISP1301_MXC)	+= isp1301.o
Index: linux-2.6.18/arch/arm/mach-mx2/isp1301.c
===================================================================
--- linux-2.6.18.orig/arch/arm/mach-mx2/isp1301.c
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-
-#include <linux/i2c.h>
-#include <asm/arch/mxc_i2c.h>
-#include <asm/arch/isp1301.h>
-
-static int isp1301_attach(struct i2c_adapter *adap);
-static int isp1301_detach(struct i2c_client *client);
-
-static struct i2c_driver isp1301_i2c_driver = {
-	.driver = {
-		   .owner = THIS_MODULE,
-		   .name = "isp1301 Client",
-		   },
-	.attach_adapter = isp1301_attach,
-	.detach_client = isp1301_detach,
-};
-
-static struct i2c_client isp1301_i2c_client = {
-	.name = "isp1301 I2C dev",
-	.addr = ISP1301_DEV_ADDR,
-	.driver = &isp1301_i2c_driver,
-};
-
-static int isp1301_detect_client(struct i2c_adapter *adapter, int address,
-				 int kind)
-{
-	isp1301_i2c_client.adapter = adapter;
-	if (i2c_attach_client(&isp1301_i2c_client)) {
-		isp1301_i2c_client.adapter = NULL;
-		printk(KERN_ERR "isp1301_attach: i2c_attach_client failed\n");
-		return -1;
-	}
-
-	printk(KERN_INFO "isp1301 Detected\n");
-	return 0;
-}
-
-static unsigned short normal_i2c[] = { ISP1301_DEV_ADDR, I2C_CLIENT_END };
-
-/* Magic definition of all other variables and things */
-I2C_CLIENT_INSMOD;
-
-/*!
- * isp1301 I2C attach function
- *
- * @param adapter            struct i2c_adapter *
- * @return  Error code indicating success or failure
- */
-static int isp1301_attach(struct i2c_adapter *adap)
-{
-	return i2c_probe(adap, &addr_data, &isp1301_detect_client);
-}
-
-/*!
- * isp1301 I2C detach function
- *
- * @param client            struct i2c_client *
- * @return  Error code indicating success or failure
- */
-static int isp1301_detach(struct i2c_client *client)
-{
-	int err;
-
-	if (!isp1301_i2c_client.adapter)
-		return -1;
-
-	err = i2c_detach_client(&isp1301_i2c_client);
-	isp1301_i2c_client.adapter = NULL;
-
-	return err;
-}
-
-static int isp1301_i2c_client_xfer(unsigned int addr, char *reg, int reg_len,
-				   char *buf, int num, int tran_flag)
-{
-	struct i2c_msg msg[2];
-	int ret;
-
-	msg[0].addr = addr;
-	msg[0].len = reg_len;
-	msg[0].buf = reg;
-	msg[0].flags = tran_flag;
-	msg[0].flags &= ~I2C_M_RD;
-
-	msg[1].addr = addr;
-	msg[1].len = num;
-	msg[1].buf = buf;
-	msg[1].flags = tran_flag;
-
-	if (tran_flag & 1) {
-		msg[1].flags |= I2C_M_RD;
-	} else {
-		msg[1].flags &= ~I2C_M_RD;
-	}
-
-	ret = i2c_transfer(isp1301_i2c_client.adapter, msg, 2);
-	if (ret >= 0)
-		return 0;
-
-	return ret;
-}
-
-void isp1301_init(void)
-{
-	i2c_add_driver(&isp1301_i2c_driver);
-}
-
-void isp1301_uninit(void)
-{
-	i2c_del_driver(&isp1301_i2c_driver);
-}
-
-/* Write ISP1301 register*/
-static inline void isp1301_write_reg(char reg, char data)
-{
-	isp1301_i2c_client_xfer(ISP1301_DEV_ADDR, &reg, 1, &data, 1, 0);
-}
-
-/* read ISP1301 register*/
-static inline char isp1301_read_reg(char reg)
-{
-	char data;
-	isp1301_i2c_client_xfer(ISP1301_DEV_ADDR, &reg, 1, &data, 1, 1);
-	return data;
-}
-
-/* set ISP1301 as USB host*/
-void isp1301_set_serial_host(void)
-{
-	isp1301_write_reg(ISP1301_CTRL_REG1_CLR, 0xFF);
-	isp1301_write_reg(ISP1301_CTRL_REG1_SET,
-			  (VBUS_DRV | DP_PULLDOWN | DM_PULLDOWN));
-	isp1301_write_reg(ISP1301_MODE_REG1_SET, DAT_SE0);	/* SE0 state */
-}
-
-/* set ISP1301 as USB device*/
-void isp1301_set_serial_dev(void)
-{
-	isp1301_write_reg(ISP1301_MODE_REG1_CLR, 0xFF);
-	/* FS mode, DP pull down, DM pull down */
-	isp1301_write_reg(ISP1301_CTRL_REG1_SET,
-			  (DP_PULLDOWN | DM_PULLDOWN | DP_PULLUP));
-}
-
-void isp1301_set_vbus_power(int on)
-{
-	if (on) {
-		/* disable D+ pull-up */
-		isp1301_write_reg(ISP1301_CTRL_REG1_CLR, DP_PULLUP);
-		/* enable D+ pull-down */
-		isp1301_write_reg(ISP1301_CTRL_REG1_SET, DP_PULLDOWN);
-		/* turn on Vbus */
-		isp1301_write_reg(ISP1301_CTRL_REG1_SET, VBUS_DRV);
-	} else {
-		/* D+ pull up, D- pull down  */
-		isp1301_write_reg(ISP1301_CTRL_REG1_SET,
-				  (DP_PULLUP | DM_PULLDOWN));
-		/* disable D- pull up, disable D+ pull down */
-		isp1301_write_reg(ISP1301_CTRL_REG1_CLR,
-				  (DM_PULLUP | DP_PULLDOWN));
-	}
-}
Index: linux-2.6.18/arch/arm/mach-mx2/usb.c
===================================================================
--- linux-2.6.18.orig/arch/arm/mach-mx2/usb.c
+++ linux-2.6.18/arch/arm/mach-mx2/usb.c
@@ -1,8 +1,5 @@
 /*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
- *
- *	otg_{get,set}_transceiver() are from arm/plat-omap/usb.c.
- *	which is Copyright (C) 2004 Texas Instruments, Inc.
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -26,6 +23,10 @@
  * @ingroup USB_MX27
  */
 
+/*!
+ *Include files
+ */
+
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/types.h>
@@ -33,269 +34,48 @@
 #include <linux/init.h>
 #include <linux/err.h>
 #include <linux/platform_device.h>
-#include <linux/usb_otg.h>
-#include <linux/delay.h>
-#include <linux/clk.h>
+#include <linux/fsl_devices.h>
+#include <linux/usb/fsl_xcvr.h>
+#include <linux/usb/otg.h>
 
 #include <asm/io.h>
 #include <asm/irq.h>
 #include <asm/system.h>
 #include <asm/hardware.h>
 #include <asm/mach-types.h>
-
-#include <asm/arch/board.h>
 #include <asm/arch/arc_otg.h>
-#include <asm/arch/gpio.h>
-
-#ifdef CONFIG_ISP1504_MXC
-#include <asm/arch/isp1504.h>
-#endif
 
-#ifdef CONFIG_ISP1301_MXC
-#include <asm/arch/isp1301.h>
-#endif
-
-#define PBC3_CLEAR	PBC_BCTRL3_CLEAR_REG
-#define PBC3_SET	PBC_BCTRL3_SET_REG
-
-#define ISP1504_TIMEOUT	100
-
-#undef DEBUG
-#undef VERBOSE
-
-extern void gpio_usbh1_active(void);
+extern struct platform_device *host_pdev_register(struct resource *res,
+						  int n_res,
+						  struct fsl_usb2_platform_data
+						  *config);
+extern int fsl_usb_host_init(struct platform_device *pdev);
+extern void fsl_usb_host_uninit(struct fsl_usb2_platform_data *pdata);
+extern int usbotg_init(struct platform_device *pdev);
+extern void usbotg_uninit(struct fsl_usb2_platform_data *pdata);
+extern int gpio_usbh1_active(void);
 extern void gpio_usbh1_inactive(void);
-extern void gpio_usbh2_active(void);
+extern int gpio_usbh2_active(void);
 extern void gpio_usbh2_inactive(void);
-extern void gpio_usbotg_hs_active(void);
+extern int gpio_usbotg_hs_active(void);
 extern void gpio_usbotg_hs_inactive(void);
-extern void gpio_usbotg_fs_active(void);
+extern int gpio_usbotg_fs_active(void);
 extern void gpio_usbotg_fs_inactive(void);
 
-static struct clk *usb_clk;
-static struct clk *usb_ahb_clk;
-static unsigned long timeout;
-extern int clk_get_usecount(struct clk *clk);
-
-/*
- * make sure USB_CLK is running at 60 MHz +/- 1000 Hz
- */
-static int check_usbclk(void)
-{
-	unsigned long freq;
-
-	usb_ahb_clk = clk_get(NULL, "usb_ahb_clk");
-	clk_enable(usb_ahb_clk);
-	clk_put(usb_ahb_clk);
-
-	usb_clk = clk_get(NULL, "usb_clk");
-	freq = clk_get_rate(usb_clk);
-	clk_put(usb_clk);
-	if ((freq < 59999000) || (freq > 60001000)) {
-		printk(KERN_ERR "USB_CLK=%lu, should be 60MHz\n", freq);
-		return -1;
-	}
-	return 0;
-}
-
-#ifdef CONFIG_ISP1504_MXC
+#ifdef CONFIG_USB_EHCI_ARC_H1
 /*!
- * read ULPI register 'reg' thru VIEWPORT register 'view'
- *
- * @param       reg   register to read
- * @param       view  the ULPI VIEWPORT register address
- * @return	return isp1504 register value
+ * HOST1 config
  */
-u8 isp1504_read(int reg, volatile u32 * view)
-{
-	u32 data;
-
-	/* make sure interface is running */
-	if (!(__raw_readl(view) && ULPIVW_SS)) {
-		__raw_writel(ULPIVW_WU, view);
-		timeout = jiffies + ISP1504_TIMEOUT;
-		do {		/* wait for wakeup */
-			if (time_after(jiffies, timeout)) {
-				printk(KERN_ERR "%s: TIMEOUT\n", __FUNCTION__);
-				return -ETIMEDOUT;
-			}
-			data = __raw_readl(view);
-		} while (data & ULPIVW_WU);
-	}
-
-	/* read the register */
-	__raw_writel((ULPIVW_RUN | (reg << ULPIVW_ADDR_SHIFT)), view);
-
-	timeout = jiffies + ISP1504_TIMEOUT;
-	do {			/* wait for completion */
-		if (time_after(jiffies, timeout)) {
-			printk(KERN_ERR "%s: TIMEOUT\n", __FUNCTION__);
-			return -ETIMEDOUT;
-		}
-		data = __raw_readl(view);
-	} while (data & ULPIVW_RUN);
-
-	return (u8) (data >> ULPIVW_RDATA_SHIFT) & ULPIVW_RDATA_MASK;
-}
-EXPORT_SYMBOL(isp1504_read);
-
-/*!
- * set bits into OTG ISP1504 register 'reg' thru VIEWPORT register 'view'
- *
- * @param       bits  set value
- * @param	reg   which register
- * @param       view  the ULPI VIEWPORT register address
- */
-void isp1504_set(u8 bits, int reg, volatile u32 * view)
-{
-	u32 data;
-
-	/* make sure interface is running */
-	if (!(__raw_readl(view) && ULPIVW_SS)) {
-		printk(KERN_INFO "\nSS=0\n");
-		__raw_writel(ULPIVW_WU, view);
-		timeout = jiffies + ISP1504_TIMEOUT;
-		do {		/* wait for wakeup */
-			if (time_after(jiffies, timeout)) {
-				printk(KERN_ERR "%s: TIMEOUT\n", __FUNCTION__);
-				return;
-			}
-			data = __raw_readl(view);
-		} while (data & ULPIVW_WU);
-	}
-
-	__raw_writel((ULPIVW_RUN | ULPIVW_WRITE |
-		      ((reg + ISP1504_REG_SET) << ULPIVW_ADDR_SHIFT) |
-		      ((bits & ULPIVW_WDATA_MASK) << ULPIVW_WDATA_SHIFT)),
-		     view);
-
-	timeout = jiffies + ISP1504_TIMEOUT;
-	while (__raw_readl(view) & ULPIVW_RUN) {  /* wait for completion */
-		if (time_after(jiffies, timeout)) {
-			printk(KERN_ERR "%s: TIMEOUT\n", __FUNCTION__);
-			return;
-		}
-	}
-}
-EXPORT_SYMBOL(isp1504_set);
-
-/*!
- * clear bits in OTG ISP1504 register 'reg' thru VIEWPORT register 'view'
- *
- * @param       bits  bits to clear
- * @param	reg   in this register
- * @param       view  the ULPI VIEWPORT register address
- */
-void isp1504_clear(u8 bits, int reg, volatile u32 * view)
-{
-	__raw_writel((ULPIVW_RUN | ULPIVW_WRITE |
-		      ((reg + ISP1504_REG_CLEAR) << ULPIVW_ADDR_SHIFT) |
-		      ((bits & ULPIVW_WDATA_MASK) << ULPIVW_WDATA_SHIFT)),
-		     view);
-
-	timeout = jiffies + ISP1504_TIMEOUT;
-	while (__raw_readl(view) & ULPIVW_RUN) {  /* wait for completion */
-		if (time_after(jiffies, timeout)) {
-			printk(KERN_ERR "%s: TIMEOUT\n", __FUNCTION__);
-			return;
-		}
-	}
-}
-EXPORT_SYMBOL(isp1504_clear);
-
-/*!
- * set vbus power
- *
- * @param       on    power on or off
- * @param       view  the ULPI view register address
- */
-static void __attribute((unused)) ulpi_set_vbus_power(int on,
-						      volatile u32 * view)
-{
-	pr_debug("%s: on=%d  view=0x%p\n", __FUNCTION__, on, view);
-
-	pr_debug("%s: ULPI Vendor ID 0x%x    Product ID 0x%x\n", __FUNCTION__,
-		 (isp1504_read(ISP1504_VID_HIGH, view) << 8) |
-		 isp1504_read(ISP1504_VID_LOW, view),
-		 (isp1504_read(ISP1504_PID_HIGH, view) << 8) |
-		 isp1504_read(ISP1504_PID_LOW, view));
-
-	pr_debug("%s: OTG Control before = 0x%x\n", __FUNCTION__,
-		 isp1504_read(ISP1504_OTGCTL, view));
-
-	if (on) {
-		isp1504_set(DRV_VBUS_EXT |	/* enable external Vbus */
-			    DRV_VBUS |	/* enable internal Vbus */
-			    USE_EXT_VBUS_IND |	/* use external indicator */
-			    CHRG_VBUS,	/* charge Vbus */
-			    ISP1504_OTGCTL, view);
-
-	} else {
-		isp1504_clear(DRV_VBUS_EXT |	/* disable external Vbus */
-			      DRV_VBUS,	/* disable internal Vbus */
-			      ISP1504_OTGCTL, view);
-
-		isp1504_set(USE_EXT_VBUS_IND |	/* use external indicator */
-			    DISCHRG_VBUS,	/* discharge Vbus */
-			    ISP1504_OTGCTL, view);
-	}
-
-	pr_debug("%s: OTG Control after = 0x%x\n\n", __FUNCTION__,
-		 isp1504_read(ISP1504_OTGCTL, view));
-}
-#endif
-
-#ifdef CONFIG_USB_MXC_H1_PORT
-static void usbh1_set_xcvr(void)
-{
-	UH1_PORTSC1 &= ~PORTSC_PTS_MASK;
-	UH1_PORTSC1 |= PORTSC_PTS_SERIAL;
-}
-
-static int usbh1_init(void)
-{
-	pr_debug("%s: grab H1 pins\n", __FUNCTION__);
-
-	clk_enable(usb_clk);
-	pr_debug("%s: usb_clk usecount %d\n\n", __FUNCTION__,
-		 clk_get_usecount(usb_clk));
-
-	gpio_usbh1_active();
-	mdelay(1);
-
-	__raw_writew(PBC_BCTRL3_FSH_MOD, PBC3_CLEAR);	/* single ended */
-	__raw_writew(PBC_BCTRL3_FSH_VBUS_EN, PBC3_CLEAR);	/* enable FSH VBUS */
-
-	USBCTRL &= ~(UCTRL_H1SIC_MASK | UCTRL_BPE);	/* disable bypass mode */
-	USBCTRL |= UCTRL_H1SIC_SU6 |	/* single-ended / unidir. */
-	    UCTRL_H1WIE | UCTRL_H1DT |	/* disable H1 TLL */
-	    UCTRL_H1PM;		/* power mask */
-
-	usbh1_set_xcvr();
-	return 0;
-}
-
-static void usbh1_uninit(void)
-{
-	pr_debug("%s: \n", __FUNCTION__);
-
-	__raw_writew(PBC_BCTRL3_FSH_VBUS_EN, PBC3_SET);	/* disable FSH VBUS */
-
-	gpio_usbh1_inactive();	/* release our pins */
-	clk_disable(usb_clk);
-	pr_debug("%s: usb_clk usecount %d\n\n", __FUNCTION__,
-		 clk_get_usecount(usb_clk));
-}
-
-static u64 usbh1_dmamask = ~((u32)0);
-
-static struct arc_usb_config usbh1_config = {
-	.name            = "Host 1",
-	.platform_init   = usbh1_init,
-	.platform_uninit = usbh1_uninit,
-	.xcvr_type       = PORTSC_PTS_SERIAL,
-	.usbmode         = (u32) &UH1_USBMODE,
-	.power_budget    = 500,		/* 500 mA max power */
+/* *INDENT-OFF* */
+static struct fsl_usb2_platform_data usbh1_config = {
+	.name              = "Host 1",
+	.platform_init     = fsl_usb_host_init,
+	.platform_uninit   = fsl_usb_host_uninit,
+	.usbmode           = (u32) &UH1_USBMODE,
+	.power_budget      = 500,		/* 500 mA max power */
+	.gpio_usb_active   = gpio_usbh1_active,
+	.gpio_usb_inactive = gpio_usbh1_inactive,
+	.transceiver       = "serial",
 };
 
 static struct resource usbh1_resources[] = {
@@ -309,78 +89,24 @@ static struct resource usbh1_resources[]
 		.flags = IORESOURCE_IRQ,
 	},
 };
-#endif	/* CONFIG_USB_MXC_H1_PORT */
-
-#ifdef CONFIG_USB_MXC_H2_PORT
-static void usbh2_set_xcvr(void)
-{
-	UH2_PORTSC1 &= ~PORTSC_PTS_MASK;	/* set ULPI xcvr */
-	UH2_PORTSC1 |= PORTSC_PTS_ULPI;
-
-	/* need to reset the controller here so that the ID pin
-	 * is correctly detected.
-	 */
-	UH2_USBCMD |= UCMD_RESET;
-
-	/* allow controller to reset, and leave time for
-	 * the ULPI transceiver to reset too.
-	 */
-	mdelay(10);
-
-	/* Turn off the usbpll for ulpi tranceivers */
-	clk_disable(usb_clk);
-	pr_debug("%s: usb_clk usecount %d\n\n", __FUNCTION__,
-		 clk_get_usecount(usb_clk));
-}
-
-static int usbh2_init(void)
-{
-	pr_debug("%s: grab H2 pins\n", __FUNCTION__);
-
-	__raw_writew(PBC_BCTRL3_HSH_EN, PBC3_CLEAR);	/* enable OTG_VBUS_EN */
-	clk_enable(usb_clk);
-	pr_debug("%s: usb_clk usecount %d\n\n", __FUNCTION__,
-		 clk_get_usecount(usb_clk));
-
-	gpio_usbh2_active();	/* grab our pins */
-	mdelay(1);
-
-	USBCTRL &= ~(UCTRL_BPE);	/* disable bypass mode */
-	USBCTRL |= UCTRL_H2WIE |	/* wakeup intr enable */
-	    UCTRL_H2UIE |	/* ULPI intr enable */
-	    UCTRL_H2DT |	/* disable H2 TLL */
-	    UCTRL_H2PM;		/* power mask */
-
-	pr_debug("%s: success\n", __FUNCTION__);
-	usbh2_set_xcvr();	/* set transceiver type */
-	return 0;
-}
-
-static void usbh2_uninit(void)
-{
-	pr_debug("%s: \n", __FUNCTION__);
-
-	__raw_writew(PBC_BCTRL3_HSH_EN, PBC3_SET);	/* disable HSH */
-
-	gpio_usbh2_inactive();	/* release our pins */
-}
-
-static void usbh2_set_vbus_power(int on)
-{
-	pr_debug("%s: on=%d\n", __FUNCTION__, on);
-	ulpi_set_vbus_power(on, &UH2_ULPIVIEW);
-}
-
-static u64 usbh2_dmamask = ~((u32)0);
+/* *INDENT-ON* */
+#endif
 
-static struct arc_usb_config usbh2_config = {
-	.name            = "Host 2",
-	.platform_init   = usbh2_init,
-	.platform_uninit = usbh2_uninit,
-	.set_vbus_power  = usbh2_set_vbus_power,
-	.xcvr_type       = PORTSC_PTS_ULPI,
-	.usbmode         = (u32) &UH2_USBMODE,
-	.power_budget    = 500,		/* 500 mA max power */
+#ifdef CONFIG_USB_EHCI_ARC_H2
+/*!
+ * HOST2 config
+ */
+/* *INDENT-OFF* */
+static struct fsl_usb2_platform_data usbh2_config = {
+	.name              = "Host 2",
+	.platform_init     = fsl_usb_host_init,
+	.platform_uninit   = fsl_usb_host_uninit,
+	.usbmode           = (u32) &UH2_USBMODE,
+	.viewport          = (u32) &UH2_ULPIVIEW,
+	.power_budget      = 500,  /* 500 mA max power */
+	.gpio_usb_active   = gpio_usbh2_active,
+	.gpio_usb_inactive = gpio_usbh2_inactive,
+	.transceiver       = "isp1504",
 };
 
 static struct resource usbh2_resources[] = {
@@ -394,389 +120,226 @@ static struct resource usbh2_resources[]
 		.flags = IORESOURCE_IRQ,
 	},
 };
-#endif	/* CONFIG_USB_MXC_H2_PORT */
-
-#ifdef CONFIG_USB_MXC_OTG_PORT
-#ifdef CONFIG_USB_MXC_OTG_PORT_HS
-static int otg_used = 0;	/* OTG use-count */
-
-static void otg_hs_set_xcvr(void)
-{
-	u32 tmp;
-
-	/* set ULPI xcvr */
-	tmp = UOG_PORTSC1 & ~PORTSC_PTS_MASK;
-	tmp |= PORTSC_PTS_ULPI;
-	UOG_PORTSC1 = tmp;
-
-	/* need to reset the controller here so that the ID pin
-	 * is correctly detected.
-	 */
-	UOG_USBCMD |= UCMD_RESET;
-
-	/* allow controller to reset, and leave time for
-	 * the ULPI transceiver to reset too.
-	 */
-	mdelay(10);
-
-	/* Turn off the usbpll for ulpi tranceivers */
-	clk_disable(usb_clk);
-	pr_debug("%s: usb_pll usecount %d\n\n", __FUNCTION__,
-		 clk_get_usecount(usb_clk));
-}
-
-static int otg_hs_init(void)
-{
-	if (!otg_used) {
-		pr_debug("%s: grab OTG-HS pins\n", __FUNCTION__);
-
-		/* enable OTG/HS */
-		clk_enable(usb_clk);
-		pr_debug("%s: usb_clk usecount %d\n\n", __FUNCTION__,
-			 clk_get_usecount(usb_clk));
-		__raw_writew(PBC_BCTRL3_OTG_HS_EN, PBC3_CLEAR);
-
-		gpio_usbotg_hs_active();	/* grab our pins */
-		mdelay(1);
-
-		USBCTRL &= ~UCTRL_BPE;	/* disable bypass mode */
-		USBCTRL |= UCTRL_OUIE |	/* ULPI intr enable */
-		    UCTRL_OWIE |	/* OTG wakeup intr enable */
-		    UCTRL_OPM;	/* power mask */
-
-		otg_hs_set_xcvr();	/* set transciever type */
-	}
-
-	isp1504_set(ID_PULL_UP, ISP1504_OTGCTL, &UOG_ULPIVIEW);
-#ifdef DEBUG
-	if (!(isp1504_read(ISP1504_OTGCTL, &UOG_ULPIVIEW) & ID_PULL_UP)) {
-		printk(KERN_ERR "ID_PULL_UP not set in OTGCTL!!\n");
-	}
+/* *INDENT-ON* */
 #endif
 
-	otg_used++;
-	return 0;
-}
-
-static void otg_hs_uninit(void)
-{
-	pr_debug("%s: \n", __FUNCTION__);
-
-	otg_used--;
-	if (!otg_used) {
-		/* disable  OTG/HS */
-		__raw_writew(PBC_BCTRL3_OTG_HS_EN, PBC3_SET);
-
-		pr_debug("%s: free OTG-HS pins\n", __FUNCTION__);
-		gpio_usbotg_hs_inactive();	/* release our pins */
-	}
-}
-
-static void otg_hs_set_vbus_power(int on)
-{
-	pr_debug("%s: on=%d\n", __FUNCTION__, on);
-	ulpi_set_vbus_power(on, &UOG_ULPIVIEW);
-}
-
-#if defined(CONFIG_USB_MXC_OTG_PORT_HOST) || \
-    defined(CONFIG_USB_MXC_OTG_PORT_OTG)
-static u64 usbotg_host_dmamask = ~((u32)0);
-
-static struct arc_usb_config usbotg_host_config = {
-	.name            = "OTG HS Host",
-	.platform_init   = otg_hs_init,
-	.platform_uninit = otg_hs_uninit,
-	.set_vbus_power  = otg_hs_set_vbus_power,
-	.xcvr_type       = PORTSC_PTS_ULPI,
-	.usbmode         = (u32) &UOG_USBMODE,
-	.does_otg        = 1,
-	.power_budget    = 500,		/* 500 mA max power */
+/*!
+ * OTG config
+ */
+/* *INDENT-OFF* */
+#if defined(CONFIG_USB_EHCI_ARC_OTG) || defined(CONFIG_USB_GADGET_ARC) || defined(CONFIG_OTG_BTC_ARC)
+#if defined(CONFIG_MC13783_MXC)
+static struct fsl_usb2_platform_data mxc_serial_host_config = {
+	.name              = "OTG",
+	.platform_init     = usbotg_init,
+	.platform_uninit   = usbotg_uninit,
+	.usbmode           = (u32) &UOG_USBMODE,
+	.viewport          = (u32) &UOG_ULPIVIEW,
+	.does_otg          = 1,
+	.operating_mode    = FSL_USB2_DR_HOST,
+	.power_budget      = 500,  /* 500 mA max power */
+	.gpio_usb_active   = gpio_usbotg_fs_active,
+	.gpio_usb_inactive = gpio_usbotg_fs_inactive,
+	.transceiver       = "mc13783",
+};
+#elif defined(CONFIG_ISP1301_MXC)
+static struct fsl_usb2_platform_data mxc_serial_host_config = {
+	.name              = "OTG",
+	.platform_init     = usbotg_init,
+	.platform_uninit   = usbotg_uninit,
+	.usbmode           = (u32) &UOG_USBMODE,
+	.viewport          = (u32) &UOG_ULPIVIEW,
+	.does_otg          = 0,
+	.operating_mode    = FSL_USB2_DR_HOST,
+	.power_budget      = 500,  /* 500 mA max power */
+	.gpio_usb_active   = gpio_usbotg_fs_active,
+	.gpio_usb_inactive = gpio_usbotg_fs_inactive,
+	.transceiver       = "isp1301",
+};
+#elif defined(CONFIG_ISP1504_MXC)
+static struct fsl_usb2_platform_data mxc_isp1504_config = {
+	.name              = "OTG",
+	.platform_init     = usbotg_init,
+	.platform_uninit   = usbotg_uninit,
+	.usbmode           = (u32) &UOG_USBMODE,
+	.viewport          = (u32) &UOG_ULPIVIEW,
+	.does_otg          = 1,
+	.power_budget      = 500,  /* 500 mA max power */
+	.gpio_usb_active   = gpio_usbotg_hs_active,
+	.gpio_usb_inactive = gpio_usbotg_hs_inactive,
+	.transceiver       = "isp1504",
 };
-#endif	/* CONFIG_USB_MXC_OTG_PORT_HOST || CONFIG_USB_MXC_OTG_PORT_OTG */
+#endif
 
-#if defined(CONFIG_USB_MXC_OTG_PORT_GADGET) || \
-    defined(CONFIG_USB_MXC_OTG_PORT_OTG)
-static u64 udc_dmamask = ~((u32)0);
-
-static struct arc_usb_config udc_config = {
-	.name            = "OTG HS Gadget",
-	.platform_init   = otg_hs_init,
-	.platform_uninit = otg_hs_uninit,
-	.set_vbus_power  = otg_hs_set_vbus_power,
-	.xcvr_type       = PORTSC_PTS_ULPI,
-	.usbmode         = (u32) &UOG_USBMODE,
+static struct resource otg_resources[] = {
+	{
+		.start = (u32) (USB_OTGREGS_BASE),
+		.end   = (u32) (USB_OTGREGS_BASE + 0x1ff),
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_USB3,
+		.flags = IORESOURCE_IRQ,
+	},
 };
-#endif	/* CONFIG_USB_MXC_OTG_PORT_GADGET || CONFIG_USB_MXC_OTG_PORT_OTG */
-#endif	/* CONFIG_USB_MXC_OTG_PORT_HS */
-
-#ifdef CONFIG_USB_MXC_OTG_PORT_FS
-static void otg_fs_set_xcvr(void)
-{
-	u32 tmp;
-
-	tmp = UOG_PORTSC1 & ~PORTSC_PTS_MASK;
-	tmp |= PORTSC_PTS_SERIAL;
-	UOG_PORTSC1 = tmp;
-}
+#endif
+/* *INDENT-ON* */
 
-#if defined(CONFIG_USB_MXC_OTG_PORT_HOST) || \
-    defined(CONFIG_USB_MXC_OTG_PORT_OTG)
-static int otg_fs_host_init(void)
+#if defined(CONFIG_USB_GADGET_ARC) || defined(CONFIG_OTG_BTC_ARC)
+/*!
+ * OTG Gadget device
+ */
+static void udc_release(struct device *dev)
 {
-	pr_debug("%s: grab OTG-FS pins\n", __FUNCTION__);
-	clk_enable(usb_clk);
-	pr_debug("%s: usb_clk usecount %d\n\n", __FUNCTION__,
-		 clk_get_usecount(usb_clk));
-
-	isp1301_init();
-
-	isp1301_set_serial_host();
-	gpio_usbotg_fs_active();	/* grab our pins */
-	mdelay(1);
-
-	/* enable OTG VBUS */
-	__raw_writew(PBC_BCTRL3_OTG_VBUS_EN, PBC3_CLEAR);
-
-	otg_fs_set_xcvr();	/* set transceiver type */
-
-	USBCTRL &= ~(UCTRL_OSIC_MASK | UCTRL_BPE);	/* disable bypass mode */
-	USBCTRL |= UCTRL_OSIC_SU6 |	/* single-ended, unidir, 6 wire */
-	    UCTRL_OWIE |	/* OTG wakeup intr enable */
-	    UCTRL_OPM;		/* power mask */
-
-	/* need reset */
-	UOG_USBCMD |= UCMD_RESET;
-	mdelay(10);
-
-	return 0;
+	/* normally not freed */
 }
 
-static void otg_fs_host_uninit(void)
-{
-	pr_debug("%s: \n", __FUNCTION__);
-
-	__raw_writew(PBC_BCTRL3_OTG_VBUS_EN, PBC3_SET);	/* disable OTG VBUS */
+static u64 udc_dmamask = ~(u32) 0;
 
-	isp1301_uninit();
-
-	gpio_usbotg_fs_inactive();	/* release our pins */
-	clk_disable(usb_clk);
-	pr_debug("%s: usb_clk usecount %d\n\n", __FUNCTION__,
-		 clk_get_usecount(usb_clk));
-}
-
-static u64 usbotg_host_dmamask = ~((u32)0);
-
-static struct arc_usb_config usbotg_host_config = {
-	.name            = "OTG FS Host",
-	.platform_init   = otg_fs_host_init,
-	.platform_uninit = otg_fs_host_uninit,
-	.set_vbus_power  = isp1301_set_vbus_power,
-	.xcvr_type       = PORTSC_PTS_SERIAL,
-	.usbmode         = (u32) &UOG_USBMODE,
-	.does_otg        = 1,
-	.power_budget    = 500,		/* 500 mA max power */
+#if defined(CONFIG_MC13783_MXC)
+static struct fsl_usb2_platform_data mxc_serial_peripheral_config = {
+	.name = "OTG",
+	.platform_init = usbotg_init,
+	.platform_uninit = usbotg_uninit,
+	.usbmode = (u32) & UOG_USBMODE,
+	.does_otg = 1,
+	.operating_mode = FSL_USB2_DR_DEVICE,
+	.power_budget = 150,	/* 150 mA max power */
+	.gpio_usb_active = gpio_usbotg_fs_active,
+	.gpio_usb_inactive = gpio_usbotg_fs_inactive,
+	.transceiver = "mc13783",
+};
+#elif defined(CONFIG_ISP1301_MXC)
+static struct fsl_usb2_platform_data mxc_serial_peripheral_config = {
+	.name = "OTG",
+	.platform_init = usbotg_init,
+	.platform_uninit = usbotg_uninit,
+	.usbmode = (u32) & UOG_USBMODE,
+	.does_otg = 0,
+	.operating_mode = FSL_USB2_DR_DEVICE,
+	.power_budget = 150,	/* 150 mA max power */
+	.gpio_usb_active = gpio_usbotg_fs_active,
+	.gpio_usb_inactive = gpio_usbotg_fs_inactive,
+	.transceiver = "isp1301",
 };
-#endif	/* CONFIG_USB_MXC_OTG_PORT_HOST || CONFIG_USB_MXC_OTG_PORT_OTG */
-
-#if defined(CONFIG_USB_MXC_OTG_PORT_GADGET) || \
-    defined(CONFIG_USB_MXC_OTG_PORT_OTG)
-int otg_fs_dev_init(void)
-{
-	pr_debug("%s: grab OTG-FS pins\n", __FUNCTION__);
-
-	clk_enable(usb_clk);
-	pr_debug("%s: usb_clk usecount %d\n\n", __FUNCTION__,
-		 clk_get_usecount(usb_clk));
-
-	isp1301_init();
-
-	isp1301_set_serial_dev();
-	gpio_usbotg_fs_active();	/* grab our pins */
-	mdelay(1);
-
-	/* disable OTG VBUS */
-	__raw_writew(PBC_BCTRL3_OTG_VBUS_EN, PBC3_SET);
-
-	otg_fs_set_xcvr();	/* set transceiver type */
-
-	USBCTRL &= ~(UCTRL_OSIC_MASK | UCTRL_BPE);	/* disable bypass */
-	USBCTRL |= UCTRL_OSIC_DU6 |	/* differential, unidir, 6 wire */
-	    UCTRL_OWIE |	/* OTG wakeup intr enable */
-	    UCTRL_OPM;		/* power mask */
-
-	USB_OTG_MIRROR = 0xd;
-	return 0;
-}
-
-static void otg_fs_dev_uninit(void)
-{
-	pr_debug("%s: \n", __FUNCTION__);
-
-	/* disable OTG VBUS */
-	__raw_writew(PBC_BCTRL3_OTG_VBUS_EN, PBC3_SET);
-
-	isp1301_uninit();
-	gpio_usbotg_fs_inactive();	/* release our pins */
-	clk_disable(usb_clk);
-	pr_debug("%s: usb_clk usecount %d\n\n", __FUNCTION__,
-		 clk_get_usecount(usb_clk));
-}
-
-static u64 udc_dmamask = ~((u32)0);
+#endif
 
-static struct arc_usb_config udc_config = {
-	.name            = "OTG FS Gadget",
-	.platform_init   = otg_fs_dev_init,
-	.platform_uninit = otg_fs_dev_uninit,
-	.set_vbus_power  = isp1301_set_vbus_power,
-	.xcvr_type       = PORTSC_PTS_SERIAL,
-	.usbmode         = (u32) &UOG_USBMODE,
+/* *INDENT-OFF* */
+static struct platform_device otg_udc_device = {
+	.name = "arc_udc",
+	.id   = -1,
+	.dev  = {
+		.release           = udc_release,
+		.dma_mask          = &udc_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+#if defined(CONFIG_MC13783_MXC) || defined(CONFIG_ISP1301_MXC)
+		.platform_data     = &mxc_serial_peripheral_config,
+#elif defined(CONFIG_ISP1504_MXC)
+		.platform_data     = &mxc_isp1504_config,
+#endif
+		},
+	.resource = otg_resources,
+	.num_resources = ARRAY_SIZE(otg_resources),
 };
-#endif	/* CONFIG_USB_MXC_OTG_PORT_GADGET || CONFIG_USB_MXC_OTG_PORT_OTG */
-#endif	/* CONFIG_USB_MXC_OTG_PORT_FS */
-
-#ifdef CONFIG_USB_MXC_OTG_PORT_OTG
-static struct otg_transceiver *xceiv;
-
-struct otg_transceiver *otg_get_transceiver(void)
-{
-	pr_debug("%s xceiv=0x%p\n\n", __FUNCTION__, xceiv);
-	if (xceiv)
-		get_device(xceiv->dev);
-	return xceiv;
-}
-EXPORT_SYMBOL(otg_get_transceiver);
+/* *INDENT-ON* */
+#endif
 
-int otg_set_transceiver(struct otg_transceiver *x)
+#if defined(CONFIG_USB_OTG)
+static void pindetect_release(struct device *dev)
 {
-	pr_debug("%s xceiv=0x%p  x=0x%p\n\n", __FUNCTION__, xceiv, x);
-	if (xceiv && x)
-		return -EBUSY;
-	xceiv = x;
-	return 0;
 }
-EXPORT_SYMBOL(otg_set_transceiver);
 
-static struct arc_xcvr_config isp1504_config = {
-	.name            = "isp1504",
-	.platform_init   = otg_hs_init,
-	.platform_uninit = otg_hs_uninit,
-	.regs            = (void *)&UOG_ID,
-};
-
-static struct resource isp1504_resources[] = {
-	{
-		.start = MXC_INT_USB3,
-		.flags = IORESOURCE_IRQ,
-	},
-};
-
-static u64 isp1504_dmamask = ~((u32)0);
-#endif	/* CONFIG_USB_MXC_OTG_PORT_OTG */
-
-static struct resource otg_resources[] = {
+/* *INDENT-OFF* */
+static struct resource pindetect_resources[] = {
 	{
 		.start = (u32) (USB_OTGREGS_BASE),
 		.end   = (u32) (USB_OTGREGS_BASE + 0x1ff),
 		.flags = IORESOURCE_MEM,
 	},
 	{
-		.start = MXC_INT_USB3,
+		.start = INT_USB3,
 		.flags = IORESOURCE_IRQ,
 	},
 };
-#endif	/* CONFIG_USB_MXC_OTG_PORT */
 
-static struct platform_device mxcusb_devices[] = {
-#ifdef CONFIG_USB_MXC_H1_PORT
-	{
-	 .name = "arc-ehci",
-	 .id = 0,
-	 .dev = {
-		.dma_mask = &usbh1_dmamask,
-		.coherent_dma_mask = ~((u32)0),
-		.platform_data = &usbh1_config,
-	 },
-	 .num_resources = ARRAY_SIZE(usbh1_resources),
-	 .resource = usbh1_resources,
-	},
-#endif
-#ifdef CONFIG_USB_MXC_H2_PORT
-	{
-	 .name = "arc-ehci",
-	 .id = 1,
-	 .dev = {
-		.dma_mask = &usbh2_dmamask,
-		.coherent_dma_mask = ~((u32)0),
-		.platform_data = &usbh2_config,
-	 },
-	 .num_resources = ARRAY_SIZE(usbh2_resources),
-	 .resource = usbh2_resources,
-	},
-#endif
-#if defined(CONFIG_USB_MXC_OTG_PORT_HOST) || \
-    defined(CONFIG_USB_MXC_OTG_PORT_OTG)
-	{
-	 .name = "arc-ehci",
-	 .id = 2,
-	 .dev = {
-		.dma_mask = &usbotg_host_dmamask,
-		.coherent_dma_mask = ~((u32)0),
-		.platform_data = &usbotg_host_config,
-	 },
-	 .num_resources = ARRAY_SIZE(otg_resources),
-	 .resource = otg_resources,
-	},
-#endif
-#if defined(CONFIG_USB_MXC_OTG_PORT_GADGET) || \
-    defined(CONFIG_USB_MXC_OTG_PORT_OTG)
-	{
-	 .name = "arc_udc",
-	 .id   = -1,
-	 .dev  = {
-		.dma_mask          = &udc_dmamask,
-		.coherent_dma_mask = ~((u32)0),
-		.platform_data     = &udc_config,
-		},
-	 .num_resources = ARRAY_SIZE(otg_resources),
-	 .resource      = otg_resources,
-	},
+static u64 pindetect_dmamask = ~(u32) 0;
+
+static struct fsl_usb2_platform_data fsl_otg_config = {
+	.name            = "fsl_arc",
+	.platform_init   = usbotg_init,
+	.platform_uninit = usbotg_uninit,
+	.usbmode         = (u32) &UOG_USBMODE,
+	.power_budget    = 500,		/* 500 mA max power */
+#if defined(CONFIG_MC13783_MXC)
+	.operating_mode    = FSL_USB2_DR_DEVICE,
+	.gpio_usb_active   = gpio_usbotg_fs_active,
+	.gpio_usb_inactive = gpio_usbotg_fs_inactive,
+	.transceiver       = "mc13783",
+#elif defined(CONFIG_ISP1504_MXC)
+	.gpio_usb_active   = gpio_usbotg_hs_active,
+	.gpio_usb_inactive = gpio_usbotg_hs_inactive,
+	.transceiver       = "isp1504",
 #endif
-#ifdef CONFIG_USB_MXC_OTG_PORT_OTG
-	{
-	 .name = "isp1504_arc",
-	 .id   = -1,
-	 .dev  = {
-		.dma_mask          = &isp1504_dmamask,
-		.coherent_dma_mask = ~((u32)0),
-		.platform_data     = &isp1504_config,
+};
+
+static struct platform_device fsl_device = {
+	.name = "fsl_arc",
+	.id   = -1,
+	.dev  = {
+		.release           = pindetect_release,
+		.dma_mask          = &pindetect_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+		.platform_data     = &fsl_otg_config,
 		},
-	 .num_resources = ARRAY_SIZE(isp1504_resources),
-	 .resource      = isp1504_resources,
-	},
-#endif
+	.resource      = pindetect_resources,
+	.num_resources = ARRAY_SIZE(pindetect_resources),
 };
+#endif				/* CONFIG_USB_OTG */
 
 static int __init mx27_usb_init(void)
 {
-	int i, res;
+	struct fsl_usb2_platform_data __attribute__((unused)) *pdata;
+
+	pr_debug("%s: \n", __FUNCTION__);
+
+#ifdef CONFIG_USB_EHCI_ARC_H1
+	host_pdev_register(usbh1_resources, ARRAY_SIZE(usbh1_resources),
+			   &usbh1_config);
+#endif
+
+#ifdef CONFIG_USB_EHCI_ARC_H2
+	host_pdev_register(usbh2_resources, ARRAY_SIZE(usbh2_resources),
+			   &usbh2_config);
+#endif
 
-	if (check_usbclk() != 0)
-		return -EINVAL;
+#ifdef CONFIG_USB_EHCI_ARC_OTG
+#if defined(CONFIG_MC13783_MXC)	|| defined(CONFIG_ISP1301_MXC)
+	host_pdev_register(otg_resources, ARRAY_SIZE(otg_resources),
+			   &mxc_serial_host_config);
+#elif defined(CONFIG_ISP1504_MXC)
+	host_pdev_register(otg_resources, ARRAY_SIZE(otg_resources),
+			   &mxc_isp1504_config);
+#endif
+#endif
 
-	for (i = 0; i < ARRAY_SIZE(mxcusb_devices); i++) {
-		struct platform_device *pdev = &mxcusb_devices[i];
-		res = platform_device_register(pdev);
-		if (res) {
-			dev_err(&(pdev->dev), "unable to register device\n");
-			for(; i >= 0; i--)
-				platform_device_unregister(&mxcusb_devices[i]);
-			return res;
-		}
+#if defined(CONFIG_USB_GADGET_ARC) || defined(CONFIG_OTG_BTC_ARC)
+	if (platform_device_register(&otg_udc_device)) {
+		printk(KERN_ERR "usb: can't register OTG Gadget\n");
+	} else {
+		pdata = otg_udc_device.dev.platform_data;
+		printk(KERN_INFO "usb: OTG gadget (%s) registered\n",
+		       pdata->transceiver);
 	}
+#endif
+
+#ifdef CONFIG_USB_OTG
+	if (platform_device_register(&fsl_device))
+		printk(KERN_ERR "usb: can't register otg device\n");
+	else
+		printk(KERN_INFO "usb: OTG OTG registered\n");
+#endif
 
 	return 0;
 }
 
-arch_initcall(mx27_usb_init);
+module_init(mx27_usb_init);
Index: linux-2.6.18/arch/arm/plat-mxc/Kconfig
===================================================================
--- linux-2.6.18.orig/arch/arm/plat-mxc/Kconfig
+++ linux-2.6.18/arch/arm/plat-mxc/Kconfig
@@ -23,4 +23,54 @@ config MXC_EMMA
         bool
         depends on ARCH_MXC
 
+config ISP1504_MXC
+        bool
+        select ISP1504_MXC_OTG if USB_GADGET && USB_EHCI_HCD && USB_OTG
+        default y if USB_EHCI_FSL_1504 || USB_EHCI_ARC_H2 || USB_GADGET_FSL_1504
+
+config ISP1504_MXC_OTG
+        tristate
+        help
+          Support for USB OTG pin detect using the ISP1504 transceiver on MXC platforms.
+
+config ISP1301_MXC
+        bool
+        default y if USB_EHCI_FSL_1301 || USB_GADGET_FSL_1301
+        select I2C_MXC
+
+config MC13783_MXC
+        bool
+        default y if USB_EHCI_FSL_MC13783 || USB_GADGET_FSL_MC13783
+        select SPI_MXC
+
+choice
+        prompt "Select serial USB transceiver mode"
+        depends on ISP1301_MXC || MC13783_MXC
+        default MXC_USB_SU6
+
+config MXC_USB_SU6
+        bool "Single Ended Unidirectional Mode"
+        help
+          If you say yes to this option, the serial tranceiver operates in SU6 mode.
+          This option will work for either the Freescale MC13783 or Philips ISP1301
+          transceiver.
+
+config MXC_USB_SB3
+        bool "Single Ended Bidirectional Mode"
+        help
+          If you say yes to this option, the serial tranceiver operates in SB3 mode.
+          Not recommended for the Freescale MC13783.
+
+config MXC_USB_DU6
+        bool "Differential Unidirectional Mode"
+        help
+          If you say yes to this option, the serial tranceiver operates in DU6 mode.
+
+config MXC_USB_DB4
+        bool "Differential Bidirectional Mode"
+        help
+          If you say yes to this option, the serial tranceiver operates in DB4 mode.
+
+endchoice
+
 endif
Index: linux-2.6.18/arch/arm/plat-mxc/Makefile
===================================================================
--- linux-2.6.18.orig/arch/arm/plat-mxc/Makefile
+++ linux-2.6.18/arch/arm/plat-mxc/Makefile
@@ -4,4 +4,15 @@
 
 # Common support
 obj-y := irq.o clock.o gpio.o wdog.o
-obj-$(CONFIG_ARCH_MX2) += dma_mx2.o
+obj-$(CONFIG_ARCH_MX2) += dma_mx2.o usb_common.o
+
+# USB support
+obj-$(CONFIG_ISP1504_MXC) += isp1504xc.o
+
+obj-$(CONFIG_ISP1301_MXC) += isp1301xc.o
+
+obj-$(CONFIG_MC13783_MXC) += mc13783_xc.o
+
+ifneq ($(CONFIG_USB_EHCI_ARC_H1),)
+obj-y += serialxc.o
+endif
Index: linux-2.6.18/arch/arm/plat-mxc/isp1301xc.c
===================================================================
--- /dev/null
+++ linux-2.6.18/arch/arm/plat-mxc/isp1301xc.c
@@ -0,0 +1,275 @@
+/*
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/usb/fsl_xcvr.h>
+#include <linux/i2c.h>
+
+#include <asm/arch/arc_otg.h>
+
+/*
+ * ISP1301 register addresses,all register of ISP1301
+ * is one-byte length register
+ */
+
+/* ISP1301: I2C device address */
+#define ISP1301_DEV_ADDR		0x2D
+
+/* ISP 1301 register set*/
+#define ISP1301_MODE_REG1_SET		0x04
+#define ISP1301_MODE_REG1_CLR		0x05
+
+#define ISP1301_CTRL_REG1_SET		0x06
+#define ISP1301_CTRL_REG1_CLR		0x07
+
+#define ISP1301_INT_SRC_REG		0x08
+#define ISP1301_INT_LAT_REG_SET		0x0a
+#define ISP1301_INT_LAT_REG_CLR		0x0b
+#define ISP1301_INT_FALSE_REG_SET	0x0c
+#define ISP1301_INT_FALSE_REG_CLR	0x0d
+#define ISP1301_INT_TRUE_REG_SET	0x0e
+#define ISP1301_INT_TRUE_REG_CLR	0x0f
+
+#define ISP1301_CTRL_REG2_SET		0x10
+#define ISP1301_CTRL_REG2_CLR		0x11
+
+#define ISP1301_MODE_REG2_SET		0x12
+#define ISP1301_MODE_REG2_CLR		0x13
+
+#define ISP1301_BCD_DEV_REG0		0x14
+#define ISP1301_BCD_DEV_REG1		0x15
+
+/* OTG Control register bit description */
+#define DP_PULLUP			0x01
+#define DM_PULLUP			0x02
+#define DP_PULLDOWN			0x04
+#define DM_PULLDOWN			0x08
+#define ID_PULLDOWN			0x10
+#define VBUS_DRV			0x20
+#define VBUS_DISCHRG			0x40
+#define VBUS_CHRG			0x80
+
+/* Mode Control 1 register bit description */
+#define SPEED_REG			0x01
+#define SUSPEND_REG			0x02
+#define DAT_SE0				0x04
+#define TRANSP_EN			0x08
+#define BDIS_ACON_EN			0x10
+#define OE_INT_EN			0x20
+#define UART_EN				0x40
+
+/* Mode Control 2 register bit description */
+#define SPD_SUSP_CTRL			0x02
+#define BI_DI				0x04
+
+static int isp1301_attach(struct i2c_adapter *adapter);
+static int isp1301_detach(struct i2c_client *client);
+
+static struct i2c_driver isp1301_i2c_driver = {
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = "isp1301 Client",
+		   },
+	.attach_adapter = isp1301_attach,
+	.detach_client = isp1301_detach,
+};
+
+static struct i2c_client isp1301_i2c_client = {
+	.name = "isp1301 I2C dev",
+	.addr = ISP1301_DEV_ADDR,
+	.driver = &isp1301_i2c_driver,
+};
+
+static unsigned short normal_i2c[] = { ISP1301_DEV_ADDR, I2C_CLIENT_END };
+
+/* Magic definition of all other variables and things */
+I2C_CLIENT_INSMOD;
+
+static int isp1301_detect_client(struct i2c_adapter *adapter, int address,
+				 int kind)
+{
+	isp1301_i2c_client.adapter = adapter;
+	if (i2c_attach_client(&isp1301_i2c_client)) {
+		isp1301_i2c_client.adapter = NULL;
+		printk(KERN_ERR "isp1301_attach: i2c_attach_client failed\n");
+		return -1;
+	}
+
+	printk(KERN_INFO "isp1301 Detected\n");
+	return 0;
+}
+
+/*!
+ * isp1301 I2C attach function
+ *
+ * @param adapter            struct i2c_adapter *
+ * @return  Error code indicating success or failure
+ */
+static int isp1301_attach(struct i2c_adapter *adapter)
+{
+	return i2c_probe(adapter, &addr_data, &isp1301_detect_client);
+}
+
+/*!
+ * isp1301 I2C detach function
+ *
+ * @param client            struct i2c_client *
+ * @return  Error code indicating success or failure
+ */
+static int isp1301_detach(struct i2c_client *client)
+{
+	int err;
+
+	if (!isp1301_i2c_client.adapter)
+		return -1;
+
+	err = i2c_detach_client(&isp1301_i2c_client);
+	isp1301_i2c_client.adapter = NULL;
+
+	return err;
+}
+
+static void isp1301_init(struct fsl_xcvr_ops *this)
+{
+	pr_debug("%s\n", __FUNCTION__);
+
+	i2c_add_driver(&isp1301_i2c_driver);
+}
+
+static void isp1301_uninit(struct fsl_xcvr_ops *this)
+{
+	// DDD do this for host only:
+	/* disable OTG VBUS */
+	i2c_del_driver(&isp1301_i2c_driver);
+}
+
+/* Write ISP1301 register*/
+static inline void isp1301_write_reg(char reg, char data)
+{
+	i2c_smbus_write_byte_data(&isp1301_i2c_client, reg, data);
+}
+
+/* read ISP1301 register*/
+static inline char isp1301_read_reg(char reg)
+{
+	return i2c_smbus_read_byte_data(&isp1301_i2c_client, reg);
+}
+
+/* set ISP1301 as USB host*/
+static inline void isp1301_set_serial_host(void)
+{
+	pr_debug("%s\n", __FUNCTION__);
+
+	isp1301_write_reg(ISP1301_MODE_REG2_CLR, 0xFF);
+#if defined(CONFIG_MXC_USB_SB3) || defined(CONFIG_MXC_USB_DB4)
+	isp1301_write_reg(ISP1301_MODE_REG2_SET, SPD_SUSP_CTRL | BI_DI);
+#else
+	isp1301_write_reg(ISP1301_MODE_REG2_SET, SPD_SUSP_CTRL);
+#endif
+
+	isp1301_write_reg(ISP1301_MODE_REG1_CLR, 0xFF);
+#if defined(CONFIG_MXC_USB_SB3) || defined(CONFIG_MXC_USB_SU6)
+	isp1301_write_reg(ISP1301_MODE_REG1_SET, DAT_SE0 | SPEED_REG);
+#else
+	isp1301_write_reg(ISP1301_MODE_REG1_SET, SPEED_REG);
+#endif
+
+	/* configure transceiver for host mode */
+	isp1301_write_reg(ISP1301_CTRL_REG1_SET,
+			  (VBUS_DRV | DP_PULLDOWN | DM_PULLDOWN));
+}
+
+/* set ISP1301 as USB device*/
+static inline void isp1301_set_serial_dev(void)
+{
+	pr_debug("%s\n", __FUNCTION__);
+
+	isp1301_write_reg(ISP1301_MODE_REG2_CLR, 0xFF);
+#if defined(CONFIG_MXC_USB_SB3) || defined(CONFIG_MXC_USB_DB4)
+	isp1301_write_reg(ISP1301_MODE_REG2_SET, SPD_SUSP_CTRL | BI_DI);
+#else
+	isp1301_write_reg(ISP1301_MODE_REG2_SET, SPD_SUSP_CTRL);
+#endif
+
+	isp1301_write_reg(ISP1301_MODE_REG1_CLR, 0xFF);
+#if defined(CONFIG_MXC_USB_SB3) || defined(CONFIG_MXC_USB_SU6)
+	isp1301_write_reg(ISP1301_MODE_REG1_SET, DAT_SE0 | SPEED_REG);
+#else
+	isp1301_write_reg(ISP1301_MODE_REG1_SET, SPEED_REG);
+#endif
+
+	/* FS mode, DP pull down, DM pull down */
+	isp1301_write_reg(ISP1301_CTRL_REG1_SET,
+			  (DP_PULLDOWN | DM_PULLDOWN | DP_PULLUP));
+}
+
+static void isp1301_set_vbus_power(u32 * view, int on)
+{
+	pr_debug("%s(on=%d)\n", __FUNCTION__, on);
+	if (on) {
+		/* disable D+ pull-up */
+		isp1301_write_reg(ISP1301_CTRL_REG1_CLR, DP_PULLUP);
+		/* enable D+ pull-down */
+		isp1301_write_reg(ISP1301_CTRL_REG1_SET, DP_PULLDOWN);
+		/* turn on Vbus */
+		isp1301_write_reg(ISP1301_CTRL_REG1_SET, VBUS_DRV);
+	} else {
+		/* D+ pull up, D- pull down  */
+		isp1301_write_reg(ISP1301_CTRL_REG1_SET,
+				  (DP_PULLUP | DM_PULLDOWN));
+		/* disable D- pull up, disable D+ pull down */
+		isp1301_write_reg(ISP1301_CTRL_REG1_CLR,
+				  (DM_PULLUP | DP_PULLDOWN));
+	}
+}
+
+static struct fsl_xcvr_ops isp1301_ops_otg = {
+	.name = "isp1301",
+	.xcvr_type = PORTSC_PTS_SERIAL,
+	.init = isp1301_init,
+	.uninit = isp1301_uninit,
+	.set_host = isp1301_set_serial_host,
+	.set_device = isp1301_set_serial_dev,
+	.set_vbus_power = isp1301_set_vbus_power,
+};
+
+extern void fsl_usb_xcvr_register(struct fsl_xcvr_ops *xcvr_ops);
+
+static int __init isp1301xc_init(void)
+{
+	pr_debug("%s\n", __FUNCTION__);
+
+	fsl_usb_xcvr_register(&isp1301_ops_otg);
+
+	return 0;
+}
+
+extern void fsl_usb_xcvr_unregister(struct fsl_xcvr_ops *xcvr_ops);
+
+static void __exit isp1301xc_exit(void)
+{
+	fsl_usb_xcvr_unregister(&isp1301_ops_otg);
+}
+
+module_init(isp1301xc_init);
+module_exit(isp1301xc_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("isp1301");
+MODULE_LICENSE("GPL");
Index: linux-2.6.18/arch/arm/plat-mxc/isp1504xc.c
===================================================================
--- /dev/null
+++ linux-2.6.18/arch/arm/plat-mxc/isp1504xc.c
@@ -0,0 +1,234 @@
+/*
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/usb/fsl_xcvr.h>
+
+#include <asm/hardware.h>
+#include <asm/arch/arc_otg.h>
+
+/* ISP 1504 register addresses */
+#define ISP1504_VID_LOW		0x00	/* Vendor ID low */
+#define ISP1504_VID_HIGH	0x01	/* Vendor ID high */
+#define ISP1504_PID_LOW		0x02	/* Product ID low */
+#define ISP1504_PID_HIGH	0x03	/* Product ID high */
+#define ISP1504_ITFCTL		0x07	/* Interface Control */
+#define ISP1504_OTGCTL		0x0A	/* OTG Control */
+
+/* add to above register address to access Set/Clear functions */
+#define ISP1504_REG_SET		0x01
+#define ISP1504_REG_CLEAR	0x02
+
+/* 1504 OTG Control Register bits */
+#define USE_EXT_VBUS_IND	(1 << 7)	/* Use ext. Vbus indicator */
+#define DRV_VBUS_EXT		(1 << 6)	/* Drive Vbus external */
+#define DRV_VBUS		(1 << 5)	/* Drive Vbus */
+#define CHRG_VBUS		(1 << 4)	/* Charge Vbus */
+#define DISCHRG_VBUS		(1 << 3)	/* Discharge Vbus */
+#define DM_PULL_DOWN		(1 << 2)	/* enable DM Pull Down */
+#define DP_PULL_DOWN		(1 << 1)	/* enable DP Pull Down */
+#define ID_PULL_UP		(1 << 0)	/* enable ID Pull Up */
+
+/*!
+ * read ULPI register 'reg' thru VIEWPORT register 'view'
+ *
+ * @param       reg   register to read
+ * @param       view  the ULPI VIEWPORT register address
+ * @return	return isp1504 register value
+ */
+static u8 isp1504_read(int reg, volatile u32 * view)
+{
+	u32 data;
+
+	/* make sure interface is running */
+	if (!(__raw_readl(view) && ULPIVW_SS)) {
+		__raw_writel(ULPIVW_WU, view);
+		do {		/* wait for wakeup */
+			data = __raw_readl(view);
+		} while (data & ULPIVW_WU);
+	}
+
+	/* read the register */
+	__raw_writel((ULPIVW_RUN | (reg << ULPIVW_ADDR_SHIFT)), view);
+
+	do {			/* wait for completion */
+		data = __raw_readl(view);
+	} while (data & ULPIVW_RUN);
+
+	return (u8) (data >> ULPIVW_RDATA_SHIFT) & ULPIVW_RDATA_MASK;
+}
+
+/*!
+ * set bits into OTG ISP1504 register 'reg' thru VIEWPORT register 'view'
+ *
+ * @param       bits  set value
+ * @param	reg   which register
+ * @param       view  the ULPI VIEWPORT register address
+ */
+static void isp1504_set(u8 bits, int reg, volatile u32 * view)
+{
+	u32 data;
+
+	/* make sure interface is running */
+	if (!(__raw_readl(view) && ULPIVW_SS)) {
+		__raw_writel(ULPIVW_WU, view);
+		do {		/* wait for wakeup */
+			data = __raw_readl(view);
+		} while (data & ULPIVW_WU);
+	}
+
+	__raw_writel((ULPIVW_RUN | ULPIVW_WRITE |
+		      ((reg + ISP1504_REG_SET) << ULPIVW_ADDR_SHIFT) |
+		      ((bits & ULPIVW_WDATA_MASK) << ULPIVW_WDATA_SHIFT)),
+		     view);
+
+	while (__raw_readl(view) & ULPIVW_RUN)	/* wait for completion */
+		continue;
+}
+
+/*!
+ * clear bits in OTG ISP1504 register 'reg' thru VIEWPORT register 'view'
+ *
+ * @param       bits  bits to clear
+ * @param	reg   in this register
+ * @param       view  the ULPI VIEWPORT register address
+ */
+static void isp1504_clear(u8 bits, int reg, volatile u32 * view)
+{
+	__raw_writel((ULPIVW_RUN | ULPIVW_WRITE |
+		      ((reg + ISP1504_REG_CLEAR) << ULPIVW_ADDR_SHIFT) |
+		      ((bits & ULPIVW_WDATA_MASK) << ULPIVW_WDATA_SHIFT)),
+		     view);
+
+	while (__raw_readl(view) & ULPIVW_RUN)	/* wait for completion */
+		continue;
+}
+
+extern int gpio_usbotg_hs_active(void);
+
+static void isp1508_fix(u32 * view)
+{
+	/* Set bits IND_PASS_THRU and IND_COMPL */
+	isp1504_set(0x60, ISP1504_ITFCTL, view);
+
+	/* Set bit USE_EXT_VBUS_IND */
+	isp1504_set(USE_EXT_VBUS_IND, ISP1504_OTGCTL, view);
+}
+
+/*!
+ * set vbus power
+ *
+ * @param       view  viewport register
+ * @param       on    power on or off
+ */
+static void isp1504_set_vbus_power(u32 * view, int on)
+{
+	pr_debug("real %s(on=%d) view=0x%p\n", __FUNCTION__, on, view);
+
+	pr_debug("ULPI Vendor ID 0x%x    Product ID 0x%x\n",
+		 (isp1504_read(ISP1504_VID_HIGH, view) << 8) |
+		 isp1504_read(ISP1504_VID_LOW, view),
+		 (isp1504_read(ISP1504_PID_HIGH, view) << 8) |
+		 isp1504_read(ISP1504_PID_LOW, view));
+
+	pr_debug("OTG Control before=0x%x\n",
+		 isp1504_read(ISP1504_OTGCTL, view));
+
+	if (on) {
+		isp1504_set(DRV_VBUS_EXT |	/* enable external Vbus */
+			    DRV_VBUS |	/* enable internal Vbus */
+			    USE_EXT_VBUS_IND |	/* use external indicator */
+			    CHRG_VBUS,	/* charge Vbus */
+			    ISP1504_OTGCTL, view);
+
+	} else {
+		isp1508_fix(view);
+
+		isp1504_clear(DRV_VBUS_EXT |	/* disable external Vbus */
+			      DRV_VBUS,	/* disable internal Vbus */
+			      ISP1504_OTGCTL, view);
+
+		isp1504_set(USE_EXT_VBUS_IND |	/* use external indicator */
+			    DISCHRG_VBUS,	/* discharge Vbus */
+			    ISP1504_OTGCTL, view);
+	}
+
+	pr_debug("OTG Control after = 0x%x\n",
+		 isp1504_read(ISP1504_OTGCTL, view));
+}
+
+/*!
+ * set remote wakeup
+ *
+ * @param       view  viewport register
+ */
+static void isp1504_set_remote_wakeup(u32 * view)
+{
+	__raw_writel(~ULPIVW_WRITE & __raw_readl(view), view);
+	__raw_writel((1 << ULPIVW_PORT_SHIFT) | __raw_readl(view), view);
+	__raw_writel(ULPIVW_RUN | __raw_readl(view), view);
+
+	while (__raw_readl(view) & ULPIVW_RUN)	/* wait for completion */
+		continue;
+}
+
+static void isp1504_init(struct fsl_xcvr_ops *this)
+{
+	pr_debug("%s:\n", __FUNCTION__);
+}
+
+static void isp1504_uninit(struct fsl_xcvr_ops *this)
+{
+	pr_debug("%s:\n", __FUNCTION__);
+}
+
+static struct fsl_xcvr_ops isp1504_ops = {
+	.name = "isp1504",
+	.xcvr_type = PORTSC_PTS_ULPI,
+	.init = isp1504_init,
+	.uninit = isp1504_uninit,
+	.set_host = NULL,
+	.set_device = NULL,
+	.set_vbus_power = isp1504_set_vbus_power,
+	.set_remote_wakeup = isp1504_set_remote_wakeup,
+};
+
+extern void fsl_usb_xcvr_register(struct fsl_xcvr_ops *xcvr_ops);
+
+static int __init isp1504xc_init(void)
+{
+	pr_debug("%s\n", __FUNCTION__);
+
+	fsl_usb_xcvr_register(&isp1504_ops);
+
+	return 0;
+}
+
+extern void fsl_usb_xcvr_unregister(struct fsl_xcvr_ops *xcvr_ops);
+
+static void __exit isp1504xc_exit(void)
+{
+	fsl_usb_xcvr_unregister(&isp1504_ops);
+}
+
+module_init(isp1504xc_init);
+module_exit(isp1504xc_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("isp1504 xcvr driver");
+MODULE_LICENSE("GPL");
Index: linux-2.6.18/arch/arm/plat-mxc/serialxc.c
===================================================================
--- /dev/null
+++ linux-2.6.18/arch/arm/plat-mxc/serialxc.c
@@ -0,0 +1,64 @@
+/*
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/usb/fsl_xcvr.h>
+
+#include <asm/hardware.h>
+#include <asm/arch/arc_otg.h>
+
+static void usb_serial_init(struct fsl_xcvr_ops *this)
+{
+}
+
+static void usb_serial_uninit(struct fsl_xcvr_ops *this)
+{
+}
+
+static struct fsl_xcvr_ops serial_ops = {
+	.name = "serial",
+	.xcvr_type = PORTSC_PTS_SERIAL,
+	.init = usb_serial_init,
+	.uninit = usb_serial_uninit,
+};
+
+extern void fsl_usb_xcvr_register(struct fsl_xcvr_ops *xcvr_ops);
+
+static int __init serialxc_init(void)
+{
+	pr_debug("%s\n", __FUNCTION__);
+
+	fsl_usb_xcvr_register(&serial_ops);
+
+	return 0;
+}
+
+extern void fsl_usb_xcvr_unregister(struct fsl_xcvr_ops *xcvr_ops);
+
+static void __exit serialxc_exit(void)
+{
+	fsl_usb_xcvr_unregister(&serial_ops);
+}
+
+module_init(serialxc_init);
+module_exit(serialxc_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("serial xcvr driver");
+MODULE_LICENSE("GPL");
Index: linux-2.6.18/arch/arm/plat-mxc/usb_common.c
===================================================================
--- /dev/null
+++ linux-2.6.18/arch/arm/plat-mxc/usb_common.c
@@ -0,0 +1,589 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ *	otg_{get,set}_transceiver() are from arm/plat-omap/usb.c.
+ *	which is Copyright (C) 2004 Texas Instruments, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ *@defgroup USB ARC OTG USB Driver
+ */
+
+/*!
+ * @file usb_common.c
+ *
+ * @brief platform related part of usb driver.
+ * @ingroup USB
+ */
+
+/*!
+ *Include files
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/usb/otg.h>
+#include <linux/usb/fsl_xcvr.h>
+#include <asm/arch/arc_otg.h>
+
+#define MXC_NUMBER_USB_TRANSCEIVER 6
+struct fsl_xcvr_ops *g_xc_ops[MXC_NUMBER_USB_TRANSCEIVER] = { NULL };
+
+static struct clk *usb_clk;
+static struct clk *usb_ahb_clk;
+
+/*
+ * make sure USB_CLK is running at 60 MHz +/- 1000 Hz
+ */
+static int fsl_check_usbclk(void)
+{
+	unsigned long freq;
+
+	usb_ahb_clk = clk_get(NULL, "usb_ahb_clk");
+	if (clk_enable(usb_ahb_clk)) {
+		printk(KERN_ERR "clk_enable(usb_ahb_clk) failed\n");
+		return -EINVAL;
+	}
+	clk_put(usb_ahb_clk);
+
+	usb_clk = clk_get(NULL, "usb_clk");
+	freq = clk_get_rate(usb_clk);
+	clk_put(usb_clk);
+	if ((freq < 59999000) || (freq > 60001000)) {
+		printk(KERN_ERR "USB_CLK=%lu, should be 60MHz\n", freq);
+		return -1;
+	}
+
+	return 0;
+}
+
+void fsl_usb_xcvr_register(struct fsl_xcvr_ops *xcvr_ops)
+{
+	int i;
+
+	pr_debug("%s\n", __FUNCTION__);
+	for (i = 0; i < MXC_NUMBER_USB_TRANSCEIVER; i++) {
+		if (g_xc_ops[i] == NULL) {
+			g_xc_ops[i] = xcvr_ops;
+			return;
+		}
+	}
+
+	pr_debug("Failed %s\n", __FUNCTION__);
+}
+
+EXPORT_SYMBOL(fsl_usb_xcvr_register);
+
+void fsl_usb_xcvr_unregister(struct fsl_xcvr_ops *xcvr_ops)
+{
+	int i;
+
+	pr_debug("%s\n", __FUNCTION__);
+	for (i = 0; i < MXC_NUMBER_USB_TRANSCEIVER; i++) {
+		if (g_xc_ops[i] == xcvr_ops) {
+			g_xc_ops[i] = NULL;
+			return;
+		}
+	}
+
+	pr_debug("Failed %s\n", __FUNCTION__);
+}
+
+EXPORT_SYMBOL(fsl_usb_xcvr_unregister);
+
+static struct fsl_xcvr_ops *fsl_usb_get_xcvr(char *name)
+{
+	int i;
+
+	pr_debug("%s\n", __FUNCTION__);
+	if (name == NULL) {
+		printk(KERN_ERR "None tranceiver name be passed\n");
+		return NULL;
+	}
+
+	for (i = 0; i < MXC_NUMBER_USB_TRANSCEIVER; i++) {
+		if (strcmp(g_xc_ops[i]->name, name) == 0) {
+			return g_xc_ops[i];
+		}
+	}
+	pr_debug("Failed %s\n", __FUNCTION__);
+	return NULL;
+}
+
+/* The dmamask must be set for EHCI to work */
+static u64 ehci_dmamask = ~(u32) 0;
+
+/*!
+ * Register an instance of a USB host platform device.
+ *
+ * @param	res:	resource pointer
+ * @param       n_res:	number of resources
+ * @param       config: config pointer
+ *
+ * @return      newly-registered platform_device
+ *
+ * The USB controller supports 3 host interfaces, and the
+ * kernel can be configured to support some number of them.
+ * Each supported host interface is registered as an instance
+ * of the "fsl-ehci" device.  Call this function multiple times
+ * to register each host interface.
+ */
+static int instance_id = 0;
+struct platform_device *host_pdev_register(struct resource *res, int n_res, struct fsl_usb2_platform_data
+					   *config)
+{
+	struct platform_device *pdev;
+	int rc;
+
+	pr_debug("register host res=0x%p, size=%d\n", res, n_res);
+
+	pdev = platform_device_register_simple("fsl-ehci",
+					       instance_id, res, n_res);
+	if (IS_ERR(pdev)) {
+		pr_debug("can't register %s Host, %ld\n",
+			 config->name, PTR_ERR(pdev));
+		return NULL;
+	}
+
+	pdev->dev.coherent_dma_mask = 0xffffffff;
+	pdev->dev.dma_mask = &ehci_dmamask;
+
+	/*
+	 * platform_device_add_data() makes a copy of
+	 * the platform_data passed in.  That makes it
+	 * impossible to share the same config struct for
+	 * all OTG devices (host,gadget,otg).  So, just
+	 * set the platorm_data pointer ourselves.
+	 */
+	rc = platform_device_add_data(pdev, config,
+				      sizeof(struct fsl_usb2_platform_data));
+	if (rc) {
+		platform_device_unregister(pdev);
+		return NULL;
+	}
+
+	printk(KERN_INFO "usb: %s host (%s) registered\n", config->name,
+	       config->transceiver);
+	pr_debug("pdev=0x%p  dev=0x%p  resources=0x%p  pdata=0x%p\n",
+		 pdev, &pdev->dev, pdev->resource, pdev->dev.platform_data);
+
+	instance_id++;
+
+	return pdev;
+}
+
+static int fsl_usb_mem_init(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct fsl_usb2_platform_data *pdata;
+
+	pdata = (struct fsl_usb2_platform_data *)pdev->dev.platform_data;
+
+	pr_debug("%s: pdev=0x%p  pdata=0x%p\n", __FUNCTION__, pdev, pdata);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "no MEM resource.\n");
+		return -ENODEV;
+	}
+
+	pdata->r_start = res->start;
+	pdata->r_len = res->end - res->start + 1;
+	pr_debug("%s: MEM resource start=0x%x  len=0x%x\n", pdata->name,
+		 res->start, pdata->r_len);
+
+	if (!request_mem_region(pdata->r_start, pdata->r_len, "OTG")) {
+		dev_err(&pdev->dev, "request_mem_region failed\n");
+		return -EBUSY;
+	}
+	pdata->regs = ioremap(pdata->r_start, pdata->r_len);
+	pr_debug("ioremapped to 0x%p\n", pdata->regs);
+
+	if (pdata->regs == NULL) {
+		dev_err(&pdev->dev, "ioremap failed\n");
+		release_mem_region(pdata->r_start, pdata->r_len);
+		return -EFAULT;
+	}
+
+	pr_debug("%s: success\n", __FUNCTION__);
+	return 0;
+}
+
+static int fsl_usb_mem_map(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct fsl_usb2_platform_data *pdata;
+
+	pdata = (struct fsl_usb2_platform_data *)pdev->dev.platform_data;
+
+	pr_debug("%s: pdev=0x%p  pdata=0x%p\n", __FUNCTION__, pdev, pdata);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "no MEM resource.\n");
+		return -ENODEV;
+	}
+
+	pdata->r_start = res->start;
+	pdata->r_len = res->end - res->start + 1;
+	pr_debug("%s: MEM resource start=0x%x  len=0x%x\n", pdata->name,
+		 res->start, pdata->r_len);
+
+	pdata->regs = ioremap(pdata->r_start, pdata->r_len);
+	pr_debug("ioremapped to 0x%p\n", pdata->regs);
+
+	if (pdata->regs == NULL) {
+		dev_err(&pdev->dev, "ioremap failed\n");
+		return -EFAULT;
+	}
+
+	pr_debug("%s: success\n", __FUNCTION__);
+	return 0;
+}
+
+void fsl_platform_set_vbus_power(struct fsl_usb2_platform_data *pdata, int on)
+{
+	if (pdata->xcvr_ops && pdata->xcvr_ops->set_vbus_power)
+		pdata->xcvr_ops->set_vbus_power((u32 *) pdata->viewport, on);
+}
+
+EXPORT_SYMBOL(fsl_platform_set_vbus_power);
+
+void fsl_platform_perform_remote_wakeup(struct fsl_usb2_platform_data *pdata)
+{
+	if (pdata->xcvr_ops && pdata->xcvr_ops->set_remote_wakeup)
+		pdata->xcvr_ops->set_remote_wakeup((u32 *) pdata->viewport);
+}
+
+EXPORT_SYMBOL(fsl_platform_perform_remote_wakeup);
+
+#if defined(CONFIG_USB_OTG)
+static struct otg_transceiver *xceiv;
+
+/**
+ * otg_get_transceiver - find the (single) OTG transceiver driver
+ *
+ * Returns the transceiver driver, after getting a refcount to it; or
+ * null if there is no such transceiver.  The caller is responsible for
+ * releasing that count.
+ */
+struct otg_transceiver *otg_get_transceiver(void)
+{
+	pr_debug("%s xceiv=0x%p\n", __FUNCTION__, xceiv);
+	if (xceiv)
+		get_device(xceiv->dev);
+	return xceiv;
+}
+
+EXPORT_SYMBOL(otg_get_transceiver);
+
+int otg_set_transceiver(struct otg_transceiver *x)
+{
+	pr_debug("%s xceiv=0x%p  x=0x%p\n", __FUNCTION__, xceiv, x);
+	if (xceiv && x)
+		return -EBUSY;
+	xceiv = x;
+	return 0;
+}
+
+EXPORT_SYMBOL(otg_set_transceiver);
+#endif
+
+static void usbh1_set_serial_xcvr(void)
+{
+	pr_debug("%s: \n", __FUNCTION__);
+	USBCTRL &= ~(UCTRL_H1SIC_MASK | UCTRL_BPE);	/* disable bypass mode */
+	USBCTRL |= UCTRL_H1SIC_SU6 |	/* single-ended / unidir. */
+	    UCTRL_H1WIE | UCTRL_H1DT |	/* disable H1 TLL */
+	    UCTRL_H1PM;		/* power mask */
+	UH1_PORTSC1 &= ~PORTSC_PTS_MASK;
+	UH1_PORTSC1 |= PORTSC_PTS_SERIAL;
+}
+
+static void usbh2_set_ulpi_xcvr(void)
+{
+	pr_debug("%s\n", __FUNCTION__);
+	USBCTRL &= ~(UCTRL_H2SIC_MASK | UCTRL_BPE);	/* disable bypass mode */
+	USBCTRL |= UCTRL_H2WIE |	/* wakeup intr enable */
+	    UCTRL_H2UIE |	/* ULPI intr enable */
+	    UCTRL_H2DT |	/* disable H2 TLL */
+	    UCTRL_H2PM;		/* power mask */
+
+	UH2_PORTSC1 &= ~PORTSC_PTS_MASK;	/* set ULPI xcvr */
+	UH2_PORTSC1 |= PORTSC_PTS_ULPI;
+
+	/* Turn off the usbpll for ulpi tranceivers */
+	clk_disable(usb_clk);
+}
+
+int fsl_usb_host_init(struct platform_device *pdev)
+{
+	struct fsl_usb2_platform_data *pdata;
+	struct fsl_xcvr_ops *xops;
+	int rc;
+
+	pdata = (struct fsl_usb2_platform_data *)pdev->dev.platform_data;
+
+	pr_debug("%s: pdev=0x%p  pdata=0x%p\n", __FUNCTION__, pdev,
+		 pdata->name);
+
+	xops = fsl_usb_get_xcvr(pdata->transceiver);
+	if (!xops) {
+		printk(KERN_ERR "%s transceiver ops missing\n", pdata->name);
+		return -EINVAL;
+	}
+	pdata->xcvr_ops = xops;
+	pdata->xcvr_type = xops->xcvr_type;
+
+	if (fsl_check_usbclk() != 0)
+		return -EINVAL;
+
+	/* request_mem_region and ioremap registers */
+	if ((rc = fsl_usb_mem_init(pdev))) {
+		pdata->gpio_usb_inactive();	/* release our pins */
+		return rc;
+	}
+
+	pr_debug("%s: grab pins\n", __FUNCTION__);
+	if (pdata->gpio_usb_active())
+		return -EINVAL;
+
+	if (clk_enable(usb_clk)) {
+		printk(KERN_ERR "clk_enable(usb_clk) failed\n");
+		return -EINVAL;
+	}
+
+	if (xops->init)
+		xops->init(xops);
+
+	if (xops->xcvr_type == PORTSC_PTS_SERIAL) {
+		usbh1_set_serial_xcvr();
+	} else if (xops->xcvr_type == PORTSC_PTS_ULPI) {
+		usbh2_set_ulpi_xcvr();
+	}
+
+	pr_debug("%s: %s success\n", __FUNCTION__, pdata->name);
+	return 0;
+}
+
+EXPORT_SYMBOL(fsl_usb_host_init);
+
+void fsl_usb_host_uninit(struct fsl_usb2_platform_data *pdata)
+{
+	pr_debug("%s\n", __FUNCTION__);
+
+	if (pdata->xcvr_ops && pdata->xcvr_ops->uninit)
+		pdata->xcvr_ops->uninit(pdata->xcvr_ops);
+
+	iounmap(pdata->regs);
+	release_mem_region(pdata->r_start, pdata->r_len);
+
+	pdata->regs = NULL;
+	pdata->r_start = pdata->r_len = 0;
+
+	pdata->gpio_usb_inactive();
+	if (pdata->xcvr_type == PORTSC_PTS_SERIAL)
+		clk_disable(usb_clk);
+}
+
+EXPORT_SYMBOL(fsl_usb_host_uninit);
+
+static void otg_set_serial_xcvr(void)
+{
+	u32 tmp;
+
+	pr_debug("%s\n", __FUNCTION__);
+	tmp = UOG_PORTSC1 & ~PORTSC_PTS_MASK;
+	tmp |= PORTSC_PTS_SERIAL;
+	UOG_PORTSC1 = tmp;
+}
+
+void otg_set_serial_host(void)
+{
+	pr_debug("%s\n", __FUNCTION__);
+	/* set USBCTRL for host operation
+	 * disable: bypass mode,
+	 * set: single-ended/unidir/6 wire, OTG wakeup intr enable,
+	 *      power mask
+	 */
+	USBCTRL &= ~UCTRL_OSIC_MASK;
+#if defined(CONFIG_ARCH_MX27) || defined(CONFIG_ARCH_MX3)
+	USBCTRL &= ~UCTRL_BPE;
+#endif
+
+#if defined(CONFIG_MXC_USB_SB3)
+	USBCTRL |= UCTRL_OSIC_SB3 | UCTRL_OWIE | UCTRL_OPM;
+#elif defined(CONFIG_MXC_USB_SU6)
+	USBCTRL |= UCTRL_OSIC_SU6 | UCTRL_OWIE | UCTRL_OPM;
+#elif defined(CONFIG_MXC_USB_DB4)
+	USBCTRL |= UCTRL_OSIC_DB4 | UCTRL_OWIE | UCTRL_OPM;
+#else
+	USBCTRL |= UCTRL_OSIC_DU6 | UCTRL_OWIE | UCTRL_OPM;
+#endif
+
+	USB_OTG_MIRROR = 0xa;
+}
+
+EXPORT_SYMBOL(otg_set_serial_host);
+
+void otg_set_serial_peripheral(void)
+{
+	/* set USBCTRL for device operation
+	 * disable: bypass mode
+	 * set: differential/unidir/6 wire, OTG wakeup intr enable,
+	 *      power mask
+	 */
+	USBCTRL &= ~UCTRL_OSIC_MASK;
+#if defined(CONFIG_ARCH_MX27) || defined(CONFIG_ARCH_MX3)
+	USBCTRL &= ~UCTRL_BPE;
+#endif
+
+#if defined(CONFIG_MXC_USB_SB3)
+	USBCTRL |= UCTRL_OSIC_SB3 | UCTRL_OWIE | UCTRL_OPM;
+#elif defined(CONFIG_MXC_USB_SU6)
+	USBCTRL |= UCTRL_OSIC_SU6 | UCTRL_OWIE | UCTRL_OPM;
+#elif defined(CONFIG_MXC_USB_DB4)
+	USBCTRL |= UCTRL_OSIC_DB4 | UCTRL_OWIE | UCTRL_OPM;
+#else
+	USBCTRL |= UCTRL_OSIC_DU6 | UCTRL_OWIE | UCTRL_OPM;
+#endif
+
+	USB_OTG_MIRROR = 0xd;
+}
+
+EXPORT_SYMBOL(otg_set_serial_peripheral);
+
+static void otg_set_ulpi_xcvr(void)
+{
+	u32 tmp;
+
+	pr_debug("%s\n", __FUNCTION__);
+	USBCTRL &= ~UCTRL_OSIC_MASK;
+#if defined(CONFIG_ARCH_MX27) || defined(CONFIG_ARCH_MX3)
+	USBCTRL &= ~UCTRL_BPE;
+#endif
+	USBCTRL |= UCTRL_OUIE |	/* ULPI intr enable */
+	    UCTRL_OWIE |	/* OTG wakeup intr enable */
+	    UCTRL_OPM;		/* power mask */
+
+	/* set ULPI xcvr */
+	tmp = UOG_PORTSC1 & ~PORTSC_PTS_MASK;
+	tmp |= PORTSC_PTS_ULPI;
+	UOG_PORTSC1 = tmp;
+
+	/* need to reset the controller here so that the ID pin
+	 * is correctly detected.
+	 */
+	UOG_USBCMD |= UCMD_RESET;
+
+	/* allow controller to reset, and leave time for
+	 * the ULPI transceiver to reset too.
+	 */
+	msleep(100);
+
+	/* Turn off the usbpll for ulpi tranceivers */
+	clk_disable(usb_clk);
+}
+
+static int otg_used = 0;
+
+int usbotg_init(struct platform_device *pdev)
+{
+	struct fsl_usb2_platform_data *pdata;
+	struct fsl_xcvr_ops *xops;
+	int rc;
+
+	pdata = (struct fsl_usb2_platform_data *)pdev->dev.platform_data;
+
+	pr_debug("%s: pdev=0x%p  pdata=0x%p\n", __FUNCTION__, pdev, pdata);
+
+	xops = fsl_usb_get_xcvr(pdata->transceiver);
+	if (!xops) {
+		printk(KERN_ERR "OTG transceiver ops missing\n");
+		return -EINVAL;
+	}
+	pdata->xcvr_ops = xops;
+	pdata->xcvr_type = xops->xcvr_type;
+
+	if (!otg_used) {
+		if (fsl_check_usbclk() != 0)
+			return -EINVAL;
+
+		pr_debug("%s: grab pins\n", __FUNCTION__);
+		if (pdata->gpio_usb_active())
+			return -EINVAL;
+
+		if (clk_enable(usb_clk)) {
+			printk(KERN_ERR "clk_enable(usb_clk) failed\n");
+			return -EINVAL;
+		}
+
+		/* request_mem_region and ioremap registers */
+		if ((rc = fsl_usb_mem_init(pdev))) {
+			return rc;
+		}
+
+		if (xops->init)
+			xops->init(xops);
+
+		if (xops->xcvr_type == PORTSC_PTS_SERIAL) {
+			if (pdata->operating_mode == FSL_USB2_DR_HOST) {
+				otg_set_serial_host();
+				/* need reset */
+				UOG_USBCMD |= UCMD_RESET;
+				msleep(100);
+			} else if (pdata->operating_mode == FSL_USB2_DR_DEVICE)
+				otg_set_serial_peripheral();
+			otg_set_serial_xcvr();
+		} else if (xops->xcvr_type == PORTSC_PTS_ULPI) {
+			otg_set_ulpi_xcvr();
+		}
+	} else {
+		fsl_usb_mem_map(pdev);
+	}
+
+	otg_used++;
+	pr_debug("%s: success\n", __FUNCTION__);
+	return 0;
+}
+
+EXPORT_SYMBOL(usbotg_init);
+
+void usbotg_uninit(struct fsl_usb2_platform_data *pdata)
+{
+	pr_debug("%s\n", __FUNCTION__);
+
+	otg_used--;
+	if (!otg_used) {
+		if (pdata->xcvr_ops && pdata->xcvr_ops->uninit)
+			pdata->xcvr_ops->uninit(pdata->xcvr_ops);
+
+		iounmap(pdata->regs);
+		release_mem_region(pdata->r_start, pdata->r_len);
+
+		pdata->regs = NULL;
+		pdata->r_start = pdata->r_len = 0;
+
+		pdata->gpio_usb_inactive();
+		if (pdata->xcvr_type == PORTSC_PTS_SERIAL)
+			clk_disable(usb_clk);
+	}
+}
+
+EXPORT_SYMBOL(usbotg_uninit);
Index: linux-2.6.18/drivers/usb/Makefile
===================================================================
--- linux-2.6.18.orig/drivers/usb/Makefile
+++ linux-2.6.18/drivers/usb/Makefile
@@ -66,3 +66,6 @@ obj-$(CONFIG_USB_APPLEDISPLAY)	+= misc/
 
 obj-$(CONFIG_USB_ATM)		+= atm/
 obj-$(CONFIG_USB_SPEEDTOUCH)	+= atm/
+
+obj-$(CONFIG_USB_OTG)          += otg/
+
Index: linux-2.6.18/drivers/usb/gadget/Kconfig
===================================================================
--- linux-2.6.18.orig/drivers/usb/gadget/Kconfig
+++ linux-2.6.18/drivers/usb/gadget/Kconfig
@@ -207,27 +207,13 @@ config USB_OMAP
 	default USB_GADGET
 	select USB_GADGET_SELECTED
 
-config USB_OTG
-	boolean "OTG Support"
-	depends on USB_GADGET_OMAP && ARCH_OMAP_OTG && USB_OHCI_HCD
-	help
-	   The most notable feature of USB OTG is support for a
-	   "Dual-Role" device, which can act as either a device
-	   or a host.  The initial role choice can be changed
-	   later, when two dual-role devices talk to each other.
-
-	   Select this only if your OMAP board has a Mini-AB connector.
-
 config USB_GADGET_ARC
-	boolean "ARC USB Device Controller"
+	boolean "Freescale USB Device Controller"
 	depends on ARCH_MXC
-	select USB_GADGET_DUALSPEED
- 	help
-	   Some Freescale processors have an ARC High Speed
-	   USBOTG controller, which supports device mode.
-	   This driver supports the controller in the i.MX27 or i.MX31,
-	   and should work with controllers
-	   in other Freescale processors too, given minor tweaks.
+	select USB_GADGET_DUALSPEED if USB_GADGET_FSL_1504
+	help
+          Some Freescale processors have a USBOTG controller,
+          which supports device mode.
 
 	   Say "y" to link the driver statically, or "m" to build a
 	   dynamically linked module called "arc_udc" and force all
@@ -316,6 +302,18 @@ config USB_MPC885ADS
 
 endchoice
 
+config USB_OTG
+	boolean "OTG Support"
+	depends on (USB_GADGET_OMAP && ARCH_OMAP_OTG && USB_OHCI_HCD) || \
+		(USB_GADGET_ARC && ARCH_MX2 && USB_GADGET_FSL_1504 && USB_EHCI_HCD)
+	help
+	   The most notable feature of USB OTG is support for a
+	   "Dual-Role" device, which can act as either a device
+	   or a host.  The initial role choice can be changed
+	   later, when two dual-role devices talk to each other.
+
+	   Select this only if your board has a Mini-AB connector.
+
 config USB_GADGET_DUALSPEED
 	bool
 	depends on USB_GADGET
@@ -324,6 +322,40 @@ config USB_GADGET_DUALSPEED
 	  Means that gadget drivers should include extra descriptors
 	  and code to handle dual-speed controllers.
 
+config USB_GADGET_ARC_OTG
+	bool "Support for OTG peripheral port on Freescale controller"
+	depends on USB_GADGET_ARC
+	default y
+	help
+	  Enable support for the Freescale OTG port in peripheral mode.
+
+choice
+	prompt "Select OTG transceiver"
+	depends on USB_GADGET_ARC_OTG
+	help
+         Choose the transceiver to use with the Freescale OTG port.
+
+config USB_GADGET_FSL_1301
+	bool "Philips ISP1301"
+	depends on !USB_EHCI_FSL_MC13783 && !USB_EHCI_FSL_1504
+	---help---
+	  Enable support for the Full Speed Philips ISP1301 transceiver.
+
+	  This is the factory default for the mx27ads board.
+	  The mx31ads and mx32ads boards require modifications
+	  to support this transceiver.
+
+config USB_GADGET_FSL_1504
+	bool "Philips ISP1504"
+	depends on !USB_EHCI_FSL_MC13783 && !USB_EHCI_FSL_1301
+	---help---
+	  Enable support for the High Speed Philips ISP1504 transceiver.
+
+	  This is the factory default for the mx31ads and mx32ads boards.
+	  The mx27ads board requires modifications to support this transceiver.
+
+endchoice
+
 #
 # USB Gadget Drivers
 #
Index: linux-2.6.18/drivers/usb/gadget/arcotg_udc.c
===================================================================
--- linux-2.6.18.orig/drivers/usb/gadget/arcotg_udc.c
+++ linux-2.6.18/drivers/usb/gadget/arcotg_udc.c
@@ -38,13 +38,15 @@
 #include <linux/platform_device.h>
 #include <linux/usb_ch9.h>
 #include <linux/usb_gadget.h>
-#include <linux/usb_otg.h>
 #include <linux/dma-mapping.h>
 #include <linux/dmapool.h>
-#include <linux/io.h>
-#include <linux/irq.h>
+#include <linux/fsl_devices.h>
+#include <linux/usb/fsl_xcvr.h>
+#include <linux/usb/otg.h>
 
 #include <asm/byteorder.h>
+#include <asm/io.h>
+#include <asm/irq.h>
 #include <asm/system.h>
 #include <asm/dma.h>
 
@@ -54,11 +56,14 @@
 extern void gpio_usbotg_hs_active(void);
 extern void gpio_usbotg_fs_active(void);
 
-static unsigned long timeout;
+static void ep0stall(struct arcotg_udc *);
+static int ep0_prime_status(struct arcotg_udc *, int);
+
+static int timeout;
 
 #undef	USB_TRACE
 
-#define	DRIVER_DESC	"MX27 ARC USBOTG Device Controller driver"
+#define	DRIVER_DESC	"ARC USBOTG Device Controller driver"
 #define	DRIVER_AUTHOR	"Freescale Semiconductor"
 #define	DRIVER_VERSION	"1 August 2005"
 
@@ -103,28 +108,29 @@ static const struct usb_endpoint_descrip
 	.wMaxPacketSize = USB_MAX_CTRL_PAYLOAD,
 };
 
-static int arcotg_udc_suspend(struct device *pdev, pm_message_t state);
-static int arcotg_udc_resume(struct device *pdev);
-static int __devexit arcotg_udc_remove(struct platform_device *pdev);
+static int udc_suspend(struct arcotg_udc *udc);
+static int fsl_udc_suspend(struct device *dev, pm_message_t state);
+static int fsl_udc_resume(struct device *dev);
 
 /********************************************************************
- * 	Internal Used Function
+ *	Internal Used Function
 ********************************************************************/
 
 #ifdef DUMP_QUEUES
 static void dump_ep_queue(struct arcotg_ep *ep)
 {
-	int ep_index = ep_index(ep) * 2 + ep_is_in(ep);
+	int ep_index;
 	struct arcotg_req *req;
 	struct ep_td_struct *dtd;
 
-	pr_debug("udc: ep=0x%p  index=%d\n", ep, ep_index);
-
 	if (list_empty(&ep->queue)) {
 		pr_debug("udc: empty\n");
 		return;
 	}
 
+	ep_index = ep_index(ep) * 2 + ep_is_in(ep);
+	pr_debug("udc: ep=0x%p  index=%d\n", ep, ep_index);
+
 	list_for_each_entry(req, &ep->queue, queue) {
 		pr_debug("udc: req=0x%p  dTD count=%d\n", req, req->dtd_count);
 		pr_debug("udc: dTD head=0x%p  tail=0x%p\n", req->head,
@@ -156,9 +162,11 @@ static inline void dump_ep_queue(struct 
  */
 static void done(struct arcotg_ep *ep, struct arcotg_req *req, int status)
 {
-	struct arcotg_udc *udc = (struct arcotg_udc *)ep->udc;
+	struct arcotg_udc *udc = NULL;
 	unsigned char stopped = ep->stopped;
 
+	udc = (struct arcotg_udc *)ep->udc;
+
 	pr_debug("udc: req=0x%p\n", req);
 	if (req->head) {
 		pr_debug("udc: freeing head=0x%p\n", req->head);
@@ -257,6 +265,8 @@ static void nuke(struct arcotg_ep *ep, i
 /*------------------------------------------------------------------
 	Internal Hardware related function
  ------------------------------------------------------------------*/
+extern void fsl_platform_set_vbus_power(struct fsl_usb2_platform_data *pdata,
+					int on);
 
 /*
  * init device controller
@@ -268,6 +278,9 @@ static int dr_controller_setup(struct ar
 	unsigned int tmp = 0, portctrl = 0;
 	void *qh_addr = udc->ep_qh;
 	struct device *dev __attribute((unused)) = udc->gadget.dev.parent;
+	struct fsl_usb2_platform_data *pdata;
+
+	pdata = udc->pdata;
 
 	pr_debug("udc: dev=0x%p\n", dev);
 
@@ -276,8 +289,6 @@ static int dr_controller_setup(struct ar
 		return -EINVAL;
 
 	/* Stop and reset the usb controller */
-
-	spin_lock(&udc->lock);
 	tmp = le32_to_cpu(usb_slave_regs->usbcmd);
 	tmp &= ~USB_CMD_RUN_STOP;
 	usb_slave_regs->usbcmd = cpu_to_le32(tmp);
@@ -285,15 +296,16 @@ static int dr_controller_setup(struct ar
 	tmp = le32_to_cpu(usb_slave_regs->usbcmd);
 	tmp |= USB_CMD_CTRL_RESET;
 	usb_slave_regs->usbcmd = cpu_to_le32(tmp);
-	spin_unlock(&udc->lock);
 
 	/* Wait for reset to complete */
-	timeout = jiffies + UDC_RESET_FLUSH_TIMEOUT;
-	while ((le32_to_cpu(usb_slave_regs->usbcmd) & USB_CMD_CTRL_RESET)) {
-		if (time_after(jiffies, timeout)) {
-			printk(KERN_ERR "%s: TIMEOUT\n", __FUNCTION__);
-			return -ETIMEDOUT;
-		}
+	timeout = 10000000;
+	while ((le32_to_cpu(usb_slave_regs->usbcmd) & USB_CMD_CTRL_RESET) &&
+	       --timeout) {
+		continue;
+	}
+	if (timeout == 0) {
+		printk(KERN_ERR "%s: TIMEOUT\n", __FUNCTION__);
+		return -ETIMEDOUT;
 	}
 
 	/* Set the controller as device mode */
@@ -303,6 +315,9 @@ static int dr_controller_setup(struct ar
 	tmp |= USB_MODE_SETUP_LOCK_OFF;
 	usb_slave_regs->usbmode = cpu_to_le32(tmp);
 
+	if (pdata->xcvr_ops && pdata->xcvr_ops->set_device)
+		pdata->xcvr_ops->set_device();
+
 	/* Clear the setup status */
 	usb_slave_regs->usbsts = 0;
 
@@ -322,10 +337,10 @@ static int dr_controller_setup(struct ar
 #ifdef DEBUG_FORCE_FS
 	portctrl |= 0x1000000;
 #endif
+
 	usb_slave_regs->portsc1 = cpu_to_le32(portctrl);
 
-	if (udc->config->set_vbus_power)
-		udc->config->set_vbus_power(0);
+	fsl_platform_set_vbus_power(pdata, 0);
 
 	return 0;
 }
@@ -351,11 +366,6 @@ static void dr_controller_run(struct arc
 	/* Clear stopped bit */
 	udc->stopped = 0;
 
-	/* Set the controller as device mode */
-	tmp = le32_to_cpu(usb_slave_regs->usbmode);
-	tmp |= USB_MODE_CTRL_MODE_DEVICE;
-	usb_slave_regs->usbmode = cpu_to_le32(tmp);
-
 	/* Set controller to Run */
 	tmp = le32_to_cpu(usb_slave_regs->usbcmd);
 	tmp |= USB_CMD_RUN_STOP;
@@ -419,13 +429,14 @@ void dr_ep_setup(unsigned char ep_num, u
 	usb_slave_regs->endptctrl[ep_num] = cpu_to_le32(tmp_epctrl);
 
 	/* wait for the write reg to finish */
-	timeout = jiffies + UDC_RESET_FLUSH_TIMEOUT;
+	timeout = 10000000;
 	while ((!(le32_to_cpu(usb_slave_regs->endptctrl[ep_num]) &
-		(tmp_epctrl & (EPCTRL_TX_ENABLE | EPCTRL_RX_ENABLE))))) {
-		if (time_after(jiffies, timeout)) {
-			printk(KERN_ERR "%s: TIMEOUT\n", __FUNCTION__);
-			break;
-		}
+		  (tmp_epctrl & (EPCTRL_TX_ENABLE | EPCTRL_RX_ENABLE))))
+	       && --timeout) {
+		continue;
+	}
+	if (timeout == 0) {
+		printk(KERN_ERR "%s: TIMEOUT\n", __FUNCTION__);
 	}
 }
 
@@ -451,11 +462,23 @@ static void dr_ep_change_stall(unsigned 
 			tmp_epctrl &= ~EPCTRL_RX_EP_STALL;
 			tmp_epctrl |= EPCTRL_RX_DATA_TOGGLE_RST;
 		}
-
 	}
 	usb_slave_regs->endptctrl[ep_num] = cpu_to_le32(tmp_epctrl);
 }
 
+/* Get stall status of a specific ep
+   Return: 0: not stalled; 1:stalled */
+static int dr_ep_get_stall(unsigned char ep_num, unsigned char dir)
+{
+	u32 epctrl;
+
+	epctrl = le32_to_cpu(usb_slave_regs->endptctrl[ep_num]);
+	if (dir)
+		return (epctrl & EPCTRL_TX_EP_STALL) ? 1 : 0;
+	else
+		return (epctrl & EPCTRL_RX_EP_STALL) ? 1 : 0;
+}
+
 /********************************************************************
 	Internal Structure Build up functions
 ********************************************************************/
@@ -596,6 +619,7 @@ static int arcotg_ep_enable(struct usb_e
 			case 64:
 				break;
 			default:
+			case USB_SPEED_LOW:
 				goto en_done;
 			}
 		}
@@ -811,15 +835,22 @@ static void arcotg_free_request(struct u
  * @return Returns a new buffer, or null if one could not be allocated
  */
 static void *arcotg_alloc_buffer(struct usb_ep *_ep, unsigned bytes,
-				 dma_addr_t *dma, gfp_t gfp_flags)
+				 dma_addr_t * dma, gfp_t gfp_flags)
 {
-	struct arcotg_ep *ep = container_of(_ep, struct arcotg_ep, ep);
+	void *retval = NULL;
 
 	if (!bytes)
 		return 0;
 
-	return dma_alloc_coherent(ep->udc->gadget.dev.parent,
-			bytes, dma, gfp_flags);
+	retval = kmalloc(bytes, gfp_flags);
+
+	if (retval)
+		*dma = virt_to_phys(retval);
+
+	pr_debug("udc: ep=%s  buffer=0x%p  dma=0x%x  len=%d\n",
+		 _ep->name, retval, *dma, bytes);
+
+	return retval;
 }
 
 /*!
@@ -832,16 +863,9 @@ static void *arcotg_alloc_buffer(struct 
 static void arcotg_free_buffer(struct usb_ep *_ep, void *buf,
 			       dma_addr_t dma, unsigned bytes)
 {
-	struct arcotg_ep *ep;
-
 	pr_debug("udc: buf=0x%p  dma=0x%x\n", buf, dma);
-
-	if (!_ep)
-		return;
-
-	ep = container_of(_ep, struct arcotg_ep, ep);
-
-	dma_free_coherent(ep->udc->gadget.dev.parent, bytes, buf, dma);
+	if (buf)
+		kfree(buf);
 }
 
 /*-------------------------------------------------------------------------*/
@@ -880,7 +904,7 @@ static int arcotg_queue_td(struct arcotg
 			goto out;
 		}
 
-		timeout = jiffies + UDC_RESET_FLUSH_TIMEOUT;
+		timeout = 10000000;
 		do {
 			/* Set ATDTW bit in USBCMD */
 			usb_slave_regs->usbcmd |= cpu_to_le32(USB_CMD_ATDTW);
@@ -889,13 +913,13 @@ static int arcotg_queue_td(struct arcotg
 			tmp_stat = le32_to_cpu(usb_slave_regs->endptstatus) &
 			    bitmask;
 
-			if (time_after(jiffies, timeout)) {
-				printk(KERN_ERR "%s: TIMEOUT\n", __FUNCTION__);
-				break;
-			}
-
 		} while ((!(usb_slave_regs->usbcmd &
-			    cpu_to_le32(USB_CMD_ATDTW))));
+			    cpu_to_le32(USB_CMD_ATDTW)))
+			 && --timeout);
+
+		if (timeout == 0) {
+			printk(KERN_ERR "%s: TIMEOUT\n", __FUNCTION__);
+		}
 
 		/* Write ATDTW bit to 0 */
 		usb_slave_regs->usbcmd &= cpu_to_le32(~USB_CMD_ATDTW);
@@ -1075,6 +1099,18 @@ static int arcotg_ep_queue(struct usb_ep
 
 	req->ep = ep;
 
+	/* if data phase is absent send the status phase */
+	if ((ep_index(ep) == 0)) {
+		if (udc->ep0_state != DATA_STATE_XMIT &&
+		    udc->ep0_state != DATA_STATE_RECV &&
+		    (udc->local_setup_buff).wLength == 0) {
+			if (ep0_prime_status(udc, EP_DIR_IN))
+				ep0stall(udc);
+			else
+				return 0;
+		}
+	}
+
 	/* map virtual address to hardware */
 	if (req->req.dma == DMA_ADDR_INVALID) {
 		req->req.dma = dma_map_single(ep->udc->gadget.dev.parent,
@@ -1110,10 +1146,8 @@ static int arcotg_ep_queue(struct usb_ep
 	/* push the dtds to device queue */
 	if (!arcotg_req_to_dtd(req, udc))
 		arcotg_queue_td(ep, req);
-	else {
-		spin_unlock_irqrestore(&udc->lock, flags);
+	else
 		return -ENOMEM;
-	}
 
 	/* EP0 */
 	if ((ep_index(ep) == 0)) {
@@ -1216,7 +1250,7 @@ static int _arcotg_ep_set_halt(struct us
 		pr_debug("udc: ep0_state now WAIT_FOR_SETUP\n");
 		udc->ep0_dir = 0;
 	}
-out:
+      out:
 	pr_debug("udc:  %s %s halt rc=%d\n",
 		 ep->ep.name, value ? "set" : "clear", status);
 
@@ -1280,17 +1314,13 @@ static void arcotg_fifo_flush(struct usb
 	do {
 		/* set the flush bit, and wait for it to clear */
 		usb_slave_regs->endptflush = cpu_to_le32(bitmask);
-		timeout = jiffies + UDC_RESET_FLUSH_TIMEOUT;
-		while (usb_slave_regs->endptflush){
-			if (time_after(jiffies, timeout)) {
-				printk(KERN_ERR "%s: TIMEOUT\n", __FUNCTION__);
-				break;
-			}
-		}
+		while (usb_slave_regs->endptflush)
+			continue;
+
 		/* if ENDPTSTAT bit is set, the flush failed. Retry. */
 		if (!(cpu_to_le32(usb_slave_regs->endptstatus) && bitmask))
 			break;
-	} while (++loops < 3);
+	} while (++loops > 3);
 }
 
 /*!
@@ -1386,12 +1416,6 @@ static int arcotg_vbus_session(struct us
 	pr_debug("udc: VBUS %s\n", is_active ? "on" : "off");
 	udc->vbus_active = (is_active != 0);
 
-	/* FIXME manipulate pullups?? check other platforms. */
-	/*if (can_pullup(udc))
-		usb_slave_regs->usbcmd |= USB_CMD_RUN_STOP;
-	else
-		usb_slave_regs->usbcmd &= ~USB_CMD_RUN_STOP;*/
-
 	spin_unlock_irqrestore(&udc->lock, flags);
 	return 0;
 }
@@ -1452,7 +1476,7 @@ static const struct usb_gadget_ops arcot
 	.pullup = arcotg_pullup,
 };
 
-static void Ep0Stall(struct arcotg_udc *udc)
+static void ep0stall(struct arcotg_udc *udc)
 {
 	u32 tmp;
 
@@ -1502,10 +1526,8 @@ static int ep0_prime_status(struct arcot
 
 	if ((arcotg_req_to_dtd(req, udc) == 0))
 		status = arcotg_queue_td(ep, req);
-	else {
-		spin_unlock_irqrestore(&udc->lock, flags);
+	else
 		return -ENOMEM;
-	}
 
 	if (status)
 		printk(KERN_ERR "Can't get control status request \n");
@@ -1531,7 +1553,7 @@ static int udc_reset_ep_queue(struct arc
 
 	return 0;
 }
-static void ch9SetAddress(struct arcotg_udc *udc, u16 value, u16 index,
+static void ch9setaddress(struct arcotg_udc *udc, u16 value, u16 index,
 			  u16 length)
 {
 	pr_debug("udc: new address=%d\n", value);
@@ -1544,57 +1566,71 @@ static void ch9SetAddress(struct arcotg_
 
 	/* Status phase */
 	if (ep0_prime_status(udc, EP_DIR_IN))
-		Ep0Stall(udc);
+		ep0stall(udc);
 }
 
-static void ch9GetStatus(struct arcotg_udc *udc, u16 value, u16 index,
-			 u16 length)
+static void ch9getstatus(struct arcotg_udc *udc, u8 request_type, u16 value,
+			 u16 index, u16 length)
 {
-	u16 usb_status = 0;	/* fix me to give correct status */
+	u16 tmp = 0;		/* Status, cpu endian */
 
 	struct arcotg_req *req;
 	struct arcotg_ep *ep;
 	int status = 0;
-	unsigned long flags;
 
-	pr_debug("%s\n", __FUNCTION__);
 	ep = &udc->eps[0];
 
-	req = container_of(arcotg_alloc_request(&ep->ep, GFP_KERNEL),
-			   struct arcotg_req, req);
+	if ((request_type & USB_RECIP_MASK) == USB_RECIP_DEVICE) {
+		/* Get device status */
+		tmp = 1 << USB_DEVICE_SELF_POWERED;
+		tmp |= udc->remote_wakeup << USB_DEVICE_REMOTE_WAKEUP;
+	} else if ((request_type & USB_RECIP_MASK) == USB_RECIP_INTERFACE) {
+		/* Get interface status */
+		/* We don't have interface information in udc driver */
+		tmp = 0;
+	} else if ((request_type & USB_RECIP_MASK) == USB_RECIP_ENDPOINT) {
+		/* Get endpoint status */
+		struct arcotg_ep *target_ep;
+
+		target_ep = get_ep_by_pipe(udc, get_pipe_by_windex(index));
+
+		/* stall if endpoint doesn't exist */
+		if (!target_ep->desc)
+			goto stall;
+		tmp = dr_ep_get_stall(ep_index(target_ep), ep_is_in(target_ep))
+				<< USB_ENDPOINT_HALT;
+	}
+
+	udc->ep0_dir = USB_DIR_IN;
+	/* Borrow the per device status_req */
+	req = udc->status_req;
+	/* Fill in the reqest structure */
+	*((u16 *) req->req.buf) = cpu_to_le16(tmp);
+	req->ep = ep;
 	req->req.length = 2;
-	req->req.buf = &usb_status;
 	req->req.status = -EINPROGRESS;
 	req->req.actual = 0;
+	req->req.complete = NULL;
+	req->dtd_count = 0;
 
-	spin_lock_irqsave(&udc->lock, flags);
-
-	/* data phase */
+	/* prime the data phase */
 	if ((arcotg_req_to_dtd(req, udc) == 0))
 		status = arcotg_queue_td(ep, req);
 	else			/* no mem */
 		goto stall;
 
 	if (status) {
-		printk(KERN_ERR "Can't respond to getstatus request \n");
-		Ep0Stall(udc);
-	} else {
-		udc->ep0_state = DATA_STATE_XMIT;
-		pr_debug("udc: ep0_state now DATA_STATE_XMIT\n");
+		printk(KERN_ERR "Can't respond to getstatus request\n");
+		goto stall;
 	}
-
 	list_add_tail(&req->queue, &ep->queue);
-	dump_ep_queue(ep);
-
-	spin_unlock_irqrestore(&udc->lock, flags);
+	udc->ep0_state = DATA_STATE_XMIT;
 	return;
-
 stall:
-	Ep0Stall(udc);
-	spin_unlock_irqrestore(&udc->lock, flags);
+	ep0stall(udc);
 }
 
-static void ch9SetConfig(struct arcotg_udc *udc, u16 value, u16 index,
+static void ch9setconfig(struct arcotg_udc *udc, u16 value, u16 index,
 			 u16 length)
 {
 	pr_debug("udc: 1 calling gadget driver->setup\n");
@@ -1611,8 +1647,8 @@ static void setup_received_irq(struct ar
 			       struct usb_ctrlrequest *setup)
 {
 	u16 ptc = 0;		/* port test control */
-	int handled = 1;	/* set to zero if we do not handle the message */
-	/* and should pass it to the gadget driver */
+	int handled = 1;	/* set to zero if we do not handle the message,
+				   and should pass it to the gadget driver */
 
 	pr_debug("udc: request=0x%x\n", setup->bRequest);
 	/* Fix Endian (udc->local_setup_buff is cpu Endian now) */
@@ -1654,8 +1690,8 @@ static void setup_received_irq(struct ar
 			     bRequestType & (USB_DIR_IN | USB_TYPE_STANDARD))
 			    != (USB_DIR_IN | USB_TYPE_STANDARD))
 				break;
-			ch9GetStatus(udc, setup->wValue, setup->wIndex,
-				     setup->wLength);
+			ch9getstatus(udc, setup->bRequestType, setup->wValue,
+				     setup->wIndex, setup->wLength);
 			break;
 
 		case USB_REQ_SET_ADDRESS:
@@ -1663,7 +1699,7 @@ static void setup_received_irq(struct ar
 			    (USB_DIR_OUT | USB_TYPE_STANDARD |
 			     USB_RECIP_DEVICE))
 				break;
-			ch9SetAddress(udc, setup->wValue, setup->wIndex,
+			ch9setaddress(udc, setup->wValue, setup->wIndex,
 				      setup->wLength);
 			break;
 
@@ -1673,7 +1709,7 @@ static void setup_received_irq(struct ar
 			     USB_RECIP_DEVICE))
 				break;
 			/* gadget layer take over the status phase */
-			ch9SetConfig(udc, setup->wValue, setup->wIndex,
+			ch9setconfig(udc, setup->wValue, setup->wIndex,
 				     setup->wLength);
 			break;
 		case USB_REQ_SET_INTERFACE:
@@ -1746,7 +1782,7 @@ static void setup_received_irq(struct ar
 				if (rc == 0) {
 					/* send status only if _arcotg_ep_set_halt success */
 					if (ep0_prime_status(udc, EP_DIR_IN))
-						Ep0Stall(udc);
+						ep0stall(udc);
 				}
 				break;
 			}
@@ -1762,13 +1798,16 @@ static void setup_received_irq(struct ar
 	if (!handled) {
 		if (udc->driver->setup(&udc->gadget, &udc->local_setup_buff)
 		    != 0) {
-			Ep0Stall(udc);
+			ep0stall(udc);
 		} else if (setup->bRequestType & USB_DIR_IN) {
 			udc->ep0_state = DATA_STATE_XMIT;
 			pr_debug("udc: ep0_state now DATA_STATE_XMIT\n");
 		} else {
-			udc->ep0_state = DATA_STATE_RECV;
-			pr_debug("udc: ep0_state now DATA_STATE_RECV\n");
+			if (setup->wLength != 0) {
+				udc->ep0_state = DATA_STATE_RECV;
+				pr_debug
+				    ("udc: ep0_state now DATA_STATE_RECV\n");
+			}
 		}
 	}
 
@@ -1785,8 +1824,8 @@ static void ep0_req_complete(struct arco
 	if (udc->usb_state == USB_STATE_ADDRESS) {
 		/* Set the new address */
 		u32 new_address = (u32) udc->device_address;
-		usb_slave_regs->deviceaddr =
-			cpu_to_le32(new_address << USB_DEVICE_ADDRESS_BIT_POS);
+		usb_slave_regs->deviceaddr = cpu_to_le32(new_address <<
+							 USB_DEVICE_ADDRESS_BIT_POS);
 		pr_debug("udc: set deviceaddr to %d\n",
 			 usb_slave_regs->
 			 deviceaddr >> USB_DEVICE_ADDRESS_BIT_POS);
@@ -1798,7 +1837,7 @@ static void ep0_req_complete(struct arco
 		done(ep0, req, 0);
 		/* receive status phase */
 		if (ep0_prime_status(udc, EP_DIR_OUT))
-			Ep0Stall(udc);
+			ep0stall(udc);
 		break;
 
 	case DATA_STATE_RECV:
@@ -1806,7 +1845,7 @@ static void ep0_req_complete(struct arco
 		done(ep0, req, 0);
 		/* send status phase */
 		if (ep0_prime_status(udc, EP_DIR_IN))
-			Ep0Stall(udc);
+			ep0stall(udc);
 		break;
 
 	case WAIT_FOR_OUT_STATUS:
@@ -1820,7 +1859,7 @@ static void ep0_req_complete(struct arco
 		break;
 
 	default:
-		Ep0Stall(udc);
+		ep0stall(udc);
 		break;
 	}
 }
@@ -1837,12 +1876,7 @@ static void tripwire_handler(struct arco
 	usb_slave_regs->endptsetupstat |= temp;
 
 	/* while a hazard exists when setup package arrives */
-	timeout = jiffies + UDC_RESET_FLUSH_TIMEOUT;
 	do {
-		if (time_after(jiffies, timeout)) {
-			printk(KERN_ERR "%s: TIMEOUT\n", __FUNCTION__);
-			break;
-		}
 		/* Set Setup Tripwire */
 		temp = cpu_to_le32(USB_CMD_SUTW);
 		usb_slave_regs->usbcmd |= temp;
@@ -1858,12 +1892,12 @@ static void tripwire_handler(struct arco
 	temp &= ~USB_CMD_SUTW;
 	usb_slave_regs->usbcmd = le32_to_cpu(temp);
 
-	timeout = jiffies + UDC_RESET_FLUSH_TIMEOUT;
-	while ((usb_slave_regs->endptsetupstat & 1)) {
-		if (time_after(jiffies, timeout)) {
-			printk(KERN_ERR "%s: TIMEOUT\n", __FUNCTION__);
-			break;
-		}
+	timeout = 10000000;
+	while ((usb_slave_regs->endptsetupstat & 1) && --timeout) {
+		continue;
+	}
+	if (timeout == 0) {
+		printk(KERN_ERR "%s: TIMEOUT\n", __FUNCTION__);
 	}
 }
 
@@ -1898,8 +1932,8 @@ static int process_ep_req(struct arcotg_
 				     & DTD_PACKET_SIZE) >> DTD_LENGTH_BIT_POS);
 		actual -= remaining_length;
 
-		errors = le32_to_cpu(curr_td->size_ioc_sts) & DTD_ERROR_MASK;
-		if (errors) {
+		if ((errors = le32_to_cpu(curr_td->size_ioc_sts) &
+		     DTD_ERROR_MASK)) {
 			if (errors & DTD_STATUS_HALTED) {
 				printk(KERN_ERR "dTD error %08x \n", errors);
 				/* Clear the errors and Halt condition */
@@ -1921,7 +1955,6 @@ static int process_ep_req(struct arcotg_
 				status = -EILSEQ;
 				break;
 			} else
-				status = -EPIPE;
 				printk(KERN_ERR
 				       "Unknown error has occured (0x%x)!\r\n",
 				       errors);
@@ -1935,8 +1968,8 @@ static int process_ep_req(struct arcotg_
 		} else if (remaining_length)
 			if (direction) {
 				pr_debug
-				    ("udc: Transmit dTD remaining length not "
-				     "zero (rl=%d)\n", remaining_length);
+				    ("udc: Transmit dTD remaining length not zero "
+				     "(rl=%d)\n", remaining_length);
 				status = -EPROTO;
 				break;
 			} else {
@@ -2010,8 +2043,8 @@ static void dtd_complete_irq(struct arco
 					 queue) {
 			status = process_ep_req(udc, i, curr_req);
 			if (status == REQ_UNCOMPLETE) {
-				pr_debug("udc: Not all tds are completed "
-					 "in the req\n");
+				pr_debug
+				    ("udc: Not all tds are completed in the req\n");
 				break;
 			}
 
@@ -2032,7 +2065,7 @@ static void port_change_irq(struct arcot
 	u32 speed;
 
 	if (udc->bus_reset)
-		udc->bus_reset = FALSE;
+		udc->bus_reset = 0;
 
 	/* Bus resetting is finished */
 	if (!(le32_to_cpu(usb_slave_regs->portsc1) & PORTSCX_PORT_RESET)) {
@@ -2114,6 +2147,7 @@ static void reset_irq(struct arcotg_udc 
 
 	/* Clear usb state */
 	udc->usb_state = USB_STATE_DEFAULT;
+	udc->remote_wakeup = 0;	/* default to 0 on reset */
 
 	/* Clear all the setup token semaphores */
 	temp = le32_to_cpu(usb_slave_regs->endptsetupstat);
@@ -2123,13 +2157,13 @@ static void reset_irq(struct arcotg_udc 
 	temp = le32_to_cpu(usb_slave_regs->endptcomplete);
 	usb_slave_regs->endptcomplete = cpu_to_le32(temp);
 
-	timeout = jiffies + 100;
+	timeout = 10000000;
 	/* Wait until all endptprime bits cleared */
-	while ((usb_slave_regs->endpointprime)) {
-		if (time_after(jiffies, timeout)) {
-			printk(KERN_ERR "%s: TIMEOUT\n", __FUNCTION__);
-			break;
-		}
+	while ((usb_slave_regs->endpointprime) && --timeout) {
+		continue;
+	}
+	if (timeout == 0) {
+		printk(KERN_ERR "%s: TIMEOUT\n", __FUNCTION__);
 	}
 
 	/* Write 1s to the Flush register */
@@ -2138,7 +2172,7 @@ static void reset_irq(struct arcotg_udc 
 	if (le32_to_cpu(usb_slave_regs->portsc1) & PORTSCX_PORT_RESET) {
 		pr_debug("udc: Bus RESET\n");
 		/* Bus is reseting */
-		udc->bus_reset = TRUE;
+		udc->bus_reset = 1;
 		udc->ep0_state = WAIT_FOR_SETUP;
 		pr_debug("udc: ep0_state now WAIT_FOR_SETUP\n");
 		udc->ep0_dir = 0;
@@ -2165,7 +2199,7 @@ static void reset_irq(struct arcotg_udc 
 	}
 }
 
-static irqreturn_t arcotg_udc_irq(int irq, void *_udc, struct pt_regs *regs)
+static irqreturn_t arcotg_udc_irq(int irq, void *_udc)
 {
 	struct arcotg_udc *udc = _udc;
 	u32 irq_src;
@@ -2268,8 +2302,8 @@ int usb_gadget_register_driver(struct us
 
 	if (!driver || (driver->speed != USB_SPEED_FULL
 			&& driver->speed != USB_SPEED_HIGH)
-	    || !driver->bind || !driver->unbind ||
-	    !driver->disconnect || !driver->setup)
+	    		|| !driver->bind || !driver->unbind ||
+	    		!driver->disconnect || !driver->setup)
 		return -EINVAL;
 
 	if (udc->driver)
@@ -2293,15 +2327,13 @@ int usb_gadget_register_driver(struct us
 	}
 
 	if (udc->transceiver) {
-		pm_message_t state = { 0 };
-
 		/* Suspend the controller until OTG enables it */
-		arcotg_udc_suspend(&udc->gadget.dev, state);
+		udc_suspend(udc);
 		pr_debug("udc: suspend udc for OTG auto detect \n");
 
-		/* export udc suspend/resume call to OTG */
-		udc->gadget.dev.driver->suspend = arcotg_udc_suspend;
-		udc->gadget.dev.driver->resume = arcotg_udc_resume;
+		/* Export udc suspend/resume call to OTG */
+		udc->gadget.dev.parent->driver->suspend = fsl_udc_suspend;
+		udc->gadget.dev.parent->driver->resume = fsl_udc_resume;
 
 		/* connect to bus through transceiver */
 		retval = otg_set_peripheral(udc->transceiver, &udc->gadget);
@@ -2327,14 +2359,17 @@ int usb_gadget_register_driver(struct us
 out:
 	return retval;
 }
+
 EXPORT_SYMBOL(usb_gadget_register_driver);
 
+/* Disconnect from gadget driver */
 int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
 {
 	struct arcotg_ep *loop_ep;
 	unsigned long flags;
 	struct arcotg_udc *udc = udc_controller;
 
+	pr_debug("usb_gadget_unregister_driver: udc=0x%p\n", udc);
 	if (!udc)
 		return -ENODEV;
 
@@ -2367,11 +2402,13 @@ int usb_gadget_unregister_driver(struct 
 	    nuke(loop_ep, -ESHUTDOWN);
 
 	/* report disconnect to free up endpoints */
+	pr_debug("udc: disconnect\n");
 	driver->disconnect(&udc->gadget);
 
 	spin_unlock_irqrestore(&udc->lock, flags);
 
 	/* unbind gadget and unhook driver. */
+	pr_debug("udc: unbind\n");
 	driver->unbind(&udc->gadget);
 	udc->gadget.dev.driver = 0;
 	udc->driver = 0;
@@ -2391,7 +2428,34 @@ EXPORT_SYMBOL(usb_gadget_unregister_driv
 
 static const char proc_filename[] = "driver/arcotg_udc";
 
-static int arcotg_proc_read(char *page, char **start, off_t off, int count,
+static inline const char * _get_PORTSCX_PTS_FSLS(u32 tmp_reg) {
+	switch (tmp_reg & PORTSCX_PTS_FSLS) {
+		case PORTSCX_PTS_UTMI: return "UTMI";
+		case PORTSCX_PTS_ULPI: return "ULPI ";
+		case PORTSCX_PTS_FSLS: return "FS/LS Serial";
+		default: return "None";
+	}
+}
+
+static inline const char * _get_PORTSCX_PORT_SPEED_UNDEF(u32 tmp_reg) {
+	switch (tmp_reg & PORTSCX_PORT_SPEED_UNDEF) {
+		case PORTSCX_PORT_SPEED_FULL: return "Full Speed";
+		case PORTSCX_PORT_SPEED_LOW: return "Low Speed";
+		case PORTSCX_PORT_SPEED_HIGH: return "High Speed";
+		default: return "Undefined";
+	}
+}
+
+static inline const char * _get_USB_MODE_CTRL_MODE_HOST(u32 tmp_reg) {
+	switch (tmp_reg & USB_MODE_CTRL_MODE_HOST) {
+		case USB_MODE_CTRL_MODE_IDLE: return "Idle";
+		case USB_MODE_CTRL_MODE_DEVICE: return "Device Controller";
+		case USB_MODE_CTRL_MODE_HOST: return "Host Controller";
+		default: return "None"
+	}
+}
+
+static int fsl_proc_read(char *page, char **start, off_t off, int count,
 			    int *eof, void *_dev)
 {
 	char *buf = page;
@@ -2402,7 +2466,6 @@ static int arcotg_proc_read(char *page, 
 	u32 tmp_reg;
 	struct arcotg_ep *ep = NULL;
 	struct arcotg_req *req;
-	char *ptt, *ps, *cm;
 
 	struct arcotg_udc *udc = udc_controller;
 	if (off != 0)
@@ -2480,34 +2543,6 @@ static int arcotg_proc_read(char *page, 
 	next += t;
 
 	tmp_reg = le32_to_cpu(usb_slave_regs->portsc1);
-	switch (tmp_reg & PORTSCX_PTS_FSLS) {
-	case PORTSCX_PTS_UTMI:
-		ptt = "UTMI";
-		break;
-	case PORTSCX_PTS_ULPI:
-		ptt = "ULPI ";
-		break;
-	case PORTSCX_PTS_FSLS:
-		ptt = "FS/LS Serial";
-		break;
-	default:
-		ptt = "None";
-		break;
-	}
-	switch (tmp_reg & PORTSCX_PORT_SPEED_UNDEF) {
-	case PORTSCX_PORT_SPEED_FULL:
-		ps = "Full Speed";
-		break;
-	case PORTSCX_PORT_SPEED_LOW:
-		ps = "Low Speed";
-		break;
-	case PORTSCX_PORT_SPEED_HIGH:
-		ps = "High Speed";
-		break;
-	default:
-		ps = "Undefined";
-		break;
-	}
 	t = scnprintf(next, size,
 		      "USB Port Status&Control Reg:\n"
 		      "Port Transceiver Type : %s" "Port Speed: %s \n"
@@ -2516,42 +2551,27 @@ static int arcotg_proc_read(char *page, 
 		      "Port Enable/Disable Change: %s\n"
 		      "Port Enabled/Disabled: %s"
 		      "Current Connect Status: %s\n\n",
-		      ptt,
-		      ps,
+		      _get_PORTSCX_PTS_FSLS(tmp_reg),
+		      _get_PORTSCX_PORT_SPEED_UNDEF(tmp_reg),
 		      (tmp_reg & PORTSCX_PHY_LOW_POWER_SPD) ?
-			"Normal PHY mode" : "Low power mode",
-		      (tmp_reg & PORTSCX_PORT_RESET) ?
-			"In Reset" : "Not in Reset",
+		      "Normal PHY mode" : "Low power mode",
+		      (tmp_reg & PORTSCX_PORT_RESET) ? "In Reset" :
+		      "Not in Reset",
 		      (tmp_reg & PORTSCX_PORT_SUSPEND) ? "In " : "Not in",
-		      (tmp_reg & PORTSCX_OVER_CURRENT_CHG) ?
-			"Detected" : "No",
-		      (tmp_reg & PORTSCX_PORT_EN_DIS_CHANGE) ?
-			"Disable" : "Not change",
-		      (tmp_reg & PORTSCX_PORT_ENABLE) ?
-			"Enable" : "Not correct",
+		      (tmp_reg & PORTSCX_OVER_CURRENT_CHG) ? "Dected" :
+		      "No",
+		      (tmp_reg & PORTSCX_PORT_EN_DIS_CHANGE) ? "Disable" :
+		      "Not change",
+		      (tmp_reg & PORTSCX_PORT_ENABLE) ? "Enable" :
+		      "Not correct",
 		      (tmp_reg & PORTSCX_CURRENT_CONNECT_STATUS) ?
-			"Attached" : "Not-Att");
+		      "Attached" : "Not-Att") ;
 	size -= t;
 	next += t;
 
 	tmp_reg = le32_to_cpu(usb_slave_regs->usbmode);
-	switch (tmp_reg & USB_MODE_CTRL_MODE_HOST) {
-	case USB_MODE_CTRL_MODE_IDLE:
-		cm = "Idle";
-		break;
-	case USB_MODE_CTRL_MODE_DEVICE:
-		cm = "Device Controller";
-		break;
-	case USB_MODE_CTRL_MODE_HOST:
-		cm = "Host Controller";
-		break;
-	default:
-		cm = "None";
-		break;
-	}
-	t = scnprintf(next, size,
-		      "USB Mode Reg:\n"
-		      "Controller Mode is : %s\n\n", cm);
+	t = scnprintf(next, size, "USB Mode Reg:" "Controller Mode is : %s\n\n",
+			_get_USB_MODE_CTRL_MODE_HOST(tmp_reg)) ;
 	size -= t;
 	next += t;
 
@@ -2574,7 +2594,7 @@ static int arcotg_proc_read(char *page, 
 	size -= t;
 	next += t;
 
-	/* arcotg_udc, arcotg_ep, arcotg_request structure information */
+	/* ------arcotg_udc, arcotg_ep, arcotg_request structure information ----- */
 	ep = &udc->eps[0];
 	t = scnprintf(next, size, "For %s Maxpkt is 0x%x index is 0x%x\n",
 		      ep->ep.name, ep_maxpacket(ep), ep_index(ep));
@@ -2588,8 +2608,7 @@ static int arcotg_proc_read(char *page, 
 	} else {
 		list_for_each_entry(req, &ep->queue, queue) {
 			t = scnprintf(next, size,
-				      "req %p actual 0x%x "
-				      "length 0x%x buf %p\n",
+				      "req %p actual 0x%x length 0x%x  buf %p\n",
 				      &req->req, req->req.actual,
 				      req->req.length, req->req.buf);
 			size -= t;
@@ -2625,13 +2644,6 @@ static int arcotg_proc_read(char *page, 
 				}
 			}
 		}
-		/* DDD debug */
-		/*else {
-			t = scnprintf(next, size, "\nno desc for %s\n",
-				      ep->ep.name);
-			size -= t;
-			next += t;
-		}*/
 	}
 
 	spin_unlock_irqrestore(&udc->lock, flags);
@@ -2641,7 +2653,7 @@ static int arcotg_proc_read(char *page, 
 }
 
 #define create_proc_file()	create_proc_read_entry(proc_filename, \
-				0, NULL, arcotg_proc_read, NULL)
+				0, NULL, fsl_proc_read, NULL)
 
 #define remove_proc_file()	remove_proc_entry(proc_filename, NULL)
 
@@ -2663,15 +2675,15 @@ static int arcotg_proc_read(char *page, 
  * release method, or the kernel prints out scary complaints
  * @param dev device controller pointer
  */
-static void arcotg_udc_release(struct device *dev)
+static void fsl_udc_release(struct device *dev)
 {
-	struct arcotg_udc *udc = udc_controller;
+	struct device *udc_dev = dev->parent;
+
+	struct arcotg_udc *udc = (struct arcotg_udc *)dev_get_drvdata(udc_dev);
 
 	complete(udc->done);
 	dma_free_coherent(dev, udc->ep_qh_size, udc->ep_qh, udc->ep_qh_dma);
-	udc->ep_qh = NULL;
 	kfree(udc);
-	udc = NULL;
 }
 
 /******************************************************************
@@ -2687,13 +2699,16 @@ static void *struct_udc_setup(struct pla
 	struct arcotg_udc *udc = NULL;
 
 	udc = (struct arcotg_udc *)
-	    kzalloc(sizeof(struct arcotg_udc), GFP_KERNEL);
+	    kmalloc(sizeof(struct arcotg_udc), GFP_KERNEL);
 	pr_debug("udc: kmalloc(ucd)=0x%p\n", udc);
 	if (udc == NULL) {
 		printk(KERN_ERR "malloc udc failed\n");
 		goto cleanup;
 	}
 
+	/* Zero out the internal USB state structure */
+	memset(udc, 0, sizeof(struct arcotg_udc));
+
 	/* initialized QHs, take care the 2K align */
 	udc->ep_qh_size = USB_MAX_PIPES * sizeof(struct ep_queue_head);
 
@@ -2704,21 +2719,18 @@ static void *struct_udc_setup(struct pla
 	udc->ep_qh = (struct ep_queue_head *)
 	    dma_alloc_coherent(&pdev->dev, udc->ep_qh_size,
 			       &udc->ep_qh_dma, GFP_KERNEL);
-	if (udc->ep_qh != NULL)
-		memset(udc->ep_qh, 0, udc->ep_qh_size);
-
 	if (!udc->ep_qh) {
 		printk(KERN_ERR "malloc QHs for udc failed\n");
 		goto cleanup;
 	}
 	pr_debug("udc: udc->ep_qh=0x%p\n", udc->ep_qh);
 
+	memset(udc->ep_qh, 0, udc->ep_qh_size);
+
 	/* need 32 byte alignment, don't cross 4K boundary */
 	udc->dtd_pool = dma_pool_create("arcotg_dtd", &pdev->dev,
 					sizeof(struct ep_td_struct), 32, 4096);
 	if (!udc->dtd_pool) {
-		dma_free_coherent(&pdev->dev, udc->ep_qh_size,
-			udc->ep_qh, udc->ep_qh_dma);
 		printk(KERN_ERR "dtd_pool alloc failed\n");
 		goto cleanup;
 	}
@@ -2741,6 +2753,7 @@ static void *struct_udc_setup(struct pla
 	udc->resume_state = USB_STATE_NOTATTACHED;
 	udc->usb_state = USB_STATE_POWERED;
 	udc->ep0_dir = 0;
+	udc->remote_wakeup = 0;	/* default to 0 on reset */
 	/* initliaze the arcotg_udc lock */
 	spin_lock_init(&udc->lock);
 
@@ -2784,7 +2797,7 @@ static int struct_ep_setup(struct arcotg
 		ep->desc = &arcotg_ep0_desc;
 		ep->ep.maxpacket = USB_MAX_CTRL_PAYLOAD;
 	} else {
-		ep->ep.maxpacket = (unsigned short)(~0);
+		ep->ep.maxpacket = (unsigned short)~0;
 		ep->desc = NULL;
 	}
 
@@ -2803,6 +2816,22 @@ static int struct_ep_setup(struct arcotg
 	return 0;
 }
 
+static int board_init(struct platform_device *pdev)
+{
+	struct fsl_usb2_platform_data *pdata;
+	pdata = (struct fsl_usb2_platform_data *)pdev->dev.platform_data;
+
+	pr_debug("%s: pdev=0x%p  pdata=0x%p\n", __FUNCTION__, pdev, pdata);
+
+	/*
+	 * do platform specific init: check the clock, grab/config pins, etc.
+	 */
+	if (pdata->platform_init && pdata->platform_init(pdev) != 0)
+		return -EINVAL;
+
+	return 0;
+}
+
 /* Driver probe functions */
 
  /*!
@@ -2810,25 +2839,24 @@ static int struct_ep_setup(struct arcotg
   * @param dev device controller pointer
   * @return Returns zero on success , or a negative error code
   */
-static int __devinit arcotg_udc_probe(struct platform_device *pdev)
+static int __devinit fsl_udc_probe(struct platform_device *pdev)
 {
-	/* FIXME: add platform_data */
-	struct arc_usb_config *config = pdev->dev.platform_data;
-	struct arcotg_udc *udc = NULL;
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+	struct arcotg_udc *udc;
+
 	unsigned int tmp_status = -ENODEV;
 	unsigned int i;
 	u32 id;
 	u64 rsrc_start, rsrc_len;
-	struct device *dev = &pdev->dev;
 
 	if (strcmp(pdev->name, "arc_udc")) {
 		pr_debug("udc: Wrong device\n");
 		return -ENODEV;
 	}
 
-	pr_debug("udc: pdev=0x%p  config=0x%p\n", pdev, config);
+	pr_debug("%s: pdev=0x%p  pdata=0x%p\n", __FUNCTION__, pdev, pdata);
 
-	if (config->platform_init() != 0)
+	if (board_init(pdev) != 0)
 		return -EINVAL;
 
 	/* Initialize the udc structure including QH member and other member */
@@ -2839,25 +2867,25 @@ static int __devinit arcotg_udc_probe(st
 		pr_debug("udc: udc is NULL\n");
 		return -ENOMEM;
 	}
-	dev_set_drvdata(dev, udc);
 
-	udc->config = config;
-	udc->xcvr_type = config->xcvr_type;
+	dev_set_drvdata(&pdev->dev, udc);
+
+	udc->pdata = pdata;
+	udc->xcvr_type = pdata->xcvr_type;
 
 #ifdef CONFIG_USB_OTG
 	udc->transceiver = otg_get_transceiver();
 	pr_debug("udc: otg_get_transceiver returns 0x%p", udc->transceiver);
 #endif
 
-	udc_controller->irq = platform_get_irq(pdev, 0);
-	if (!udc_controller->irq) {
+	if (pdev->resource[1].flags != IORESOURCE_IRQ) {
 		return -ENODEV;
 	}
 
 	rsrc_start = pdev->resource[0].start;
 	rsrc_len = pdev->resource[0].end - pdev->resource[0].start + 1;
 
-	pr_debug("     start=0x%lx   end=0x%lx\n",
+	pr_debug("start=0x%lx   end=0x%lx\n",
 		 (unsigned long)pdev->resource[0].start,
 		 (unsigned long)pdev->resource[0].end);
 	pr_debug("rsrc_start=0x%llx  rsrc_len=0x%llx\n", rsrc_start, rsrc_len);
@@ -2873,8 +2901,8 @@ static int __devinit arcotg_udc_probe(st
 	       id & 0x3f, id >> 16);
 
 	/* request irq and disable DR  */
-	tmp_status = request_irq(udc_controller->irq, arcotg_udc_irq,
-				 SA_SHIRQ, driver_name, udc);
+	tmp_status = request_irq(pdev->resource[1].start, arcotg_udc_irq,
+				 IRQF_SHARED, driver_name, udc);
 	if (tmp_status != 0) {
 		printk(KERN_ERR "cannot request irq %d err %d \n",
 		       (int)pdev->resource[1].start, tmp_status);
@@ -2908,7 +2936,7 @@ static int __devinit arcotg_udc_probe(st
 
 	strcpy(udc->gadget.dev.bus_id, "gadget");
 
-	udc->gadget.dev.release = arcotg_udc_release;
+	udc->gadget.dev.release = fsl_udc_release;
 	udc->gadget.dev.parent = &pdev->dev;
 
 	if (udc->transceiver) {
@@ -2930,14 +2958,10 @@ static int __devinit arcotg_udc_probe(st
 	}
 
 	create_proc_file();
-	if (device_add(&udc->gadget.dev)) {
-		printk(KERN_ERR "device_add: Adding device failed\n");
-		arcotg_udc_remove(pdev);
-		return -ENODEV;
-	}
-	pr_debug("udc: back from device_add\n");
+	tmp_status = device_add(&udc->gadget.dev);
+	pr_debug("udc: back from device_add ");
 
-	return 0;
+	return tmp_status;
 }
 
 /*!
@@ -2947,16 +2971,14 @@ static int __devinit arcotg_udc_probe(st
  * @param dev device controller pointer
  * @return Returns zero on success , or a negative error code
  */
-static int __devexit arcotg_udc_remove(struct platform_device *pdev)
+static int __devexit fsl_udc_remove(struct platform_device *pdev)
 {
-	struct device *dev = &pdev->dev;
-	struct arcotg_udc *udc = (struct arcotg_udc *)dev_get_drvdata(dev);
-	struct arc_usb_config *config;
+	struct arcotg_udc *udc =
+	    (struct arcotg_udc *)platform_get_drvdata(pdev);
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
 
 	DECLARE_COMPLETION(done);
 
-	config = (struct arc_usb_config *)pdev->dev.platform_data;
-
 	if (!udc)
 		return -ENODEV;
 
@@ -2973,7 +2995,7 @@ static int __devexit arcotg_udc_remove(s
 	remove_proc_file();
 
 	/* free irq */
-	free_irq(udc->irq, udc);
+	free_irq(pdev->resource[1].start, udc);
 
 	/* deinitialize all ep: strcut */
 	/* deinitialize ep0: reg and QH */
@@ -3001,8 +3023,15 @@ static int __devexit arcotg_udc_remove(s
 	 * do platform specific un-initialization:
 	 * release iomux pins, etc.
 	 */
-	config->platform_uninit();
+	if (pdata->platform_uninit)
+		pdata->platform_uninit(pdata);
+
+	return 0;
+}
 
+static int udc_suspend(struct arcotg_udc *udc)
+{
+	udc->stopped = 1;
 	return 0;
 }
 
@@ -3011,28 +3040,17 @@ static int __devexit arcotg_udc_remove(s
  * Here we stop the DR controller and disable the irq
  * @param dev device controller pointer
  * @param state current state
- * @param level power level
  * @return The function returns 0 on success or -1 if failed
  */
-static int arcotg_udc_suspend(struct device *dev, pm_message_t state)
+static int fsl_udc_suspend(struct device *dev, pm_message_t state)
 {
-	struct arcotg_udc *udc = udc_controller;
+	struct arcotg_udc *udc = (struct arcotg_udc *)dev_get_drvdata(dev);
 	pr_debug("udc: Suspend.\n");
-	udc->stopped = 1;
-	return 0;
+	return udc_suspend(udc);
 }
 
-/*!
- * Invoked on USB resume. May be called in_interrupt.
- * Here we start the DR controller and enable the irq
- * @param dev device controller pointer
- * @return The function returns 0 on success or -1 if failed
- */
-static int arcotg_udc_resume(struct device *dev)
+static int udc_resume(struct arcotg_udc *udc)
 {
-	struct arcotg_udc *udc = udc_controller;
-	pr_debug("udc: Resume dev=0x%p\n", dev);
-
 	/*Enable DR irq reg and set controller Run */
 	if (udc->stopped) {
 		dr_controller_setup(udc);
@@ -3045,11 +3063,25 @@ static int arcotg_udc_resume(struct devi
 }
 
 /*!
+ * Invoked on USB resume. May be called in_interrupt.
+ * Here we start the DR controller and enable the irq
+ * @param dev device controller pointer
+ * @return The function returns 0 on success or -1 if failed
+ */
+static int fsl_udc_resume(struct device *dev)
+{
+	struct arcotg_udc *udc = (struct arcotg_udc *)dev_get_drvdata(dev);
+	pr_debug("udc: Resume dev=0x%p udc=0x%p\n", dev, udc);
+
+	return udc_resume(udc);
+}
+
+/*!
  * Register entry point for the peripheral controller driver
  */
 static struct platform_driver udc_driver = {
-	.probe = arcotg_udc_probe,
-	.remove = __exit_p(arcotg_udc_remove),
+	.probe = fsl_udc_probe,
+	.remove = __exit_p(fsl_udc_remove),
 	.driver = {
 		   .name = driver_name,
 		   },
Index: linux-2.6.18/drivers/usb/gadget/arcotg_udc.h
===================================================================
--- linux-2.6.18.orig/drivers/usb/gadget/arcotg_udc.h
+++ linux-2.6.18/drivers/usb/gadget/arcotg_udc.h
@@ -20,13 +20,6 @@
 #ifndef __ARCOTG_UDC_H
 #define __ARCOTG_UDC_H
 
-#ifndef TRUE
-#define TRUE 1
-#endif
-#ifndef FALSE
-#define FALSE 0
-#endif
-
 /* ### define USB registers here
  */
 #define USB_MAX_ENDPOINTS		8
@@ -446,8 +439,8 @@ struct ep_td_struct {
 #define  DTD_PACKET_SIZE                      (0x7FFF0000)
 #define  DTD_LENGTH_BIT_POS                   (16)
 #define  DTD_ERROR_MASK                       (DTD_STATUS_HALTED | \
-					       DTD_STATUS_DATA_BUFF_ERR | \
-					       DTD_STATUS_TRANSACTION_ERR)
+                                               DTD_STATUS_DATA_BUFF_ERR | \
+                                               DTD_STATUS_TRANSACTION_ERR)
 
 /* -----------------------------------------------------------------------*/
 /* ##### enum data
@@ -488,6 +481,7 @@ struct arcotg_ep {
 	u32 last_io;		/* timestamp */
 
 	char name[14];
+
 	unsigned double_buf:1;
 	unsigned stopped:1;
 	unsigned fnf:1;
@@ -510,18 +504,18 @@ struct arcotg_udc {
 	struct arcotg_ep eps[USB_MAX_ENDPOINTS * 2];
 	struct usb_ctrlrequest local_setup_buff;
 	spinlock_t lock;
-	struct arc_usb_config *config;
+	struct fsl_usb2_platform_data *pdata;
 	u32 xcvr_type;
 	struct otg_transceiver *transceiver;
 	unsigned softconnect:1;
 	unsigned vbus_active:1;
 	unsigned stopped:1;
+	unsigned remote_wakeup:1;
 
 	struct ep_queue_head *ep_qh;	/* Endpoints Queue-Head */
 	int ep_qh_size;		/* Endpoints Queue-Head */
 	struct arcotg_req *status_req;	/* ep0 status request */
 
-	u32  irq;
 	u32 max_pipes;		/* Device max pipes */
 	u32 max_use_endpts;	/* Max endpointes to be used */
 	u32 bus_reset;		/* Device is bus reseting */
@@ -540,6 +534,7 @@ struct arcotg_udc {
 	struct completion *done;	/* to make sure release() is done */
 };
 
+
 /*-------------------------------------------------------------------------*/
 
 /* ### Add board specific defines here
@@ -559,14 +554,14 @@ struct arcotg_udc {
 
 #define ep_is_in(EP)	( (ep_index(EP) == 0) ? (EP->udc->ep0_dir == \
 				USB_DIR_IN ):((EP)->desc->bEndpointAddress \
-				& USB_DIR_IN) == USB_DIR_IN)
+				& USB_DIR_IN)==USB_DIR_IN)
 
 #define get_ep_by_pipe(udc, pipe)	((pipe == 1)? &udc->eps[0]: \
 					&udc->eps[pipe])
+#define get_pipe_by_windex(windex)	((windex & USB_ENDPOINT_NUMBER_MASK) \
+					* 2 + ((windex & USB_DIR_IN) ? 1 : 0))
 
 /* Bulk only class request */
 #define USB_BULK_RESET_REQUEST          0xff
 
-#define UDC_RESET_FLUSH_TIMEOUT 1000
-
 #endif				/* __ARCOTG_UDC_H */
Index: linux-2.6.18/drivers/usb/host/Kconfig
===================================================================
--- linux-2.6.18.orig/drivers/usb/host/Kconfig
+++ linux-2.6.18/drivers/usb/host/Kconfig
@@ -29,6 +29,71 @@ config USB_EHCI_HCD
 	  To compile this driver as a module, choose M here: the
 	  module will be called ehci-hcd.
 
+config USB_EHCI_ARC
+	bool "Support for Freescale controller"
+	depends on USB_EHCI_HCD && ARCH_MXC
+	---help---
+	   Some Freescale processors have an integrated High Speed
+	   USBOTG controller, which supports EHCI host mode.
+
+	   Say "y" here to add support for this controller
+	   to the EHCI HCD driver.
+
+config USB_EHCI_ARC_H1
+	bool "Support for Host1 port on Freescale controller"
+	depends on USB_EHCI_ARC && ARCH_MX2
+	---help---
+	  Enable support for the USB Host1 port.
+
+config USB_EHCI_ARC_H2
+	bool "Support for Host2 port on Freescale controller"
+	depends on USB_EHCI_ARC && \
+           (ARCH_MX2 && !SPI_MXC_SELECT1 && !SPI_MXC_SELECT2)
+	---help---
+	  Enable support for the USB Host2 port.
+
+config USB_EHCI_ARC_OTG
+	bool "Support for OTG host port on Freescale controller"
+	depends on USB_EHCI_ARC
+	default y
+	---help---
+	  Enable support for the USB OTG port in HS/FS Host mode.
+
+choice
+	prompt "Select OTG transceiver"
+	depends on USB_EHCI_ARC_OTG
+	default USB_EHCI_FSL_1301 if ARCH_MX2
+	---help---
+	  Choose the transceiver to use with the Freescale OTG port.
+
+config USB_EHCI_FSL_MC13783
+	bool "Freescale MC13783"
+	---help---
+	  Enable support for the Full Speed Freescale MC13783 transceiver.
+
+	  The mx27ads, mx31ads and mx32ads boards require modifications
+	  to support this transceiver.
+
+config USB_EHCI_FSL_1301
+	bool "Philips ISP1301"
+	---help---
+	  Enable support for the Full Speed Philips ISP1301 transceiver.
+
+	  This is the factory default for the mx27ads board.
+	  The mx31ads and mx32ads boards require modifications
+	  to support this transceiver.
+
+config USB_EHCI_FSL_1504
+	bool "Philips ISP1504"
+	---help---
+	  Enable support for the High Speed Philips ISP1504 transceiver.
+
+	  This is the factory default for the mx31ads and mx32ads boards.
+	  The mx27ads board requires modifications to support this transceiver.
+
+endchoice
+
+
 config USB_EHCI_SPLIT_ISO
 	bool "Full speed ISO transactions (EXPERIMENTAL)"
 	depends on USB_EHCI_HCD && EXPERIMENTAL
@@ -41,6 +106,7 @@ config USB_EHCI_SPLIT_ISO
 config USB_EHCI_ROOT_HUB_TT
 	bool "Root Hub Transaction Translators (EXPERIMENTAL)"
 	depends on USB_EHCI_HCD && EXPERIMENTAL
+	default y if USB_EHCI_ARC
 	---help---
 	  Some EHCI chips have vendor-specific extensions to integrate
 	  transaction translators, so that no OHCI or UHCI companion
Index: linux-2.6.18/drivers/usb/host/ehci-arc.c
===================================================================
--- linux-2.6.18.orig/drivers/usb/host/ehci-arc.c
+++ linux-2.6.18/drivers/usb/host/ehci-arc.c
@@ -29,23 +29,30 @@
 /* Note: this file is #included by ehci-hcd.c */
 
 #include <linux/platform_device.h>
-#include <linux/usb_otg.h>
+#include <linux/fsl_devices.h>
+#include <linux/usb/otg.h>
+#include <linux/usb/fsl_xcvr.h>
+#include <asm/io.h>
+#include <asm/arch/fsl_usb.h>
 
-#include <asm/arch/arc_otg.h>
+#include "ehci-fsl.h"
 
 #undef dbg
-#define dbg(fmt, ...) do {} while (0)
 #undef vdbg
+
+#define dbg(fmt, ...) do {} while (0)
 #define vdbg(fmt, ...) do {} while (0)
 
-static inline void set_host_mode(struct usb_hcd *hcd)
-{
-	u32 tmp = readl(hcd->regs + 0x1a8);
-	writel(tmp | USBMODE_CM_HC, hcd->regs + 0x1a8);
-}
+extern void fsl_platform_set_vbus_power(struct fsl_usb2_platform_data *pdata,
+					int on);
+
+/* PCI-based HCs are common, but plenty of non-PCI HCs are used too */
+
+/* configure so an HC device and id are always provided */
+/* always called with process context; sleeping is OK */
 
 /**
- * usb_hcd_arc_probe - initialize ARC HCDs
+ * usb_hcd_fsl_probe - initialize FSL-based HCDs
  * @drvier: Driver to be used for this HCD
  * @pdev: USB Host Controller being probed
  * Context: !in_interrupt()
@@ -53,29 +60,32 @@ static inline void set_host_mode(struct 
  * Allocates basic resources for this USB host controller.
  *
  */
-static int usb_hcd_arc_probe(const struct hc_driver *driver,
+static int usb_hcd_fsl_probe(const struct hc_driver *driver,
 			     struct platform_device *pdev)
 {
-	struct arc_usb_config *pdata;
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
 	struct usb_hcd *hcd;
 	struct resource *res;
 	int irq;
 	int retval;
 
-	pr_debug("initializing ARC USB Controller\n");
+	pr_debug("initializing FSL-SOC USB Controller\n");
 
 	/* Need platform data for setup */
-	pdata = (struct arc_usb_config *)pdev->dev.platform_data;
 	if (!pdata) {
 		dev_err(&pdev->dev,
 			"No platform data for %s.\n", pdev->dev.bus_id);
 		return -ENODEV;
 	}
 
+	retval = fsl_platform_verify(pdev);
+	if (retval)
+		return retval;
+
 	/*
 	 * do platform specific init: check the clock, grab/config pins, etc.
 	 */
-	if (pdata->platform_init && pdata->platform_init()) {
+	if (pdata->platform_init && pdata->platform_init(pdev)) {
 		retval = -ENODEV;
 		goto err1;
 	}
@@ -89,8 +99,7 @@ static int usb_hcd_arc_probe(const struc
 	}
 	irq = res->start;
 
-	if (pdata->set_vbus_power)
-		pdata->set_vbus_power(1);
+	fsl_platform_set_vbus_power(pdata, 1);
 
 	hcd = usb_create_hcd(driver, &pdev->dev, pdev->dev.bus_id);
 	if (!hcd) {
@@ -98,76 +107,79 @@ static int usb_hcd_arc_probe(const struc
 		goto err1;
 	}
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
-		dev_err(&pdev->dev,
-			"Found HC with no register addr. Check %s setup!\n",
-			pdev->dev.bus_id);
-		retval = -ENODEV;
-		goto err2;
-	}
-	hcd->rsrc_start = res->start;
-	hcd->rsrc_len = res->end - res->start + 1;
-
-	vdbg("start=0x%x   end=0x%x    rsrc_start=0x%llx  rsrc_len=0x%llx\n",
-	     res->start, res->end, hcd->rsrc_start, hcd->rsrc_len);
-
-	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len,
-				driver->description)) {
-		dev_dbg(&pdev->dev, "request_mem_region failed\n");
-		retval = -EBUSY;
-		goto err2;
-	}
-	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
-
-	if (hcd->regs == NULL) {
-		dev_dbg(&pdev->dev, "error mapping memory\n");
-		retval = -EFAULT;
-		goto err3;
-	}
+	hcd->rsrc_start = pdata->r_start;
+	hcd->rsrc_len = pdata->r_len;
+	hcd->regs = pdata->regs;
+	vdbg("rsrc_start=0x%llx rsrc_len=0x%llx virtual=0x%x\n",
+	     hcd->rsrc_start, hcd->rsrc_len, hcd->regs);
 
 	hcd->power_budget = pdata->power_budget;
 
 	/* DDD
 	 * the following must be done by this point, otherwise the OTG
 	 * host port doesn't make it thru initializtion.
-	 * ehci_halt(), called by ehci_arc_setup() returns -ETIMEDOUT
+	 * ehci_halt(), called by ehci_fsl_setup() returns -ETIMEDOUT
 	 */
-	set_host_mode(hcd);
+	fsl_platform_set_host_mode(hcd);
 
-	retval = usb_add_hcd(hcd, irq, SA_SHIRQ);
-	if (retval != 0)
-		goto err4;
+	retval = usb_add_hcd(hcd, irq, IRQF_SHARED);
+	if (retval != 0) {
+		pr_debug("failed with usb_add_hcd\n");
+		goto err2;
+	}
+#if defined(CONFIG_USB_OTG)
+	if (pdata->does_otg) {
+		struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+
+		dbg("pdev=0x%p  hcd=0x%p  ehci=0x%p\n", pdev, hcd, ehci);
+
+		ehci->transceiver = otg_get_transceiver();
+		dbg("ehci->transceiver=0x%p\n", ehci->transceiver);
+
+		if (ehci->transceiver) {
+			retval = otg_set_host(ehci->transceiver,
+					      &ehci_to_hcd(ehci)->self);
+			if (retval) {
+				if (ehci->transceiver)
+					put_device(ehci->transceiver->dev);
+				goto err2;
+			}
+		} else {
+			printk(KERN_ERR "can't find transceiver\n");
+			retval = -ENODEV;
+			goto err2;
+		}
+	}
+#endif
 
 	return retval;
 
-err4:
-	iounmap(hcd->regs);
-err3:
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
 err2:
 	usb_put_hcd(hcd);
 err1:
 	dev_err(&pdev->dev, "init %s fail, %d\n", pdev->dev.bus_id, retval);
 	if (pdata->platform_uninit)
-		pdata->platform_uninit();
+		pdata->platform_uninit(pdata);
 	return retval;
 }
 
-static void usb_hcd_arc_remove(struct usb_hcd *hcd,
+static void usb_hcd_fsl_remove(struct usb_hcd *hcd,
 			       struct platform_device *pdev)
 {
-	struct arc_usb_config *pdata;
-
-	pdata = (struct arc_usb_config *)pdev->dev.platform_data;
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
 
 	dbg("%s  hcd=0x%p\n", __FUNCTION__, hcd);
 
+	/* DDD shouldn't we turn off the power here? */
+	fsl_platform_set_vbus_power(pdata, 0);
+
 	usb_remove_hcd(hcd);
-	if (pdata->set_vbus_power)
-		pdata->set_vbus_power(0);
-	iounmap(hcd->regs);
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+
+	if (ehci->transceiver) {
+		(void)otg_set_host(ehci->transceiver, 0);
+		put_device(ehci->transceiver->dev);
+	}
 	usb_put_hcd(hcd);
 
 	/*
@@ -175,19 +187,28 @@ static void usb_hcd_arc_remove(struct us
 	 * release iomux pins, etc.
 	 */
 	if (pdata->platform_uninit)
-		pdata->platform_uninit();
+		pdata->platform_uninit(pdata);
+}
+
+/* called after powerup, by probe or system-pm "wakeup" */
+static int ehci_fsl_reinit(struct ehci_hcd *ehci)
+{
+	fsl_platform_usb_setup(ehci_to_hcd(ehci));
+	ehci_port_power(ehci, 0);
+
+	return 0;
 }
 
 /* called during probe() after chip reset completes */
-static int ehci_arc_setup(struct usb_hcd *hcd)
+static int ehci_fsl_setup(struct usb_hcd *hcd)
 {
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
 	int retval;
 
-	/* EHCI registers start at offset 0x00 */
+	/* EHCI registers start at offset 0x100 */
 	ehci->caps = hcd->regs + 0x100;
 	ehci->regs = hcd->regs + 0x100 +
-	    HC_LENGTH(readl(&ehci->caps->hc_capbase));
+	    HC_LENGTH(ehci_readl(ehci, &ehci->caps->hc_capbase));
 
 	vdbg("%s(): ehci->caps=0x%p  ehci->regs=0x%p\n", __FUNCTION__,
 	     ehci->caps, ehci->regs);
@@ -196,7 +217,7 @@ static int ehci_arc_setup(struct usb_hcd
 	dbg_hcc_params(ehci, "reset");
 
 	/* cache this readonly data; minimize chip reads */
-	ehci->hcs_params = readl(&ehci->caps->hcs_params);
+	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
 
 	retval = ehci_halt(ehci);
 	if (retval)
@@ -212,11 +233,12 @@ static int ehci_arc_setup(struct usb_hcd
 	ehci->sbrn = 0x20;
 
 	ehci_reset(ehci);
-	ehci_port_power(ehci, 0);
 
-	return 0;
+	retval = ehci_fsl_reinit(ehci);
+	return retval;
 }
 
+/* *INDENT-OFF* */
 static const struct hc_driver ehci_arc_hc_driver = {
 	.description	= hcd_name,
 	.product_desc	= "Freescale On-Chip EHCI Host Controller",
@@ -226,19 +248,14 @@ static const struct hc_driver ehci_arc_h
 	 * generic hardware linkage
 	 */
 	.irq		= ehci_irq,
-	.flags		= HCD_USB2,
+	.flags		= FSL_PLATFORM_HC_FLAGS,
 
 	/*
 	 * basic lifecycle operations
 	 */
-	.reset		= ehci_arc_setup,
+	.reset		= ehci_fsl_setup,
 	.start		= ehci_run,
 	.stop		= ehci_stop,
-	.shutdown	= ehci_shutdown,
-#ifdef CONFIG_PM
-	.suspend	= ehci_bus_suspend,
-	.resume		= ehci_bus_resume,
-#endif
 
 	/*
 	 * managing i/o requests and associated device resources
@@ -260,28 +277,118 @@ static const struct hc_driver ehci_arc_h
 	.bus_suspend		= ehci_bus_suspend,
 	.bus_resume		= ehci_bus_resume,
 };
+/* *INDENT-ON* */
+
+#ifdef CONFIG_USB_OTG
+volatile static struct ehci_regs usb_ehci_regs;
+
+/* suspend/resume, section 4.3 */
+
+/* These routines rely on the bus (pci, platform, etc)
+ * to handle powerdown and wakeup, and currently also on
+ * transceivers that don't need any software attention to set up
+ * the right sort of wakeup.
+ *
+ * They're also used for turning on/off the port when doing OTG.
+ */
+static int ehci_arc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+	u32 cmd;
+
+	pr_debug("%s pdev=0x%p  ehci=0x%p  hcd=0x%p\n",
+		 __FUNCTION__, pdev, ehci, hcd);
+	pr_debug("%s ehci->regs=0x%p  hcd->regs=0x%p  hcd->state=%d\n",
+		 __FUNCTION__, ehci->regs, hcd->regs, hcd->state);
+
+	hcd->state = HC_STATE_SUSPENDED;
+	pdev->dev.power.power_state = PMSG_SUSPEND;
+
+	if (hcd->driver->suspend)
+		return hcd->driver->suspend(hcd, state);
+
+	/* ignore non-host interrupts */
+	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+
+	cmd = ehci_readl(ehci, &ehci->regs->command);
+	cmd &= ~CMD_RUN;
+	ehci_writel(ehci, cmd, &ehci->regs->command);
+
+	memcpy((void *)&usb_ehci_regs, ehci->regs, sizeof(struct ehci_regs));
+	usb_ehci_regs.port_status[0] &=
+	    cpu_to_le32(~(PORT_PEC | PORT_OCC | PORT_CSC));
+
+	fsl_platform_set_vbus_power(pdata, 0);
+
+	return 0;
+}
+
+static int ehci_arc_resume(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	u32 tmp;
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+
+	dbg("%s pdev=0x%p  pdata=0x%p  ehci=0x%p  hcd=0x%p\n",
+	    __FUNCTION__, pdev, pdata, ehci, hcd);
+
+	vdbg("%s ehci->regs=0x%p  hcd->regs=0x%p  usbmode=0x%x\n",
+	     __FUNCTION__, ehci->regs, hcd->regs, pdata->usbmode);
+
+	tmp = USBMODE_CM_HOST;
+	if (ehci_big_endian_mmio(ehci))
+		tmp |= USBMODE_BE;
+
+	ehci_writel(ehci, tmp, (u32 *)pdata->usbmode);
+
+	memcpy(ehci->regs, (void *)&usb_ehci_regs, sizeof(struct ehci_regs));
+
+	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+	hcd->state = HC_STATE_RUNNING;
+	pdev->dev.power.power_state = PMSG_ON;
+
+	tmp = ehci_readl(ehci, &ehci->regs->command);
+	tmp |= CMD_RUN;
+	ehci_writel(ehci, tmp, &ehci->regs->command);
+
+	fsl_platform_set_vbus_power(pdata, 1);
+
+	usb_hcd_resume_root_hub(hcd);
+
+	return 0;
+}
+#endif				/* CONFIG_USB_OTG */
 
 static int ehci_hcd_drv_probe(struct platform_device *pdev)
 {
 	if (usb_disabled())
 		return -ENODEV;
 
-	return usb_hcd_arc_probe(&ehci_arc_hc_driver, pdev);
+	return usb_hcd_fsl_probe(&ehci_arc_hc_driver, pdev);
 }
 
 static int __init_or_module ehci_hcd_drv_remove(struct platform_device *pdev)
 {
 	struct usb_hcd *hcd = platform_get_drvdata(pdev);
 
-	usb_hcd_arc_remove(hcd, pdev);
+	usb_hcd_fsl_remove(hcd, pdev);
 
 	return 0;
 }
 
-static struct platform_driver ehci_arc_driver = {
+/* *INDENT-OFF* */
+static struct platform_driver ehci_fsl_driver = {
 	.probe   = ehci_hcd_drv_probe,
 	.remove  = ehci_hcd_drv_remove,
+#ifdef CONFIG_USB_OTG
+	.suspend = ehci_arc_suspend,
+	.resume  = ehci_arc_resume,
+#endif
 	.driver  = {
-			.name = "arc-ehci",
+			.name = "fsl-ehci",
 		   },
 };
+/* *INDENT-ON* */
Index: linux-2.6.18/drivers/usb/host/ehci-hcd.c
===================================================================
--- linux-2.6.18.orig/drivers/usb/host/ehci-hcd.c
+++ linux-2.6.18/drivers/usb/host/ehci-hcd.c
@@ -984,6 +984,11 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		ehci_hcd_au1xxx_driver
 #endif
 
+#ifdef CONFIG_USB_EHCI_ARC
+#include "ehci-arc.c"
+#define        PLATFORM_DRIVER         ehci_fsl_driver
+#endif
+
 #ifdef CONFIG_PPC_PS3
 #include "ehci-ps3.c"
 #define	PS3_SYSTEM_BUS_DRIVER	ps3_ehci_sb_driver
@@ -1004,11 +1009,6 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		ixp4xx_ehci_driver
 #endif
 
-#ifdef CONFIG_ARCH_MXC
-#include "ehci-arc.c"
-#define PLATFORM_DRIVER		ehci_arc_driver
-#endif
-
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
     !defined(PS3_SYSTEM_BUS_DRIVER)
 #error "missing bus glue for ehci-hcd"
Index: linux-2.6.18/drivers/usb/host/ehci.h
===================================================================
--- linux-2.6.18.orig/drivers/usb/host/ehci.h
+++ linux-2.6.18/drivers/usb/host/ehci.h
@@ -119,6 +119,12 @@ struct ehci_hcd {			/* one per controlle
 
 	u8			sbrn;		/* packed release number */
 
+       /*
+        * OTG controllers and transceivers need software interaction;
+        * other external transceivers should be software-transparent
+        */
+       struct otg_transceiver   *transceiver;
+
 	/* irq statistics */
 #ifdef EHCI_STATS
 	struct ehci_stats	stats;
@@ -296,10 +302,8 @@ struct ehci_regs {
 } __attribute__ ((packed));
 
 #define USBMODE		0x68		/* USB Device mode */
-#define USBMODE_SDIS	(1<<3)		/* Stream disable */
 #define USBMODE_BE	(1<<2)		/* BE/LE endianness select */
 #define USBMODE_CM_HC	(3<<0)		/* host controller mode */
-#define USBMODE_CM_IDLE	(0<<0)		/* idle state */
 
 /* Appendix C, Debug port ... intended for use with special "debug devices"
  * that can help if there's no serial console.  (nonstandard enumeration.)
Index: linux-2.6.18/drivers/usb/otg/Makefile
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/usb/otg/Makefile
@@ -0,0 +1,6 @@
+#
+# Makefile for USB OTG controller  driver
+#
+# USB transceiver
+isp1504_arc-objs		:= fsl_otg.o otg_fsm.o
+obj-$(CONFIG_ISP1504_MXC_OTG) += isp1504_arc.o
Index: linux-2.6.18/drivers/usb/otg/fsl_otg.c
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/usb/otg/fsl_otg.c
@@ -0,0 +1,1076 @@
+/*
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/proc_fs.h>
+#include <linux/errno.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/usb.h>
+#include <linux/platform_device.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb_gadget.h>
+#include <linux/time.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+
+#include <linux/fsl_devices.h>
+#include "fsl_otg.h"
+#include <asm/arch/arc_otg.h>
+
+#define CONFIG_USB_OTG_DEBUG_FILES
+#define DRIVER_VERSION "Revision: 1.0"
+#define DRIVER_AUTHOR "Jerry Huang/Leo Li"
+#define DRIVER_DESC "USB OTG Driver"
+#define DRIVER_INFO DRIVER_VERSION " " DRIVER_DESC
+
+MODULE_DESCRIPTION("ARC USB OTG Transceiver Driver");
+
+static const char otg_dr_name[] = "fsl_arc";
+static spinlock_t usb_dr_regs_lock;
+
+#undef HA_DATA_PULSE
+
+volatile static struct usb_dr_mmap *usb_dr_regs;
+static struct fsl_otg *fsl_otg_dev = NULL;
+static int srp_wait_done;
+
+/* FSM timers */
+struct fsl_otg_timer *a_wait_vrise_tmr, *a_wait_bcon_tmr, *a_aidl_bdis_tmr,
+    *b_ase0_brst_tmr, *b_se0_srp_tmr;
+
+/* Driver specific timers */
+struct fsl_otg_timer *b_data_pulse_tmr, *b_vbus_pulse_tmr, *b_srp_fail_tmr,
+    *b_srp_wait_tmr, *a_wait_enum_tmr;
+
+static struct list_head active_timers;
+
+static struct fsl_otg_config fsl_otg_initdata = {
+	.otg_port = 1,
+};
+
+/**
+ * usb_bus_start_enum - start immediate enumeration (for OTG)
+ * @bus: the bus (must use hcd framework)
+ * @port: 1-based number of port; usually bus->otg_port
+ * Context: in_interrupt()
+ *
+ * Starts enumeration, with an immediate reset followed later by
+ * khubd identifying and possibly configuring the device.
+ * This is needed by OTG controller drivers, where it helps meet
+ * HNP protocol timing requirements for starting a port reset.
+ */
+
+#include "../../../drivers/usb/core/hcd.h"
+
+int usb_bus_start_enum(struct usb_bus *bus, unsigned port_num)
+{
+	struct usb_hcd *hcd;
+	int status = -EOPNOTSUPP;
+
+	/* NOTE: since HNP can't start by grabbing the bus's address0_sem,
+	 * boards with root hubs hooked up to internal devices (instead of
+	 * just the OTG port) may need more attention to resetting...
+	 */
+
+	hcd = container_of(bus, struct usb_hcd, self);
+	if (port_num && hcd->driver->start_port_reset)
+		status = hcd->driver->start_port_reset(hcd, port_num);
+
+	/* run khubd shortly after (first) root port reset finishes;
+	 * it may issue others, until at least 50 msecs have passed.
+	 */
+	if (status == 0)
+		mod_timer(&hcd->rh_timer, jiffies + msecs_to_jiffies(10));
+
+	return status;
+}
+
+#if defined(CONFIG_ISP1504_MXC)
+int write_ulpi(u8 addr, u8 data)
+{
+	u32 temp;
+	temp = 0x60000000 | (addr << 16) | data;
+	temp = cpu_to_le32(temp);
+	usb_dr_regs->ulpiview = temp;
+	return 0;
+}
+#endif
+
+/* prototype declaration */
+void fsl_otg_add_timer(void *timer);
+void fsl_otg_del_timer(void *timer);
+
+/* -------------------------------------------------------------*/
+/* Operations that will be called from OTG Finite State Machine */
+
+/* Charge vbus for vbus pulsing in SRP */
+void fsl_otg_chrg_vbus(int on)
+{
+	if (on)
+		usb_dr_regs->otgsc =
+		    cpu_to_le32((le32_to_cpu(usb_dr_regs->otgsc) &
+				 ~OTGSC_INTSTS_MASK &
+				 ~OTGSC_CTRL_VBUS_DISCHARGE) |
+				OTGSC_CTRL_VBUS_CHARGE);
+	else
+		usb_dr_regs->otgsc =
+		    cpu_to_le32((le32_to_cpu(usb_dr_regs->otgsc) &
+				 ~OTGSC_INTSTS_MASK & ~OTGSC_CTRL_VBUS_CHARGE));
+}
+
+/* Discharge vbus through a resistor to ground */
+void fsl_otg_dischrg_vbus(int on)
+{
+	if (on)
+		usb_dr_regs->otgsc =
+		    cpu_to_le32((le32_to_cpu(usb_dr_regs->otgsc) &
+				 ~OTGSC_INTSTS_MASK)
+				| OTGSC_CTRL_VBUS_DISCHARGE);
+	else
+		usb_dr_regs->otgsc =
+		    cpu_to_le32((le32_to_cpu(usb_dr_regs->otgsc) &
+				 ~OTGSC_INTSTS_MASK &
+				 ~OTGSC_CTRL_VBUS_DISCHARGE));
+}
+
+/* A-device driver vbus, controlled through PP bit in PORTSC */
+void fsl_otg_drv_vbus(int on)
+{
+	if (on)
+		usb_dr_regs->portsc =
+		    cpu_to_le32((le32_to_cpu(usb_dr_regs->portsc) &
+				 ~PORTSC_W1C_BITS) | PORTSC_PORT_POWER);
+	else
+		usb_dr_regs->portsc =
+		    cpu_to_le32(le32_to_cpu(usb_dr_regs->portsc) &
+				~PORTSC_W1C_BITS & ~PORTSC_PORT_POWER);
+
+}
+
+/* Pull-up D+, signalling connect by periperal. Also used in
+ * data-line pulsing in SRP */
+void fsl_otg_loc_conn(int on)
+{
+	if (on)
+		usb_dr_regs->otgsc =
+		    cpu_to_le32((le32_to_cpu(usb_dr_regs->otgsc) &
+				 ~OTGSC_INTSTS_MASK) | OTGSC_CTRL_DATA_PULSING);
+	else
+		usb_dr_regs->otgsc =
+		    cpu_to_le32(le32_to_cpu(usb_dr_regs->otgsc) &
+				~OTGSC_INTSTS_MASK & ~OTGSC_CTRL_DATA_PULSING);
+}
+
+/* Generate SOF by host.  This is controlled through suspend/resume the
+ * port.  In host mode, controller will automatically send SOF.
+ * Suspend will block the data on the port.
+ */
+void fsl_otg_loc_sof(int on)
+{
+}
+
+/* Start SRP pulsing by data-line pulsing, followed with v-bus pulsing. */
+void fsl_otg_start_pulse(void)
+{
+	srp_wait_done = 0;
+#ifdef HA_DATA_PULSE
+	usb_dr_regs->otgsc =
+	    cpu_to_le32((le32_to_cpu(usb_dr_regs->otgsc) & ~OTGSC_INTSTS_MASK)
+			| OTGSC_HA_DATA_PULSE);
+#else
+	fsl_otg_loc_conn(1);
+#endif
+
+	fsl_otg_add_timer(b_data_pulse_tmr);
+}
+
+void fsl_otg_pulse_vbus(void);
+
+void b_data_pulse_end(unsigned long foo)
+{
+#ifdef HA_DATA_PULSE
+#else
+	fsl_otg_loc_conn(0);
+#endif
+
+	/* Do VBUS pulse after data pulse */
+	fsl_otg_pulse_vbus();
+}
+
+void fsl_otg_pulse_vbus(void)
+{
+	srp_wait_done = 0;
+	fsl_otg_chrg_vbus(1);
+	/* start the timer to end vbus charge */
+	fsl_otg_add_timer(b_vbus_pulse_tmr);
+}
+
+void b_vbus_pulse_end(unsigned long foo)
+{
+	fsl_otg_chrg_vbus(0);
+
+	/* As USB3300 using the same a_sess_vld and b_sess_vld voltage
+	 * we need to discharge the bus for a while to distinguish
+	 * residual voltage of vbus pulsing and A device pull up */
+	fsl_otg_dischrg_vbus(1);
+	fsl_otg_add_timer(b_srp_wait_tmr);
+}
+
+void b_srp_end(unsigned long foo)
+{
+	fsl_otg_dischrg_vbus(0);
+	srp_wait_done = 1;
+
+	if ((fsl_otg_dev->otg.state == OTG_STATE_B_SRP_INIT) &&
+	    fsl_otg_dev->fsm.b_sess_vld)
+		fsl_otg_dev->fsm.b_srp_done = 1;
+}
+
+/* Workaround for a_host suspending too fast.  When a_bus_req=0,
+ * a_host will start by SRP.  It needs to set b_hnp_enable before
+ * actually suspending to start HNP
+ */
+void a_wait_enum(unsigned long foo)
+{
+	VDBG("a_wait_enum timeout\n");
+	if (!fsl_otg_dev->otg.host->b_hnp_enable)
+		fsl_otg_add_timer(a_wait_enum_tmr);
+	else
+		otg_statemachine(&fsl_otg_dev->fsm);
+}
+
+/* ------------------------------------------------------*/
+
+/* The timeout callback function to set time out bit */
+void set_tmout(unsigned long indicator)
+{
+	*(int *)indicator = 1;
+}
+
+/* Initialize timers */
+int fsl_otg_init_timers(struct otg_fsm *fsm)
+{
+	/* FSM used timers */
+	a_wait_vrise_tmr = otg_timer_initializer(&set_tmout, TA_WAIT_VRISE,
+						 (unsigned long)&fsm->
+						 a_wait_vrise_tmout);
+	if (a_wait_vrise_tmr == NULL)
+		return -ENOMEM;
+
+	a_wait_bcon_tmr =
+	    otg_timer_initializer(&set_tmout, TA_WAIT_BCON,
+				  (unsigned long)&fsm->a_wait_bcon_tmout);
+	if (a_wait_bcon_tmr == NULL)
+		return -ENOMEM;
+
+	a_aidl_bdis_tmr =
+	    otg_timer_initializer(&set_tmout, TA_AIDL_BDIS,
+				  (unsigned long)&fsm->a_aidl_bdis_tmout);
+	if (a_aidl_bdis_tmr == NULL)
+		return -ENOMEM;
+
+	b_ase0_brst_tmr =
+	    otg_timer_initializer(&set_tmout, TB_ASE0_BRST,
+				  (unsigned long)&fsm->b_ase0_brst_tmout);
+	if (b_ase0_brst_tmr == NULL)
+		return -ENOMEM;
+
+	b_se0_srp_tmr =
+	    otg_timer_initializer(&set_tmout, TB_SE0_SRP,
+				  (unsigned long)&fsm->b_se0_srp);
+	if (b_se0_srp_tmr == NULL)
+		return -ENOMEM;
+
+	b_srp_fail_tmr =
+	    otg_timer_initializer(&set_tmout, TB_SRP_FAIL,
+				  (unsigned long)&fsm->b_srp_done);
+	if (b_srp_fail_tmr == NULL)
+		return -ENOMEM;
+
+	a_wait_enum_tmr =
+	    otg_timer_initializer(&a_wait_enum, 10, (unsigned long)&fsm);
+	if (a_wait_enum_tmr == NULL)
+		return -ENOMEM;
+
+	/* device driver used timers */
+	b_srp_wait_tmr = otg_timer_initializer(&b_srp_end, TB_SRP_WAIT, 0);
+	if (b_srp_wait_tmr == NULL)
+		return -ENOMEM;
+
+	b_data_pulse_tmr = otg_timer_initializer(&b_data_pulse_end,
+						 TB_DATA_PLS, 0);
+	if (b_data_pulse_tmr == NULL)
+		return -ENOMEM;
+
+	b_vbus_pulse_tmr = otg_timer_initializer(&b_vbus_pulse_end,
+						 TB_VBUS_PLS, 0);
+	if (b_vbus_pulse_tmr == NULL)
+		return -ENOMEM;
+
+	return 0;
+}
+
+/* Uninitialize timers */
+void fsl_otg_uninit_timers(void)
+{
+	/* FSM used timers */
+	if (a_wait_vrise_tmr != NULL)
+		kfree(a_wait_vrise_tmr);
+	if (a_wait_bcon_tmr != NULL)
+		kfree(a_wait_bcon_tmr);
+	if (a_aidl_bdis_tmr != NULL)
+		kfree(a_aidl_bdis_tmr);
+	if (b_ase0_brst_tmr != NULL)
+		kfree(b_ase0_brst_tmr);
+	if (b_se0_srp_tmr != NULL)
+		kfree(b_se0_srp_tmr);
+	if (b_srp_fail_tmr != NULL)
+		kfree(b_srp_fail_tmr);
+	if (a_wait_enum_tmr != NULL)
+		kfree(a_wait_enum_tmr);
+
+	/* device driver used timers */
+	if (b_srp_wait_tmr != NULL)
+		kfree(b_srp_wait_tmr);
+	if (b_data_pulse_tmr != NULL)
+		kfree(b_data_pulse_tmr);
+	if (b_vbus_pulse_tmr != NULL)
+		kfree(b_vbus_pulse_tmr);
+}
+
+/* Add timer to timer list */
+void fsl_otg_add_timer(void *gtimer)
+{
+	struct fsl_otg_timer *timer = (struct fsl_otg_timer *)gtimer;
+	struct fsl_otg_timer *tmp_timer;
+
+	/* Check if the timer is already in the active list,
+	 * if so update timer count
+	 */
+	list_for_each_entry(tmp_timer, &active_timers, list)
+	    if (tmp_timer == timer) {
+		timer->count = timer->expires;
+		return;
+	}
+	timer->count = timer->expires;
+	list_add_tail(&timer->list, &active_timers);
+}
+
+/* Remove timer from the timer list; clear timeout status */
+void fsl_otg_del_timer(void *gtimer)
+{
+	struct fsl_otg_timer *timer = (struct fsl_otg_timer *)gtimer;
+	struct fsl_otg_timer *tmp_timer, *del_tmp;
+
+	list_for_each_entry_safe(tmp_timer, del_tmp, &active_timers, list)
+	    if (tmp_timer == timer)
+		list_del(&timer->list);
+}
+
+/* Reduce timer count by 1, and find timeout conditions.
+ * Called by fsl_otg 1ms timer interrupt
+ */
+int fsl_otg_tick_timer(void)
+{
+	struct fsl_otg_timer *tmp_timer, *del_tmp;
+	int expired = 0;
+
+	list_for_each_entry_safe(tmp_timer, del_tmp, &active_timers, list) {
+		tmp_timer->count--;
+		/* check if timer expires */
+		if (!tmp_timer->count) {
+			list_del(&tmp_timer->list);
+			tmp_timer->function(tmp_timer->data);
+			expired = 1;
+		}
+	}
+
+	return expired;
+}
+
+/* Reset controller, not reset the bus */
+void otg_reset_controller(void)
+{
+	u32 command;
+	unsigned long flags;
+
+	spin_lock_irqsave(&usb_dr_regs_lock, flags);
+	command = readl(&usb_dr_regs->usbcmd);
+	command |= UCMD_RESET;
+	writel(command, &usb_dr_regs->usbcmd);
+	spin_unlock_irqrestore(&usb_dr_regs_lock, flags);
+	while (readl(&usb_dr_regs->usbcmd) & UCMD_RESET)
+		continue;
+}
+
+/* Call suspend/resume routines in host driver */
+int fsl_otg_start_host(struct otg_fsm *fsm, int on)
+{
+	struct otg_transceiver *xceiv = fsm->transceiver;
+	struct device *dev;
+	struct fsl_otg *otg_dev = container_of(xceiv, struct fsl_otg, otg);
+	u32 retval = 0;
+	pm_message_t state = { 0 };
+
+	if (!xceiv->host)
+		return -ENODEV;
+
+	dev = xceiv->host->controller;
+
+	/* Update a_vbus_vld state as a_vbus_vld int is disabled
+	 * in device mode
+	 */
+	fsm->a_vbus_vld =
+	    (le32_to_cpu(usb_dr_regs->otgsc) & OTGSC_STS_A_VBUS_VALID) ? 1 : 0;
+	if (on) {
+		/* start fsl usb host controller */
+		if (otg_dev->host_working)
+			goto end;
+		else {
+			otg_reset_controller();
+			VDBG("host on......");
+			if (dev->driver->resume) {
+				retval = dev->driver->resume(dev);
+				if (fsm->id) {
+					/* default-b */
+					fsl_otg_drv_vbus(1);
+					/* Workaround: b_host can't driver
+					 * vbus, but PP in PORTSC needs to
+					 * be 1 for host to work.
+					 * So we set drv_vbus bit in
+					 * transceiver to 0 thru ULPI. */
+#if defined(CONFIG_ISP1504_MXC)
+					write_ulpi(0x0c, 0x20);
+#endif
+				}
+			}
+
+			otg_dev->host_working = 1;
+		}
+	} else {
+		/* stop fsl usb host controller */
+		if (!otg_dev->host_working)
+			goto end;
+		else {
+			VDBG("host off......");
+			if (dev && dev->driver) {
+				retval = dev->driver->suspend(dev, state);
+				if (fsm->id)
+					/* default-b */
+					fsl_otg_drv_vbus(0);
+			}
+			otg_dev->host_working = 0;
+		}
+	}
+      end:
+	return retval;
+}
+
+/* Call suspend and resume function in udc driver
+ * to stop and start udc driver.
+ */
+int fsl_otg_start_gadget(struct otg_fsm *fsm, int on)
+{
+	struct otg_transceiver *xceiv = fsm->transceiver;
+	struct device *udc_dev;
+	pm_message_t state = { 0 };
+
+	if (!xceiv->gadget || !xceiv->gadget->dev.parent)
+		return -ENODEV;
+
+	VDBG("gadget %s", on ? "on" : "off");
+	udc_dev = xceiv->gadget->dev.parent;
+
+	if (on)
+		udc_dev->driver->resume(udc_dev);
+	else
+		udc_dev->driver->suspend(udc_dev, state);
+
+	return 0;
+}
+
+/* Called by initialization code of host driver.  Register host controller
+ * to the OTG.  Suspend host for OTG role detection.
+ */
+static int fsl_otg_set_host(struct otg_transceiver *otg_p, struct usb_bus *host)
+{
+	struct fsl_otg *otg_dev = container_of(otg_p, struct fsl_otg, otg);
+	struct device *dev;
+	pm_message_t state = { 0 };
+
+	if (!otg_p || otg_dev != fsl_otg_dev)
+		return -ENODEV;
+
+	otg_p->host = host;
+
+	otg_dev->fsm.a_bus_drop = 0;
+	otg_dev->fsm.a_bus_req = 1;
+
+	if (host) {
+		VDBG("host off......\n");
+
+		otg_p->host->otg_port = fsl_otg_initdata.otg_port;
+		otg_p->host->is_b_host = otg_dev->fsm.id;
+		dev = host->controller;
+
+		if (dev && dev->driver)
+			dev->driver->suspend(dev, state);
+	} else {		/* host driver going away */
+
+		if (!(le32_to_cpu(otg_dev->dr_mem_map->otgsc) &
+		      OTGSC_STS_USB_ID)) {
+			/* Mini-A cable connected */
+			struct otg_fsm *fsm = &otg_dev->fsm;
+
+			otg_p->state = OTG_STATE_UNDEFINED;
+			fsm->protocol = PROTO_UNDEF;
+		}
+	}
+
+	otg_dev->host_working = 0;
+
+	otg_statemachine(&otg_dev->fsm);
+
+	return 0;
+}
+
+/* Called by initialization code of udc.  Register udc to OTG.*/
+static int fsl_otg_set_peripheral(struct otg_transceiver *otg_p,
+				  struct usb_gadget *gadget)
+{
+	struct fsl_otg *otg_dev = container_of(otg_p, struct fsl_otg, otg);
+
+	VDBG("otg_dev 0x%x", (int)otg_dev);
+	VDBG("fsl_otg_dev 0x%x", (int)fsl_otg_dev);
+
+	if (!otg_p || otg_dev != fsl_otg_dev)
+		return -ENODEV;
+
+	if (!gadget) {
+		if (!otg_dev->otg.default_a)
+			otg_p->gadget->ops->vbus_draw(otg_p->gadget, 0);
+		usb_gadget_vbus_disconnect(otg_dev->otg.gadget);
+		otg_dev->otg.gadget = 0;
+		otg_dev->fsm.b_bus_req = 0;
+		otg_statemachine(&otg_dev->fsm);
+		return 0;
+	}
+#ifdef DEBUG
+	/*
+	 * debug the initial state of the ID pin when only
+	 * the gadget driver is loaded and no cable is connected.
+	 * sometimes, we get an ID irq right
+	 * after the udc driver's otg_get_transceiver() call
+	 * that indicates that IDpin=0, which means a Mini-A
+	 * connector is attached.  not good.
+	 */
+	DBG("before: fsm.id ID pin=%d", otg_dev->fsm.id);
+	otg_dev->fsm.id = (otg_dev->dr_mem_map->otgsc & OTGSC_STS_USB_ID) ?
+	    1 : 0;
+	DBG("after:  fsm.id ID pin=%d", otg_dev->fsm.id);
+	/*if (!otg_dev->fsm.id) {
+	   printk("OTG Control = 0x%x\n",
+	   isp1504_read(ISP1504_OTGCTL,
+	   &otg_dev->dr_mem_map->ulpiview));
+	   } */
+#endif
+
+	otg_p->gadget = gadget;
+	otg_p->gadget->is_a_peripheral = !otg_dev->fsm.id;
+
+	otg_dev->fsm.b_bus_req = 1;
+
+	/* start the gadget right away if the ID pin says Mini-B */
+	DBG("ID pin=%d", otg_dev->fsm.id);
+	if (otg_dev->fsm.id == 1) {
+		fsl_otg_start_host(&otg_dev->fsm, 0);
+		otg_drv_vbus(&otg_dev->fsm, 0);
+		fsl_otg_start_gadget(&otg_dev->fsm, 1);
+	}
+
+	return 0;
+}
+
+/* Set OTG port power, only for B-device */
+static int fsl_otg_set_power(struct otg_transceiver *otg_p, unsigned mA)
+{
+	if (!fsl_otg_dev)
+		return -ENODEV;
+	if (otg_p->state == OTG_STATE_B_PERIPHERAL)
+		printk("FSL OTG:Draw %d mA\n", mA);
+
+	return 0;
+}
+
+/* Delayed pin detect interrupt processing.
+ *
+ * When the Mini-A cable is disconnected from the board,
+ * the pin-detect interrupt happens before the disconnnect
+ * interrupts for the connected device(s).  In order to
+ * process the disconnect interrupt(s) prior to switching
+ * roles, the pin-detect interrupts are delayed, and handled
+ * by this routine.
+ */
+static void fsl_otg_event(struct work_struct *work)
+{
+	struct fsl_otg *og = container_of(work, struct fsl_otg, otg_event.work);
+	struct otg_fsm *fsm = &og->fsm;
+
+	if (fsm->id) {		/* switch to gadget */
+		fsl_otg_start_host(fsm, 0);
+		otg_drv_vbus(fsm, 0);
+		fsl_otg_start_gadget(fsm, 1);
+	}
+}
+
+/* Interrupt handler.  OTG/host/peripheral share the same int line.
+ * OTG driver clears OTGSC interrupts and leaves USB interrupts
+ * intact.  It needs to have knowledge of some USB interrupts
+ * such as port change.
+ */
+irqreturn_t fsl_otg_isr(int irq, void *dev_id)
+{
+	struct otg_fsm *fsm = &((struct fsl_otg *)dev_id)->fsm;
+	struct otg_transceiver *otg = &((struct fsl_otg *)dev_id)->otg;
+	u32 otg_int_src, otg_sc;
+
+	otg_sc = le32_to_cpu(usb_dr_regs->otgsc);
+	otg_int_src = otg_sc & OTGSC_INTSTS_MASK & (otg_sc >> 8);
+
+	/* Only clear otg interrupts */
+	usb_dr_regs->otgsc |= cpu_to_le32(otg_sc & OTGSC_INTSTS_MASK);
+
+	/*FIXME: ID change not generate when init to 0 */
+	fsm->id = (otg_sc & OTGSC_STS_USB_ID) ? 1 : 0;
+	otg->default_a = (fsm->id == 0);
+
+	/* process OTG interrupts */
+	if (otg_int_src) {
+		if (otg_int_src & OTGSC_IS_USB_ID) {
+			fsm->id = (otg_sc & OTGSC_STS_USB_ID) ? 1 : 0;
+			otg->default_a = (fsm->id == 0);
+			if (otg->host)
+				otg->host->is_b_host = fsm->id;
+			if (otg->gadget)
+				otg->gadget->is_a_peripheral = !fsm->id;
+			VDBG("IRQ=ID now=%d", fsm->id);
+
+			if (fsm->id) {	/* switch to gadget */
+				schedule_delayed_work(&((struct fsl_otg *)
+							dev_id)->otg_event, 25);
+			} else {	/* switch to host */
+				cancel_delayed_work(&
+						    ((struct fsl_otg *)dev_id)->
+						    otg_event);
+				fsl_otg_start_gadget(fsm, 0);
+				otg_drv_vbus(fsm, 1);
+				fsl_otg_start_host(fsm, 1);
+			}
+
+			return IRQ_HANDLED;
+		}
+	}
+
+	return IRQ_NONE;
+}
+
+static struct otg_fsm_ops fsl_otg_ops = {
+	.chrg_vbus = fsl_otg_chrg_vbus,
+	.drv_vbus = fsl_otg_drv_vbus,
+	.loc_conn = fsl_otg_loc_conn,
+	.loc_sof = fsl_otg_loc_sof,
+	.start_pulse = fsl_otg_start_pulse,
+
+	.add_timer = fsl_otg_add_timer,
+	.del_timer = fsl_otg_del_timer,
+
+	.start_host = fsl_otg_start_host,
+	.start_gadget = fsl_otg_start_gadget,
+};
+
+/* Initialize the global variable fsl_otg_dev and request IRQ for OTG */
+static int fsl_otg_conf(struct platform_device *pdev)
+{
+	int status;
+	struct fsl_otg *fsl_otg_tc;
+	struct fsl_usb2_platform_data *pdata;
+
+	pdata = (struct fsl_usb2_platform_data *)pdev->dev.platform_data;
+
+	DBG();
+
+	if (fsl_otg_dev)
+		return 0;
+
+	/* allocate space to fsl otg device */
+	fsl_otg_tc = kmalloc(sizeof(struct fsl_otg), GFP_KERNEL);
+	if (!fsl_otg_tc)
+		return -ENODEV;
+
+	memset(fsl_otg_tc, 0, sizeof(struct fsl_otg));
+
+	fsl_otg_tc->dr_mem_map = pdata->regs;
+
+	DBG("set dr_mem_map to 0x%p", pdata->regs);
+	spin_lock_init(&usb_dr_regs_lock);
+
+	INIT_DELAYED_WORK(&fsl_otg_tc->otg_event, fsl_otg_event);
+
+	INIT_LIST_HEAD(&active_timers);
+	status = fsl_otg_init_timers(&fsl_otg_tc->fsm);
+	if (status) {
+		printk(KERN_INFO "Couldn't init OTG timers\n");
+		fsl_otg_uninit_timers();
+		kfree(fsl_otg_tc);
+		return status;
+	}
+
+	/* Set OTG state machine operations */
+	fsl_otg_tc->fsm.ops = &fsl_otg_ops;
+
+	/* record initial state of ID pin */
+	fsl_otg_tc->fsm.id = (fsl_otg_tc->dr_mem_map->otgsc & OTGSC_STS_USB_ID)
+	    ? 1 : 0;
+	DBG("initial ID pin=%d", fsl_otg_tc->fsm.id);
+
+	/* initialize the otg structure */
+	fsl_otg_tc->otg.label = DRIVER_DESC;
+	fsl_otg_tc->otg.set_host = fsl_otg_set_host;
+	fsl_otg_tc->otg.set_peripheral = fsl_otg_set_peripheral;
+	fsl_otg_tc->otg.set_power = fsl_otg_set_power;
+
+	fsl_otg_dev = fsl_otg_tc;
+
+	/* Store the otg transceiver */
+	status = otg_set_transceiver(&fsl_otg_tc->otg);
+	if (status) {
+		printk(KERN_WARNING ": unable to register OTG transceiver.\n");
+		return status;
+	}
+
+	return 0;
+}
+
+/* OTG Initialization*/
+int usb_otg_start(struct platform_device *pdev)
+{
+	struct fsl_otg *p_otg;
+	struct otg_transceiver *otg_trans = otg_get_transceiver();
+	struct otg_fsm *fsm;
+	int status;
+	u32 temp;
+	struct resource *res;
+	unsigned long flags;
+
+	DBG();
+
+	p_otg = container_of(otg_trans, struct fsl_otg, otg);
+	fsm = &p_otg->fsm;
+
+	/* Initialize the state machine structure with default values */
+	SET_OTG_STATE(otg_trans, OTG_STATE_UNDEFINED);
+	fsm->transceiver = &p_otg->otg;
+
+	usb_dr_regs = p_otg->dr_mem_map;
+	DBG("set usb_dr_regs to 0x%p", usb_dr_regs);
+
+	/* request irq */
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "Can't find irq resource.\n");
+		return -ENODEV;
+	}
+	p_otg->irq = res->start;
+	DBG("requesting irq %d", p_otg->irq);
+	status = request_irq(p_otg->irq, fsl_otg_isr, IRQF_SHARED, "fsl_arc",
+			     p_otg);
+	if (status) {
+		dev_dbg(p_otg->otg.dev, "can't get IRQ %d, error %d\n",
+			p_otg->irq, status);
+		kfree(p_otg);
+		return status;
+	}
+
+	/*
+	 * The ID input is FALSE when a Mini-A plug is inserted
+	 * in the Mini-AB receptacle. Otherwise, this input is TRUE.
+	 */
+	if (le32_to_cpu(p_otg->dr_mem_map->otgsc) & OTGSC_STS_USB_ID)
+		p_otg->otg.state = OTG_STATE_UNDEFINED;	/* not Mini-A */
+	else
+		p_otg->otg.state = OTG_STATE_A_IDLE;	/* Mini-A */
+
+	/* enable OTG interrupt */
+	spin_lock_irqsave(&usb_dr_regs_lock, flags);
+	temp = readl(&p_otg->dr_mem_map->otgsc);
+
+	temp &= ~OTGSC_INTERRUPT_ENABLE_BITS_MASK;
+	temp |= OTGSC_IE_USB_ID;
+	writel(temp, &p_otg->dr_mem_map->otgsc);
+	spin_unlock_irqrestore(&usb_dr_regs_lock, flags);
+
+	return 0;
+}
+
+static int board_init(struct platform_device *pdev)
+{
+	struct fsl_usb2_platform_data *pdata;
+	pdata = (struct fsl_usb2_platform_data *)pdev->dev.platform_data;
+
+	/*
+	 * do platform specific init: check the clock, grab/config pins, etc.
+	 */
+	if (pdata->platform_init(pdev) != 0)
+		return -EINVAL;
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------
+		PROC File System Support
+-------------------------------------------------------------------------*/
+#ifdef CONFIG_USB_OTG_DEBUG_FILES
+
+#include <linux/seq_file.h>
+
+static const char proc_filename[] = "driver/isp1504_otg";
+
+static int otg_proc_read(char *page, char **start, off_t off, int count,
+			 int *eof, void *_dev)
+{
+	struct otg_fsm *fsm = &fsl_otg_dev->fsm;
+	char *buf = page;
+	char *next = buf;
+	unsigned size = count;
+	unsigned long flags;
+	int t;
+	u32 tmp_reg;
+
+	if (off != 0)
+		return 0;
+
+	spin_lock_irqsave(&fsm->lock, flags);
+
+	/* ------basic driver infomation ---- */
+	t = scnprintf(next, size,
+		      DRIVER_DESC "\n" "isp1504_otg version: %s\n\n",
+		      DRIVER_VERSION);
+	size -= t;
+	next += t;
+
+	/* ------ Registers ----- */
+	tmp_reg = le32_to_cpu(usb_dr_regs->otgsc);
+	t = scnprintf(next, size, "OTGSC reg: %x\n", tmp_reg);
+	size -= t;
+	next += t;
+
+	tmp_reg = le32_to_cpu(usb_dr_regs->portsc);
+	t = scnprintf(next, size, "PORTSC reg: %x\n", tmp_reg);
+	size -= t;
+	next += t;
+
+	tmp_reg = le32_to_cpu(usb_dr_regs->usbmode);
+	t = scnprintf(next, size, "USBMODE reg: %x\n", tmp_reg);
+	size -= t;
+	next += t;
+
+	tmp_reg = le32_to_cpu(usb_dr_regs->usbcmd);
+	t = scnprintf(next, size, "USBCMD reg: %x\n", tmp_reg);
+	size -= t;
+	next += t;
+
+	tmp_reg = le32_to_cpu(usb_dr_regs->usbsts);
+	t = scnprintf(next, size, "USBSTS reg: %x\n", tmp_reg);
+	size -= t;
+	next += t;
+
+	/* ------ State ----- */
+	t = scnprintf(next, size,
+		      "OTG state: %s\n\n",
+		      state_string(fsl_otg_dev->otg.state));
+	size -= t;
+	next += t;
+
+#ifdef DEBUG
+	/* ------ State Machine Variables ----- */
+	t = scnprintf(next, size, "a_bus_req: %d\n", fsm->a_bus_req);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "b_bus_req: %d\n", fsm->b_bus_req);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "a_bus_resume: %d\n", fsm->a_bus_resume);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "a_bus_suspend: %d\n", fsm->a_bus_suspend);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "a_conn: %d\n", fsm->a_conn);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "a_sess_vld: %d\n", fsm->a_sess_vld);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "a_srp_det: %d\n", fsm->a_srp_det);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "a_vbus_vld: %d\n", fsm->a_vbus_vld);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "b_bus_resume: %d\n", fsm->b_bus_resume);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "b_bus_suspend: %d\n", fsm->b_bus_suspend);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "b_conn: %d\n", fsm->b_conn);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "b_se0_srp: %d\n", fsm->b_se0_srp);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "b_sess_end: %d\n", fsm->b_sess_end);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "b_sess_vld: %d\n", fsm->b_sess_vld);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "id: %d\n", fsm->id);
+	size -= t;
+	next += t;
+#endif
+
+	spin_unlock_irqrestore(&fsm->lock, flags);
+
+	*eof = 1;
+	return count - size;
+}
+
+#define create_proc_file()	create_proc_read_entry(proc_filename, \
+				0, NULL, otg_proc_read, NULL)
+
+#define remove_proc_file()	remove_proc_entry(proc_filename, NULL)
+
+#else				/* !CONFIG_USB_OTG_DEBUG_FILES */
+
+#define create_proc_file()	do {} while (0)
+#define remove_proc_file()	do {} while (0)
+
+#endif				/*CONFIG_USB_OTG_DEBUG_FILES */
+
+static int __init fsl_otg_probe(struct platform_device *pdev)
+{
+	int status;
+
+	DBG("pdev=0x%p", pdev);
+
+	if (!pdev)
+		return -ENODEV;
+
+	/* Initialize the clock, multiplexing pin and PHY interface */
+	board_init(pdev);
+
+	/* configure the OTG */
+	status = fsl_otg_conf(pdev);
+	if (status) {
+		printk(KERN_INFO "Couldn't init OTG module\n");
+		return -status;
+	}
+
+	/* start OTG */
+	status = usb_otg_start(pdev);
+
+	create_proc_file();
+	return status;
+}
+
+static int __exit fsl_otg_remove(struct platform_device *pdev)
+{
+	u32 ie;
+	struct fsl_usb2_platform_data *pdata;
+	unsigned long flags;
+
+	pdata = (struct fsl_usb2_platform_data *)pdev->dev.platform_data;
+
+	DBG("pdev=0x%p  pdata=0x%p", pdev, pdata);
+
+	otg_set_transceiver(NULL);
+
+	/* disable and clear OTGSC interrupts */
+	spin_lock_irqsave(&usb_dr_regs_lock, flags);
+	ie = readl(&usb_dr_regs->otgsc);
+	ie &= ~OTGSC_INTERRUPT_ENABLE_BITS_MASK;
+	ie |= OTGSC_INTERRUPT_STATUS_BITS_MASK;
+	writel(ie, &usb_dr_regs->otgsc);
+	spin_unlock_irqrestore(&usb_dr_regs_lock, flags);
+
+	free_irq(fsl_otg_dev->irq, fsl_otg_dev);
+
+	kfree(fsl_otg_dev);
+
+	remove_proc_file();
+
+	if (pdata->platform_uninit)
+		pdata->platform_uninit(pdata);
+
+	fsl_otg_dev = NULL;
+	return 0;
+}
+
+struct platform_driver fsl_otg_driver = {
+	.probe = fsl_otg_probe,
+	.remove = fsl_otg_remove,
+	.driver = {
+		   .name = "fsl_arc",
+		   .owner = THIS_MODULE,
+		   },
+};
+
+/*-------------------------------------------------------------------------*/
+
+static int __init fsl_usb_otg_init(void)
+{
+	printk(KERN_INFO "driver %s, %s\n", otg_dr_name, DRIVER_VERSION);
+	return platform_driver_register(&fsl_otg_driver);
+}
+
+static void __exit fsl_usb_otg_exit(void)
+{
+	platform_driver_unregister(&fsl_otg_driver);
+}
+
+module_init(fsl_usb_otg_init);
+module_exit(fsl_usb_otg_exit);
+
+MODULE_DESCRIPTION(DRIVER_INFO);
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_LICENSE("GPL");
Index: linux-2.6.18/drivers/usb/otg/fsl_otg.h
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/usb/otg/fsl_otg.h
@@ -0,0 +1,239 @@
+/*
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include "otg_fsm.h"
+#include <linux/usb/otg.h>
+
+ /* USB Command  Register Bit Masks */
+#define USB_CMD_RUN_STOP		(0x1<<0  )
+#define USB_CMD_CTRL_RESET		(0x1<<1  )
+#define USB_CMD_PERIODIC_SCHEDULE_EN	(0x1<<4  )
+#define USB_CMD_ASYNC_SCHEDULE_EN	(0x1<<5  )
+#define USB_CMD_INT_AA_DOORBELL		(0x1<<6  )
+#define USB_CMD_ASP			(0x3<<8  )
+#define USB_CMD_ASYNC_SCH_PARK_EN	(0x1<<11 )
+#define USB_CMD_SUTW			(0x1<<13 )
+#define USB_CMD_ATDTW			(0x1<<14 )
+#define USB_CMD_ITC			(0xFF<<16)
+
+/* bit 15,3,2 are frame list size */
+#define USB_CMD_FRAME_SIZE_1024		(0x0<<15 | 0x0<<2)
+#define USB_CMD_FRAME_SIZE_512		(0x0<<15 | 0x1<<2)
+#define USB_CMD_FRAME_SIZE_256		(0x0<<15 | 0x2<<2)
+#define USB_CMD_FRAME_SIZE_128		(0x0<<15 | 0x3<<2)
+#define USB_CMD_FRAME_SIZE_64		(0x1<<15 | 0x0<<2)
+#define USB_CMD_FRAME_SIZE_32		(0x1<<15 | 0x1<<2)
+#define USB_CMD_FRAME_SIZE_16		(0x1<<15 | 0x2<<2)
+#define USB_CMD_FRAME_SIZE_8		(0x1<<15 | 0x3<<2)
+
+/* bit 9-8 are async schedule park mode count */
+#define USB_CMD_ASP_00			(0x0<<8)
+#define USB_CMD_ASP_01			(0x1<<8)
+#define USB_CMD_ASP_10			(0x2<<8)
+#define USB_CMD_ASP_11			(0x3<<8)
+#define USB_CMD_ASP_BIT_POS		(8)
+
+/* bit 23-16 are interrupt threshold control */
+#define USB_CMD_ITC_NO_THRESHOLD	(0x00<<16)
+#define USB_CMD_ITC_1_MICRO_FRM		(0x01<<16)
+#define USB_CMD_ITC_2_MICRO_FRM		(0x02<<16)
+#define USB_CMD_ITC_4_MICRO_FRM		(0x04<<16)
+#define USB_CMD_ITC_8_MICRO_FRM		(0x08<<16)
+#define USB_CMD_ITC_16_MICRO_FRM	(0x10<<16)
+#define USB_CMD_ITC_32_MICRO_FRM	(0x20<<16)
+#define USB_CMD_ITC_64_MICRO_FRM	(0x40<<16)
+#define USB_CMD_ITC_BIT_POS		(16)
+
+/* USB Status Register Bit Masks */
+#define USB_STS_INT			(0x1<<0 )
+#define USB_STS_ERR			(0x1<<1 )
+#define USB_STS_PORT_CHANGE		(0x1<<2 )
+#define USB_STS_FRM_LST_ROLL		(0x1<<3 )
+#define USB_STS_SYS_ERR			(0x1<<4 )
+#define USB_STS_IAA			(0x1<<5 )
+#define USB_STS_RESET_RECEIVED		(0x1<<6 )
+#define USB_STS_SOF			(0x1<<7 )
+#define USB_STS_DCSUSPEND		(0x1<<8 )
+#define USB_STS_HC_HALTED		(0x1<<12)
+#define USB_STS_RCL			(0x1<<13)
+#define USB_STS_PERIODIC_SCHEDULE	(0x1<<14)
+#define USB_STS_ASYNC_SCHEDULE		(0x1<<15)
+
+/* USB Interrupt Enable Register Bit Masks */
+#define USB_INTR_INT_EN			(0x1<<0 )
+#define USB_INTR_ERR_INT_EN		(0x1<<1 )
+#define USB_INTR_PC_DETECT_EN		(0x1<<2 )
+#define USB_INTR_FRM_LST_ROLL_EN	(0x1<<3 )
+#define USB_INTR_SYS_ERR_EN		(0x1<<4 )
+#define USB_INTR_ASYN_ADV_EN		(0x1<<5 )
+#define USB_INTR_RESET_EN		(0x1<<6 )
+#define USB_INTR_SOF_EN			(0x1<<7 )
+#define USB_INTR_DEVICE_SUSPEND		(0x1<<8 )
+
+/* Device Address bit masks */
+#define USB_DEVICE_ADDRESS_MASK		(0x7F<<25)
+#define USB_DEVICE_ADDRESS_BIT_POS	(25)
+
+/* USB MODE Register Bit Masks */
+#define  USB_MODE_CTRL_MODE_IDLE	(0x0<<0)
+#define  USB_MODE_CTRL_MODE_DEVICE	(0x2<<0)
+#define  USB_MODE_CTRL_MODE_HOST	(0x3<<0)
+#define  USB_MODE_CTRL_MODE_RSV		(0x1<<0)
+#define  USB_MODE_SETUP_LOCK_OFF	(0x1<<3)
+#define  USB_MODE_STREAM_DISABLE	(0x1<<4)
+
+/*
+ *  A-DEVICE timing  constants
+ */
+
+/* Wait for VBUS Rise  */
+#define TA_WAIT_VRISE	(100)	/* a_wait_vrise 100 ms, section: 6.6.5.1 */
+
+/* Wait for B-Connect */
+#define TA_WAIT_BCON	(10000)	/* a_wait_bcon > 1 sec, section: 6.6.5.2
+				 * This is only used to get out of
+				 * OTG_STATE_A_WAIT_BCON state if there was
+				 * no connection for these many milliseconds
+				 */
+
+/* A-Idle to B-Disconnect */
+/* It is necessary for this timer to be more than 750 ms because of a bug in OPT
+ * test 5.4 in which B OPT disconnects after 750 ms instead of 75ms as stated
+ * in the test description
+ */
+#define TA_AIDL_BDIS	(5000)	/* a_suspend minimum 200 ms, section: 6.6.5.3 */
+
+/* B-Idle to A-Disconnect */
+#define TA_BIDL_ADIS	(12)	/* 3 to 200 ms */
+
+/* B-device timing constants */
+
+/* Data-Line Pulse Time*/
+#define TB_DATA_PLS	(10)	/* b_srp_init,continue 5~10ms, section:5.3.3 */
+#define TB_DATA_PLS_MIN	(5)	/* minimum 5 ms */
+#define TB_DATA_PLS_MAX	(10)	/* maximum 10 ms */
+
+/* SRP Initiate Time  */
+#define TB_SRP_INIT	(100)	/* b_srp_init,maximum 100 ms, section:5.3.8 */
+
+/* SRP Fail Time  */
+#define TB_SRP_FAIL	(7000)	/* b_srp_init,Fail time 5~30s, section:6.8.2.2 */
+
+/* SRP result wait time */
+#define TB_SRP_WAIT	(60)
+
+/* VBus time */
+#define TB_VBUS_PLS	(30)	/* time to keep vbus pulsing asserted */
+
+/* Discharge time */
+/* This time should be less than 10ms. It varies from system to system. */
+#define TB_VBUS_DSCHRG	(8)
+
+/* A-SE0 to B-Reset  */
+#define TB_ASE0_BRST	(20)	/* b_wait_acon, mini 3.125 ms,section:6.8.2.4 */
+
+/* A bus suspend timer before we can switch to b_wait_aconn */
+#define TB_A_SUSPEND	(7)
+#define TB_BUS_RESUME	(12)
+
+/* SE0 Time Before SRP */
+#define TB_SE0_SRP	(2)	/* b_idle,minimum 2 ms, section:5.3.2 */
+
+#define SET_OTG_STATE(otg_ptr, newstate)	((otg_ptr)->state=newstate)
+
+struct usb_dr_mmap {
+	/* Capability register */
+	u8 res1[256];
+	u16 caplength;		/* Capability Register Length */
+	u16 hciversion;		/* Host Controller Interface Version */
+	u32 hcsparams;		/* Host Controller Structual Parameters */
+	u32 hccparams;		/* Host Controller Capability Parameters */
+	u8 res2[20];
+	u32 dciversion;		/* Device Controller Interface Version */
+	u32 dccparams;		/* Device Controller Capability Parameters */
+	u8 res3[24];
+	/* Operation register */
+	u32 usbcmd;		/* USB Command Register */
+	u32 usbsts;		/* USB Status Register */
+	u32 usbintr;		/* USB Interrupt Enable Register */
+	u32 frindex;		/* Frame Index Register */
+	u8 res4[4];
+	u32 deviceaddr;		/* Device Address */
+	u32 endpointlistaddr;	/* Endpoint List Address Register */
+	u8 res5[4];
+	u32 burstsize;		/* Master Interface Data Burst Size Register */
+	u32 txttfilltuning;	/* Transmit FIFO Tuning Controls Register */
+	u8 res6[8];
+	u32 ulpiview;		/* ULPI register access */
+	u8 res7[12];
+	u32 configflag;		/* Configure Flag Register */
+	u32 portsc;		/* Port 1 Status and Control Register */
+	u8 res8[28];
+	u32 otgsc;		/* On-The-Go Status and Control */
+	u32 usbmode;		/* USB Mode Register */
+	u32 endptsetupstat;	/* Endpoint Setup Status Register */
+	u32 endpointprime;	/* Endpoint Initialization Register */
+	u32 endptflush;		/* Endpoint Flush Register */
+	u32 endptstatus;	/* Endpoint Status Register */
+	u32 endptcomplete;	/* Endpoint Complete Register */
+	u32 endptctrl[6];	/* Endpoint Control Registers */
+	u8 res9[552];
+	u32 snoop1;
+	u32 snoop2;
+	u32 age_cnt_thresh;	/* Age Count Threshold Register */
+	u32 pri_ctrl;		/* Priority Control Register */
+	u32 si_ctrl;		/* System Interface Control Register */
+	u8 res10[236];
+	u32 control;		/* General Purpose Control Register */
+};
+
+struct fsl_otg_timer {
+	unsigned long expires;	/* Number of count increase to timeout */
+	unsigned long count;	/* Tick counter */
+	void (*function) (unsigned long);	/* Timeout function */
+	unsigned long data;	/* Data passed to function */
+	struct list_head list;
+};
+
+struct fsl_otg_timer inline *otg_timer_initializer
+    (void (*function) (unsigned long), unsigned long expires,
+     unsigned long data) {
+	struct fsl_otg_timer *timer;
+	timer = kmalloc(sizeof(struct fsl_otg_timer), GFP_KERNEL);
+	if (timer == NULL)
+		return NULL;
+	timer->function = function;
+	timer->expires = expires;
+	timer->data = data;
+	return timer;
+}
+
+struct fsl_otg {
+	struct otg_transceiver otg;
+	struct otg_fsm fsm;
+	struct usb_dr_mmap *dr_mem_map;
+	struct delayed_work otg_event;
+
+	/*used for usb host */
+	u8 host_working;
+	u8 on_off;
+
+	int irq;
+};
+
+struct fsl_otg_config {
+	u8 otg_port;
+};
+
+extern const char *state_string(enum usb_otg_state state);
+extern int otg_set_resources(struct resource *resources, int num);
Index: linux-2.6.18/drivers/usb/otg/otg_fsm.c
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/usb/otg/otg_fsm.c
@@ -0,0 +1,394 @@
+/*
+ * Copyright 2006-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <asm/types.h>
+#include <linux/kernel.h>
+#include <linux/usb/otg.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/usb.h>
+#include <linux/usb_gadget.h>
+
+#include "otg_fsm.h"
+
+/* Defined by device specific driver, for different timer implementation */
+extern void *a_wait_vrise_tmr, *a_wait_bcon_tmr, *a_aidl_bdis_tmr,
+    *b_ase0_brst_tmr, *b_se0_srp_tmr, *b_srp_fail_tmr, *a_wait_enum_tmr;
+
+const char *state_string(enum usb_otg_state state)
+{
+	switch (state) {
+	case OTG_STATE_A_IDLE:
+		return "a_idle";
+	case OTG_STATE_A_WAIT_VRISE:
+		return "a_wait_vrise";
+	case OTG_STATE_A_WAIT_BCON:
+		return "a_wait_bcon";
+	case OTG_STATE_A_HOST:
+		return "a_host";
+	case OTG_STATE_A_SUSPEND:
+		return "a_suspend";
+	case OTG_STATE_A_PERIPHERAL:
+		return "a_peripheral";
+	case OTG_STATE_A_WAIT_VFALL:
+		return "a_wait_vfall";
+	case OTG_STATE_A_VBUS_ERR:
+		return "a_vbus_err";
+	case OTG_STATE_B_IDLE:
+		return "b_idle";
+	case OTG_STATE_B_SRP_INIT:
+		return "b_srp_init";
+	case OTG_STATE_B_PERIPHERAL:
+		return "b_peripheral";
+	case OTG_STATE_B_WAIT_ACON:
+		return "b_wait_acon";
+	case OTG_STATE_B_HOST:
+		return "b_host";
+	default:
+		return "UNDEFINED";
+	}
+}
+
+const char *protocol_string(int p)
+{
+	switch (p) {
+	case PROTO_HOST:
+		return "Host";
+	case PROTO_GADGET:
+		return "Peripheral";
+	default:
+		return "undef";
+	}
+}
+
+/* Change USB protocol when there is a protocol change */
+static int otg_set_protocol(struct otg_fsm *fsm, int protocol)
+{
+	int ret = 0;
+
+	if (fsm->protocol != protocol) {
+		VDBG("Change role from %s to %s",
+		     protocol_string(fsm->protocol), protocol_string(protocol));
+
+		/* stop old protocol */
+		if (fsm->protocol == PROTO_HOST)
+			ret = fsm->ops->start_host(fsm, 0);
+		else if (fsm->protocol == PROTO_GADGET)
+			ret = fsm->ops->start_gadget(fsm, 0);
+		if (ret)
+			return ret;
+
+		/* start new protocol */
+		if (protocol == PROTO_HOST)
+			ret = fsm->ops->start_host(fsm, 1);
+		else if (protocol == PROTO_GADGET)
+			ret = fsm->ops->start_gadget(fsm, 1);
+		if (ret)
+			return ret;
+
+		fsm->protocol = protocol;
+		return 0;
+	}
+
+	return 0;
+}
+
+static int state_changed = 0;
+
+/* Called when leaving a state.  Do state clean up jobs here */
+void otg_leave_state(struct otg_fsm *fsm, enum usb_otg_state old_state)
+{
+	switch (old_state) {
+	case OTG_STATE_B_IDLE:
+		otg_del_timer(fsm, b_se0_srp_tmr);
+		fsm->b_se0_srp = 0;
+		break;
+	case OTG_STATE_B_SRP_INIT:
+		fsm->b_srp_done = 0;
+		break;
+	case OTG_STATE_B_PERIPHERAL:
+		break;
+	case OTG_STATE_B_WAIT_ACON:
+		otg_del_timer(fsm, b_ase0_brst_tmr);
+		fsm->b_ase0_brst_tmout = 0;
+		break;
+	case OTG_STATE_B_HOST:
+		break;
+	case OTG_STATE_A_IDLE:
+		break;
+	case OTG_STATE_A_WAIT_VRISE:
+		otg_del_timer(fsm, a_wait_vrise_tmr);
+		fsm->a_wait_vrise_tmout = 0;
+		break;
+	case OTG_STATE_A_WAIT_BCON:
+		otg_del_timer(fsm, a_wait_bcon_tmr);
+		fsm->a_wait_bcon_tmout = 0;
+		break;
+	case OTG_STATE_A_HOST:
+		otg_del_timer(fsm, a_wait_enum_tmr);
+		break;
+	case OTG_STATE_A_SUSPEND:
+		otg_del_timer(fsm, a_aidl_bdis_tmr);
+		fsm->a_aidl_bdis_tmout = 0;
+		fsm->a_suspend_req = 0;
+		break;
+	case OTG_STATE_A_PERIPHERAL:
+		break;
+	case OTG_STATE_A_WAIT_VFALL:
+		otg_del_timer(fsm, a_wait_vrise_tmr);
+		break;
+	case OTG_STATE_A_VBUS_ERR:
+		break;
+	default:
+		break;
+	}
+}
+
+/* Called when entering a state */
+int otg_set_state(struct otg_fsm *fsm, enum usb_otg_state new_state)
+{
+	state_changed = 1;
+	if (fsm->transceiver->state == new_state)
+		return 0;
+
+	VDBG("chg state to %s", state_string(new_state));
+
+	otg_leave_state(fsm, fsm->transceiver->state);
+
+	switch (new_state) {
+	case OTG_STATE_B_IDLE:
+		otg_drv_vbus(fsm, 0);
+		otg_chrg_vbus(fsm, 0);
+		otg_loc_conn(fsm, 0);
+		otg_loc_sof(fsm, 0);
+		otg_set_protocol(fsm, PROTO_UNDEF);
+		otg_add_timer(fsm, b_se0_srp_tmr);
+		break;
+	case OTG_STATE_B_SRP_INIT:
+		otg_start_pulse(fsm);
+		otg_loc_sof(fsm, 0);
+		otg_set_protocol(fsm, PROTO_UNDEF);
+		otg_add_timer(fsm, b_srp_fail_tmr);
+		break;
+	case OTG_STATE_B_PERIPHERAL:
+		otg_chrg_vbus(fsm, 0);
+		otg_loc_conn(fsm, 1);
+		otg_loc_sof(fsm, 0);
+		otg_set_protocol(fsm, PROTO_GADGET);
+		break;
+	case OTG_STATE_B_WAIT_ACON:
+		otg_chrg_vbus(fsm, 0);
+		otg_loc_conn(fsm, 0);
+		otg_loc_sof(fsm, 0);
+		otg_set_protocol(fsm, PROTO_HOST);
+		otg_add_timer(fsm, b_ase0_brst_tmr);
+		fsm->a_bus_suspend = 0;
+		break;
+	case OTG_STATE_B_HOST:
+		otg_chrg_vbus(fsm, 0);
+		otg_loc_conn(fsm, 0);
+		otg_loc_sof(fsm, 1);
+		otg_set_protocol(fsm, PROTO_HOST);
+		usb_bus_start_enum(fsm->transceiver->host,
+				   fsm->transceiver->host->otg_port);
+		break;
+	case OTG_STATE_A_IDLE:
+		otg_drv_vbus(fsm, 0);
+		otg_chrg_vbus(fsm, 0);
+		otg_loc_conn(fsm, 0);
+		otg_loc_sof(fsm, 0);
+		otg_set_protocol(fsm, PROTO_HOST);
+		break;
+	case OTG_STATE_A_WAIT_VRISE:
+		otg_drv_vbus(fsm, 1);
+		otg_loc_conn(fsm, 0);
+		otg_loc_sof(fsm, 0);
+		otg_set_protocol(fsm, PROTO_HOST);
+		otg_add_timer(fsm, a_wait_vrise_tmr);
+		break;
+	case OTG_STATE_A_WAIT_BCON:
+		otg_drv_vbus(fsm, 1);
+		otg_loc_conn(fsm, 0);
+		otg_loc_sof(fsm, 0);
+		otg_set_protocol(fsm, PROTO_HOST);
+		otg_add_timer(fsm, a_wait_bcon_tmr);
+		break;
+	case OTG_STATE_A_HOST:
+		otg_drv_vbus(fsm, 1);
+		otg_loc_conn(fsm, 0);
+		otg_loc_sof(fsm, 1);
+		otg_set_protocol(fsm, PROTO_HOST);
+		/* When HNP is triggered while a_bus_req = 0, a_host will
+		 * suspend too fast to complete a_set_b_hnp_en
+		 */
+		if (!fsm->a_bus_req || fsm->a_suspend_req)
+			otg_add_timer(fsm, a_wait_enum_tmr);
+		break;
+	case OTG_STATE_A_SUSPEND:
+		otg_drv_vbus(fsm, 1);
+		otg_loc_conn(fsm, 0);
+		otg_loc_sof(fsm, 0);
+		otg_set_protocol(fsm, PROTO_HOST);
+		otg_add_timer(fsm, a_aidl_bdis_tmr);
+
+		break;
+	case OTG_STATE_A_PERIPHERAL:
+		otg_loc_conn(fsm, 1);
+		otg_loc_sof(fsm, 0);
+		otg_set_protocol(fsm, PROTO_GADGET);
+		otg_drv_vbus(fsm, 1);
+		break;
+	case OTG_STATE_A_WAIT_VFALL:
+		otg_drv_vbus(fsm, 0);
+		otg_loc_conn(fsm, 0);
+		otg_loc_sof(fsm, 0);
+		otg_set_protocol(fsm, PROTO_HOST);
+		break;
+	case OTG_STATE_A_VBUS_ERR:
+		otg_drv_vbus(fsm, 0);
+		otg_loc_conn(fsm, 0);
+		otg_loc_sof(fsm, 0);
+		otg_set_protocol(fsm, PROTO_UNDEF);
+		break;
+	default:
+		break;
+	}
+
+	fsm->transceiver->state = new_state;
+	return 0;
+}
+
+/* State change judgement */
+int otg_statemachine(struct otg_fsm *fsm)
+{
+	enum usb_otg_state state;
+	unsigned long flags;
+
+	spin_lock_irqsave(&fsm->lock, flags);
+
+	state = fsm->transceiver->state;
+	state_changed = 0;
+	/* State machine state change judgement */
+
+	VDBG("top: curr state=%s", state_string(state));
+
+	switch (state) {
+	case OTG_STATE_UNDEFINED:
+		VDBG("fsm->id = %d", fsm->id);
+		if (fsm->id)
+			otg_set_state(fsm, OTG_STATE_B_IDLE);
+		else
+			otg_set_state(fsm, OTG_STATE_A_IDLE);
+		break;
+	case OTG_STATE_B_IDLE:
+		VDBG("gadget: %p", fsm->transceiver->gadget);
+		if (!fsm->id)
+			otg_set_state(fsm, OTG_STATE_A_IDLE);
+		else if (fsm->b_sess_vld && fsm->transceiver->gadget)
+			otg_set_state(fsm, OTG_STATE_B_PERIPHERAL);
+		else if (fsm->b_bus_req && fsm->b_sess_end && fsm->b_se0_srp)
+			otg_set_state(fsm, OTG_STATE_B_SRP_INIT);
+		break;
+	case OTG_STATE_B_SRP_INIT:
+		if (!fsm->id || fsm->b_srp_done)
+			otg_set_state(fsm, OTG_STATE_B_IDLE);
+		break;
+	case OTG_STATE_B_PERIPHERAL:
+		if (!fsm->id || !fsm->b_sess_vld)
+			otg_set_state(fsm, OTG_STATE_B_IDLE);
+		else if (fsm->b_bus_req &&
+			 fsm->transceiver->gadget->b_hnp_enable &&
+			 fsm->a_bus_suspend)
+			otg_set_state(fsm, OTG_STATE_B_WAIT_ACON);
+		break;
+	case OTG_STATE_B_WAIT_ACON:
+		if (fsm->a_conn)
+			otg_set_state(fsm, OTG_STATE_B_HOST);
+		else if (!fsm->id || !fsm->b_sess_vld)
+			otg_set_state(fsm, OTG_STATE_B_IDLE);
+		else if (fsm->a_bus_resume || fsm->b_ase0_brst_tmout) {
+			fsm->b_ase0_brst_tmout = 0;
+			otg_set_state(fsm, OTG_STATE_B_PERIPHERAL);
+		}
+		break;
+	case OTG_STATE_B_HOST:
+		if (!fsm->id || !fsm->b_sess_vld)
+			otg_set_state(fsm, OTG_STATE_B_IDLE);
+		else if (!fsm->b_bus_req || !fsm->a_conn)
+			otg_set_state(fsm, OTG_STATE_B_PERIPHERAL);
+		break;
+	case OTG_STATE_A_IDLE:
+		if (fsm->id)
+			otg_set_state(fsm, OTG_STATE_B_IDLE);
+		else if (!fsm->a_bus_drop && (fsm->a_bus_req || fsm->a_srp_det))
+			otg_set_state(fsm, OTG_STATE_A_WAIT_VRISE);
+		break;
+	case OTG_STATE_A_WAIT_VRISE:
+		if (fsm->id || fsm->a_bus_drop || fsm->a_vbus_vld ||
+		    fsm->a_wait_vrise_tmout) {
+			otg_set_state(fsm, OTG_STATE_A_WAIT_BCON);
+		}
+		break;
+	case OTG_STATE_A_WAIT_BCON:
+		if (!fsm->a_vbus_vld)
+			otg_set_state(fsm, OTG_STATE_A_VBUS_ERR);
+		else if (fsm->b_conn)
+			otg_set_state(fsm, OTG_STATE_A_HOST);
+		else if (fsm->id | fsm->a_bus_drop | fsm->a_wait_bcon_tmout)
+			otg_set_state(fsm, OTG_STATE_A_WAIT_VFALL);
+		break;
+	case OTG_STATE_A_HOST:
+		if ((!fsm->a_bus_req || fsm->a_suspend_req) &&
+		    fsm->transceiver->host->b_hnp_enable)
+			otg_set_state(fsm, OTG_STATE_A_SUSPEND);
+		else if (fsm->id || !fsm->b_conn || fsm->a_bus_drop)
+			otg_set_state(fsm, OTG_STATE_A_WAIT_BCON);
+		else if (!fsm->a_vbus_vld)
+			otg_set_state(fsm, OTG_STATE_A_VBUS_ERR);
+		break;
+	case OTG_STATE_A_SUSPEND:
+		if (!fsm->b_conn && fsm->transceiver->host->b_hnp_enable)
+			otg_set_state(fsm, OTG_STATE_A_PERIPHERAL);
+		else if (!fsm->b_conn && !fsm->transceiver->host->b_hnp_enable)
+			otg_set_state(fsm, OTG_STATE_A_WAIT_BCON);
+		else if (fsm->a_bus_req || fsm->b_bus_resume)
+			otg_set_state(fsm, OTG_STATE_A_HOST);
+		else if (fsm->id || fsm->a_bus_drop || fsm->a_aidl_bdis_tmout)
+			otg_set_state(fsm, OTG_STATE_A_WAIT_VFALL);
+		else if (!fsm->a_vbus_vld)
+			otg_set_state(fsm, OTG_STATE_A_VBUS_ERR);
+		break;
+	case OTG_STATE_A_PERIPHERAL:
+		if (fsm->id || fsm->a_bus_drop)
+			otg_set_state(fsm, OTG_STATE_A_WAIT_VFALL);
+		else if (fsm->b_bus_suspend)
+			otg_set_state(fsm, OTG_STATE_A_WAIT_BCON);
+		else if (!fsm->a_vbus_vld)
+			otg_set_state(fsm, OTG_STATE_A_VBUS_ERR);
+		break;
+	case OTG_STATE_A_WAIT_VFALL:
+		if (fsm->id || fsm->a_bus_req ||
+		    (!fsm->a_sess_vld && !fsm->b_conn))
+			otg_set_state(fsm, OTG_STATE_A_IDLE);
+		break;
+	case OTG_STATE_A_VBUS_ERR:
+		if (fsm->id || fsm->a_bus_drop || fsm->a_clr_err)
+			otg_set_state(fsm, OTG_STATE_A_WAIT_VFALL);
+		break;
+	default:
+		break;
+	}
+	spin_unlock_irqrestore(&fsm->lock, flags);
+
+	return state_changed;
+}
Index: linux-2.6.18/drivers/usb/otg/otg_fsm.h
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/usb/otg/otg_fsm.h
@@ -0,0 +1,143 @@
+/*
+ * Copyright 2006-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifdef DEBUG
+
+#define DBG(fmt, args...) printk("j=%lu  [%s]  " fmt "\n", \
+		jiffies, __FUNCTION__, ## args)
+
+#else
+#define DBG(fmt, args...)	do{}while(0)
+#endif
+
+#ifdef VERBOSE
+#define VDBG		DBG
+#else
+#define VDBG(stuff...)	do{}while(0)
+#endif
+
+#ifdef VERBOSE
+#define MPC_LOC printk("Current Location [%s]:[%d]\n", __FILE__, __LINE__)
+#else
+#define MPC_LOC do{}while(0)
+#endif
+
+#define PROTO_UNDEF	(0)
+#define PROTO_HOST	(1)
+#define PROTO_GADGET	(2)
+
+/* OTG state machine according to the OTG spec */
+struct otg_fsm {
+	/* Input */
+	int a_bus_resume;
+	int a_bus_suspend;
+	int a_conn;
+	int a_sess_vld;
+	int a_srp_det;
+	int a_vbus_vld;
+	int b_bus_resume;
+	int b_bus_suspend;
+	int b_conn;
+	int b_se0_srp;
+	int b_sess_end;
+	int b_sess_vld;
+	int id;
+
+	/* Internal variables */
+	int a_set_b_hnp_en;
+	int b_srp_done;
+	int b_hnp_enable;
+
+	/* Timeout indicator for timers */
+	int a_wait_vrise_tmout;
+	int a_wait_bcon_tmout;
+	int a_aidl_bdis_tmout;
+	int b_ase0_brst_tmout;
+
+	/* Informative variables */
+	int a_bus_drop;
+	int a_bus_req;
+	int a_clr_err;
+	int a_suspend_req;
+	int b_bus_req;
+
+	/* Output */
+	int drv_vbus;
+	int loc_conn;
+	int loc_sof;
+
+	struct otg_fsm_ops *ops;
+	struct otg_transceiver *transceiver;
+
+	/* Current usb protocol used: 0:undefine; 1:host; 2:client */
+	int protocol;
+	spinlock_t lock;
+};
+
+struct otg_fsm_ops {
+	void (*chrg_vbus) (int on);
+	void (*drv_vbus) (int on);
+	void (*loc_conn) (int on);
+	void (*loc_sof) (int on);
+	void (*start_pulse) (void);
+	void (*add_timer) (void *timer);
+	void (*del_timer) (void *timer);
+	int (*start_host) (struct otg_fsm * fsm, int on);
+	int (*start_gadget) (struct otg_fsm * fsm, int on);
+};
+
+static inline void otg_chrg_vbus(struct otg_fsm *fsm, int on)
+{
+	fsm->ops->chrg_vbus(on);
+}
+
+static inline void otg_drv_vbus(struct otg_fsm *fsm, int on)
+{
+	if (fsm->drv_vbus != on) {
+		fsm->drv_vbus = on;
+		fsm->ops->drv_vbus(on);
+	}
+}
+
+static inline void otg_loc_conn(struct otg_fsm *fsm, int on)
+{
+	if (fsm->loc_conn != on) {
+		fsm->loc_conn = on;
+		fsm->ops->loc_conn(on);
+	}
+}
+
+static inline void otg_loc_sof(struct otg_fsm *fsm, int on)
+{
+	if (fsm->loc_sof != on) {
+		fsm->loc_sof = on;
+		fsm->ops->loc_sof(on);
+	}
+}
+
+static inline void otg_start_pulse(struct otg_fsm *fsm)
+{
+	fsm->ops->start_pulse();
+}
+
+static inline void otg_add_timer(struct otg_fsm *fsm, void *timer)
+{
+	fsm->ops->add_timer(timer);
+}
+
+static inline void otg_del_timer(struct otg_fsm *fsm, void *timer)
+{
+	fsm->ops->del_timer(timer);
+}
+
+int otg_statemachine(struct otg_fsm *fsm);
Index: linux-2.6.18/include/asm-arm/arch-mxc/arc_otg.h
===================================================================
--- linux-2.6.18.orig/include/asm-arm/arch-mxc/arc_otg.h
+++ linux-2.6.18/include/asm-arm/arch-mxc/arc_otg.h
@@ -1,4 +1,3 @@
-
 /*
  * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
@@ -14,44 +13,21 @@
 #ifndef __ASM_ARCH_MXC_ARC_OTG_H__
 #define __ASM_ARCH_MXC_ARC_OTG_H__
 
-struct arc_usb_config {
-	char *name;		/* pretty print */
-	int (*platform_init) (void);	/* platform-specific init routine */
-	void (*platform_uninit) (void);	/* platform-specific uninit routine */
-	void (*set_vbus_power) (int);	/* turn on/off Vbus power */
-	u32 xcvr_type;		/* PORTSC_PTS_* */
-	u32 usbmode;		/* address of usbmode register */
-	u32 does_otg;		/* set IFF it's an OTG port */
-	unsigned power_budget;	/* for hcd->power_budget */
-};
-
-struct arc_xcvr_config {
-	char *name;		/* pretty print */
-	int (*platform_init) (void);	/* platform-specific init routine */
-	void (*platform_uninit) (void);	/* platform-specific uninit routine */
-	void *regs;		/* register base */
-};
-
 #define USB_OTGREGS_BASE	(OTG_BASE_ADDR + 0x000)
 #define USB_H1REGS_BASE		(OTG_BASE_ADDR + 0x200)
 #define USB_H2REGS_BASE		(OTG_BASE_ADDR + 0x400)
 #define USB_OTHERREGS_BASE	(OTG_BASE_ADDR + 0x600)
 
-#define USB_REG32(base, offset) \
-		(*((volatile u32 *)(IO_ADDRESS(base + (offset)))))
-#define USB_REG16(base, offset) \
-		(*((volatile u16 *)(IO_ADDRESS(base + (offset)))))
+#define USBOTG_REG32(offset)	(*((volatile u32 *)(IO_ADDRESS(USB_OTGREGS_BASE + (offset)))))
+#define USBOTG_REG16(offset)	(*((volatile u16 *)(IO_ADDRESS(USB_OTGREGS_BASE + (offset)))))
 
-#define USBOTG_REG32(offset)	USB_REG32(USB_OTGREGS_BASE, (offset))
-#define USBOTG_REG16(offset)	USB_REG16(USB_OTGREGS_BASE, (offset))
+#define USBH1_REG32(offset)	(*((volatile u32 *)(IO_ADDRESS(USB_H1REGS_BASE + (offset)))))
+#define USBH1_REG16(offset)	(*((volatile u16 *)(IO_ADDRESS(USB_H1REGS_BASE + (offset)))))
 
-#define USBH1_REG32(offset)	USB_REG32(USB_H1REGS_BASE, (offset))
-#define USBH1_REG16(offset)	USB_REG16(USB_H1REGS_BASE, (offset))
+#define USBH2_REG32(offset)	(*((volatile u32 *)(IO_ADDRESS(USB_H2REGS_BASE + (offset)))))
+#define USBH2_REG16(offset)	(*((volatile u16 *)(IO_ADDRESS(USB_H2REGS_BASE + (offset)))))
 
-#define USBH2_REG32(offset)	USB_REG32(USB_H2REGS_BASE, (offset))
-#define USBH2_REG16(offset)	USB_REG16(USB_H2REGS_BASE, (offset))
-
-#define USBOTHER_REG(offset)	USB_REG32(USB_OTHERREGS_BASE, (offset))
+#define USBOTHER_REG(offset)	(*((volatile u32 *)(IO_ADDRESS(USB_OTHERREGS_BASE + (offset)))))
 
 /*
  * OTG registers
@@ -187,8 +163,8 @@ struct arc_xcvr_config {
 
 #define PORTSC_W1C_BITS                     \
        ( PORTSC_CONNECT_STATUS_CHANGE |     \
-	 PORTSC_PORT_EN_DIS_CHANGE    |     \
-	 PORTSC_OVER_CURRENT_CHG )
+         PORTSC_PORT_EN_DIS_CHANGE    |     \
+         PORTSC_OVER_CURRENT_CHG )
 
 /* UOG_OTGSC Register Bits */
 /* control bits: */
@@ -221,9 +197,28 @@ struct arc_xcvr_config {
 #define  OTGSC_IE_A_SESSION_VALID	(1 << 26)
 #define  OTGSC_IE_B_SESSION_VALID	(1 << 27)
 #define  OTGSC_IE_B_SESSION_END		(1 << 28)
-#define  OTGSC_IE_1ms_TIMER		(1 << 19)
+#define  OTGSC_IE_1ms_TIMER		(1 << 29)
 #define  OTGSC_IE_DATA_PULSE		(1 << 30)
 
+#if 1				/* FIXME these here for compatibility between my names and Leo's */
+/* OTG interrupt enable bit masks */
+#define  OTGSC_INTERRUPT_ENABLE_BITS_MASK	OTGSC_IE_MASK
+#define  OTGSC_INTSTS_MASK			OTGSC_IS_MASK
+
+/* OTG interrupt status bit masks */
+#define  OTGSC_INTERRUPT_STATUS_BITS_MASK	OTGSC_IS_MASK
+#endif
+
+/* x_USBMODE */
+#define USBMODE_SDIS		(1 << 4)	/* stream disable mode */
+#define USBMODE_SLOM		(1 << 3)	/* setup lockout mode */
+#define USBMODE_ES		(1 << 2)	/* (big) endian select */
+#define USBMODE_CM_MASK		(3 << 0)	/* controller mode mask */
+#define USBMODE_CM_HOST		(3 << 0)	/* host */
+#define USBMODE_CM_DEVICE	(2 << 0)	/* device */
+#define USBMODE_CM_reserved	(1 << 0)	/* reserved */
+#define USBMODE_CM_IDLE		(0 << 0)	/* idle */
+
 /* USBCTRL */
 #define UCTRL_OWIR		(1 << 31)	/* OTG wakeup intr request received */
 #define UCTRL_OSIC_MASK		(3 << 29)	/* OTG  Serial Interface Config: */
@@ -263,6 +258,7 @@ struct arc_xcvr_config {
 #define UCTRL_H2DT		(1 <<  5)	/* HOST2 TLL disabled */
 #define UCTRL_H1DT		(1 <<  4)	/* HOST1 TLL disabled */
 #define UCTRL_BPE		(1 <<  0)	/* bypass mode enable */
+#define UCTRL_OTD		(1 << 0)	/* OTG TLL Disable */
 
 /* USBCMD */
 #define UCMD_RESET		(1 << 1)	/* controller reset */
Index: linux-2.6.18/include/linux/usb/fsl_xcvr.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/linux/usb/fsl_xcvr.h
@@ -0,0 +1,24 @@
+#ifndef __LINUX_USB_FSL_XCVR_H
+#define __LINUX_USB_FSL_XCVR_H
+/**
+ * @name: transceiver name
+ * @xcvr_type: one of PORTSC_PTS_{UTMI,SERIAL,ULPI}
+ * @init: transceiver- and board-specific initialization function
+ * @uninit: transceiver- and board-specific uninitialization function
+ * @set_host:
+ * @set_device:
+ *
+ */
+struct fsl_xcvr_ops {
+	char *name;
+	u32 xcvr_type;
+
+	void (*init)(struct fsl_xcvr_ops *ops);
+	void (*uninit)(struct fsl_xcvr_ops *ops);
+	void (*set_host)(void);
+	void (*set_device)(void);
+	void (*set_vbus_power) (u32 *view, int on);
+	void (*set_remote_wakeup)(u32 *view);
+};
+
+#endif
Index: linux-2.6.18/include/linux/fsl_devices.h
===================================================================
--- linux-2.6.18.orig/include/linux/fsl_devices.h
+++ linux-2.6.18/include/linux/fsl_devices.h
@@ -102,6 +102,28 @@ struct fsl_usb2_platform_data {
 	enum fsl_usb2_operating_modes	operating_mode;
 	enum fsl_usb2_phy_modes		phy_mode;
 	unsigned int			port_enables;
+
+       /* DDD this could arguably be moved to a separate
+	* fsl usb2 device header file
+	*/
+       char *name;	     /* pretty print */
+       int (*platform_init) (struct platform_device *);
+       void (*platform_uninit) (struct fsl_usb2_platform_data *);
+       int (*platform_verify) (struct platform_device *);
+       u32 xcvr_type;	  /* PORTSC_PTS_* */
+       char *transceiver;      /* transceiver name */
+       // DDD combine usbmode and view into 1 register-base variable
+       u32 usbmode;	    /* address of usbmode register */
+       u32 viewport;	   /* address of ulpiview register */
+       u32 r_start;	    /* start of MEM resource */
+       u32 r_len;	      /* length of MEM resource */
+       void __iomem *regs;     /* ioremap'd register base */
+       int does_otg;
+       unsigned power_budget;  /* for hcd->power_budget */
+       struct fsl_xcvr_ops *xcvr_ops;
+       int (*gpio_usb_active) (void);
+       void (*gpio_usb_inactive) (void);
+
 };
 
 /* Flags in fsl_usb2_mph_platform_data */
Index: linux-2.6.18/include/linux/usb/otg.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/linux/usb/otg.h
@@ -0,0 +1,131 @@
+// include/linux/usb/otg.h
+
+/*
+ * These APIs may be used between USB controllers.  USB device drivers
+ * (for either host or peripheral roles) don't use these calls; they
+ * continue to use just usb_device and usb_gadget.
+ */
+
+
+/* OTG defines lots of enumeration states before device reset */
+enum usb_otg_state {
+	OTG_STATE_UNDEFINED = 0,
+
+	/* single-role peripheral, and dual-role default-b */
+	OTG_STATE_B_IDLE,
+	OTG_STATE_B_SRP_INIT,
+	OTG_STATE_B_PERIPHERAL,
+
+	/* extra dual-role default-b states */
+	OTG_STATE_B_WAIT_ACON,
+	OTG_STATE_B_HOST,
+
+	/* dual-role default-a */
+	OTG_STATE_A_IDLE,
+	OTG_STATE_A_WAIT_VRISE,
+	OTG_STATE_A_WAIT_BCON,
+	OTG_STATE_A_HOST,
+	OTG_STATE_A_SUSPEND,
+	OTG_STATE_A_PERIPHERAL,
+	OTG_STATE_A_WAIT_VFALL,
+	OTG_STATE_A_VBUS_ERR,
+};
+
+/*
+ * the otg driver needs to interact with both device side and host side
+ * usb controllers.  it decides which controller is active at a given
+ * moment, using the transceiver, ID signal, HNP and sometimes static
+ * configuration information (including "board isn't wired for otg").
+ */
+struct otg_transceiver {
+	struct device		*dev;
+	const char		*label;
+
+	u8			default_a;
+	enum usb_otg_state	state;
+
+	struct usb_bus		*host;
+	struct usb_gadget	*gadget;
+
+	/* to pass extra port status to the root hub */
+	u16			port_status;
+	u16			port_change;
+
+	/* bind/unbind the host controller */
+	int	(*set_host)(struct otg_transceiver *otg,
+				struct usb_bus *host);
+
+	/* bind/unbind the peripheral controller */
+	int	(*set_peripheral)(struct otg_transceiver *otg,
+				struct usb_gadget *gadget);
+
+	/* effective for B devices, ignored for A-peripheral */
+	int	(*set_power)(struct otg_transceiver *otg,
+				unsigned mA);
+
+	/* for non-OTG B devices: set transceiver into suspend mode */
+	int	(*set_suspend)(struct otg_transceiver *otg,
+				int suspend);
+
+	/* for B devices only:  start session with A-Host */
+	int	(*start_srp)(struct otg_transceiver *otg);
+
+	/* start or continue HNP role switch */
+	int	(*start_hnp)(struct otg_transceiver *otg);
+
+};
+
+
+/* for board-specific init logic */
+extern int otg_set_transceiver(struct otg_transceiver *);
+
+
+/* for usb host and peripheral controller drivers */
+extern struct otg_transceiver *otg_get_transceiver(void);
+
+static inline int
+otg_start_hnp(struct otg_transceiver *otg)
+{
+	return otg->start_hnp(otg);
+}
+
+
+/* for HCDs */
+static inline int
+otg_set_host(struct otg_transceiver *otg, struct usb_bus *host)
+{
+	return otg->set_host(otg, host);
+}
+
+
+/* for usb peripheral controller drivers */
+static inline int
+otg_set_peripheral(struct otg_transceiver *otg, struct usb_gadget *periph)
+{
+	return otg->set_peripheral(otg, periph);
+}
+
+static inline int
+otg_set_power(struct otg_transceiver *otg, unsigned mA)
+{
+	return otg->set_power(otg, mA);
+}
+
+static inline int
+otg_set_suspend(struct otg_transceiver *otg, int suspend)
+{
+	if (otg->set_suspend != NULL)
+		return otg->set_suspend(otg, suspend);
+	else
+		return 0;
+}
+
+static inline int
+otg_start_srp(struct otg_transceiver *otg)
+{
+	return otg->start_srp(otg);
+}
+
+
+/* for OTG controller drivers (and maybe other stuff) */
+extern int usb_bus_start_enum(struct usb_bus *bus, unsigned port_num);
Index: linux-2.6.18/include/asm-arm/arch-mxc/fsl_usb.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/asm-arm/arch-mxc/fsl_usb.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <asm/arch/arc_otg.h>
+
+/* ehci_arc_hc_driver.flags value */
+#define FSL_PLATFORM_HC_FLAGS (HCD_USB2 | HCD_MEMORY)
+
+static inline int fsl_platform_verify(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static inline void fsl_platform_usb_setup(struct usb_hcd *hcd)
+{
+}
+
+static inline void fsl_platform_set_host_mode(struct usb_hcd *hcd)
+{
+	unsigned int temp;
+	struct fsl_usb2_platform_data *pdata;
+
+	pdata =
+	    (struct fsl_usb2_platform_data *)hcd->self.controller->
+	    platform_data;
+
+	if (pdata->xcvr_ops && pdata->xcvr_ops->set_host)
+		pdata->xcvr_ops->set_host();
+
+	/* set host mode */
+	temp = readl(hcd->regs + 0x1a8);
+	writel(temp | USBMODE_CM_HOST, hcd->regs + 0x1a8);
+}
Index: linux-2.6.18/arch/arm/mach-mx2/mx27ads_gpio.c
===================================================================
--- linux-2.6.18.orig/arch/arm/mach-mx2/mx27ads_gpio.c
+++ linux-2.6.18/arch/arm/mach-mx2/mx27ads_gpio.c
@@ -19,10 +19,7 @@
 #include <asm/arch/gpio.h>
 
 #include "gpio_mux.h"
-
-#define SYS_FMCR	(IO_ADDRESS(SYSCTRL_BASE_ADDR) + 0x14)
-#define SYS_FMCR_NF_16BIT_SEL_OFFSET	4
-#define SYS_FMCR_NF_16BIT_SEL_MASK	(1 << 4)
+#define SYS_FMCR                0x14    /*  Functional Muxing Control Reg */
 
 static int g_uart_activated[MXC_UART_NR] = { 0, 0, 0, 0, 0, 0 };
 
@@ -190,16 +187,21 @@ EXPORT_SYMBOL(config_uartdma_event);
  *	PB25 - PB31  -- PRIMARY
  *	PB22  -- PRIMARY
  */
-void gpio_usbh1_active(void)
+int gpio_usbh1_active(void)
 {
-	gpio_request_mux(MX27_PIN_USBH1_SUSP, GPIO_MUX_PRIMARY);
-	gpio_request_mux(MX27_PIN_USBH1_RCV, GPIO_MUX_PRIMARY);
-	gpio_request_mux(MX27_PIN_USBH1_FS, GPIO_MUX_PRIMARY);
-	gpio_request_mux(MX27_PIN_USBH1_OE_B, GPIO_MUX_PRIMARY);
-	gpio_request_mux(MX27_PIN_USBH1_TXDM, GPIO_MUX_PRIMARY);
-	gpio_request_mux(MX27_PIN_USBH1_TXDP, GPIO_MUX_PRIMARY);
-	gpio_request_mux(MX27_PIN_USBH1_RXDM, GPIO_MUX_PRIMARY);
-	gpio_request_mux(MX27_PIN_USBH1_RXDP, GPIO_MUX_PRIMARY);
+	if (gpio_request_mux(MX27_PIN_USBH1_SUSP, GPIO_MUX_PRIMARY) ||
+	    gpio_request_mux(MX27_PIN_USBH1_RCV, GPIO_MUX_PRIMARY) ||
+	    gpio_request_mux(MX27_PIN_USBH1_FS, GPIO_MUX_PRIMARY) ||
+	    gpio_request_mux(MX27_PIN_USBH1_OE_B, GPIO_MUX_PRIMARY) ||
+	    gpio_request_mux(MX27_PIN_USBH1_TXDM, GPIO_MUX_PRIMARY) ||
+	    gpio_request_mux(MX27_PIN_USBH1_TXDP, GPIO_MUX_PRIMARY) ||
+	    gpio_request_mux(MX27_PIN_USBH1_RXDM, GPIO_MUX_PRIMARY) ||
+	    gpio_request_mux(MX27_PIN_USBH1_RXDP, GPIO_MUX_PRIMARY))
+	        return -EINVAL;
+
+	__raw_writew(PBC_BCTRL3_FSH_MOD, PBC_BCTRL3_CLEAR_REG);
+	__raw_writew(PBC_BCTRL3_FSH_VBUS_EN, PBC_BCTRL3_CLEAR_REG);
+	return 0;
 }
 EXPORT_SYMBOL(gpio_usbh1_active);
 void gpio_usbh1_inactive(void)
@@ -212,40 +214,45 @@ void gpio_usbh1_inactive(void)
 	gpio_free_mux(MX27_PIN_USBH1_TXDP);
 	gpio_free_mux(MX27_PIN_USBH1_RXDM);
 	gpio_free_mux(MX27_PIN_USBH1_RXDP);
+	__raw_writew(PBC_BCTRL3_FSH_VBUS_EN, PBC_BCTRL3_SET_REG);
 }
 EXPORT_SYMBOL(gpio_usbh1_inactive);
 
 /*
  * conflicts with CSPI1 (MC13783) and CSPI2 (Connector)
  */
-void gpio_usbh2_active(void)
+int gpio_usbh2_active(void)
 {
-	gpio_set_puen(MX27_PIN_USBH2_CLK, 0);
-	gpio_set_puen(MX27_PIN_USBH2_DIR, 0);
-	gpio_set_puen(MX27_PIN_USBH2_DATA7, 0);
-	gpio_set_puen(MX27_PIN_USBH2_NXT, 0);
-	gpio_set_puen(MX27_PIN_USBH2_STP, 0);
-	gpio_set_puen(MX27_PIN_CSPI2_SS2, 0);
-	gpio_set_puen(MX27_PIN_CSPI2_SS1, 0);
-	gpio_set_puen(MX27_PIN_CSPI2_SS0, 0);
-	gpio_set_puen(MX27_PIN_CSPI2_SCLK, 0);
-	gpio_set_puen(MX27_PIN_CSPI2_MISO, 0);
-	gpio_set_puen(MX27_PIN_CSPI2_MOSI, 0);
-	gpio_set_puen(MX27_PIN_CSPI1_SS2, 0);
-
-	gpio_request_mux(MX27_PIN_USBH2_CLK, GPIO_MUX_PRIMARY);
-	gpio_request_mux(MX27_PIN_USBH2_DIR, GPIO_MUX_PRIMARY);
-	gpio_request_mux(MX27_PIN_USBH2_DATA7, GPIO_MUX_PRIMARY);
-	gpio_request_mux(MX27_PIN_USBH2_NXT, GPIO_MUX_PRIMARY);
-	gpio_request_mux(MX27_PIN_USBH2_STP, GPIO_MUX_PRIMARY);
-
-	gpio_request_mux(MX27_PIN_CSPI2_SS2, GPIO_MUX_ALT);
-	gpio_request_mux(MX27_PIN_CSPI2_SS1, GPIO_MUX_ALT);
-	gpio_request_mux(MX27_PIN_CSPI2_SS0, GPIO_MUX_ALT);
-	gpio_request_mux(MX27_PIN_CSPI2_SCLK, GPIO_MUX_ALT);
-	gpio_request_mux(MX27_PIN_CSPI2_MISO, GPIO_MUX_ALT);
-	gpio_request_mux(MX27_PIN_CSPI2_MOSI, GPIO_MUX_ALT);
-	gpio_request_mux(MX27_PIN_CSPI1_SS2, GPIO_MUX_ALT);
+       if (gpio_set_puen(MX27_PIN_USBH2_CLK, 0) ||
+           gpio_set_puen(MX27_PIN_USBH2_DIR, 0) ||
+           gpio_set_puen(MX27_PIN_USBH2_DATA7, 0) ||
+           gpio_set_puen(MX27_PIN_USBH2_NXT, 0) ||
+           gpio_set_puen(MX27_PIN_USBH2_STP, 0) ||
+           gpio_set_puen(MX27_PIN_CSPI2_SS2, 0) ||
+           gpio_set_puen(MX27_PIN_CSPI2_SS1, 0) ||
+           gpio_set_puen(MX27_PIN_CSPI2_SS0, 0) ||
+           gpio_set_puen(MX27_PIN_CSPI2_SCLK, 0) ||
+           gpio_set_puen(MX27_PIN_CSPI2_MISO, 0) ||
+           gpio_set_puen(MX27_PIN_CSPI2_MOSI, 0) ||
+           gpio_set_puen(MX27_PIN_CSPI1_SS2, 0))
+               return -EINVAL;
+
+       if (gpio_request_mux(MX27_PIN_USBH2_CLK, GPIO_MUX_PRIMARY) ||
+           gpio_request_mux(MX27_PIN_USBH2_DIR, GPIO_MUX_PRIMARY) ||
+           gpio_request_mux(MX27_PIN_USBH2_DATA7, GPIO_MUX_PRIMARY) ||
+           gpio_request_mux(MX27_PIN_USBH2_NXT, GPIO_MUX_PRIMARY) ||
+           gpio_request_mux(MX27_PIN_USBH2_STP, GPIO_MUX_PRIMARY) ||
+           gpio_request_mux(MX27_PIN_CSPI2_SS2, GPIO_MUX_ALT) ||
+           gpio_request_mux(MX27_PIN_CSPI2_SS1, GPIO_MUX_ALT) ||
+           gpio_request_mux(MX27_PIN_CSPI2_SS0, GPIO_MUX_ALT) ||
+           gpio_request_mux(MX27_PIN_CSPI2_SCLK, GPIO_MUX_ALT) ||
+           gpio_request_mux(MX27_PIN_CSPI2_MISO, GPIO_MUX_ALT) ||
+           gpio_request_mux(MX27_PIN_CSPI2_MOSI, GPIO_MUX_ALT) ||
+           gpio_request_mux(MX27_PIN_CSPI1_SS2, GPIO_MUX_ALT))
+               return -EINVAL;
+
+       __raw_writew(PBC_BCTRL3_HSH_EN, PBC_BCTRL3_CLEAR_REG);
+       return 0;
 }
 EXPORT_SYMBOL(gpio_usbh2_active);
 void gpio_usbh2_inactive(void)
@@ -276,27 +283,33 @@ void gpio_usbh2_inactive(void)
 	gpio_set_puen(MX27_PIN_CSPI2_MISO, 1);
 	gpio_set_puen(MX27_PIN_CSPI2_MOSI, 1);
 	gpio_set_puen(MX27_PIN_CSPI1_SS2, 1);
+	__raw_writew(PBC_BCTRL3_HSH_EN, PBC_BCTRL3_SET_REG);
 }
 EXPORT_SYMBOL(gpio_usbh2_inactive);
 
-void gpio_usbotg_hs_active(void)
+int gpio_usbotg_hs_active(void)
 {
-	gpio_request_mux(MX27_PIN_USBOTG_DATA5, GPIO_MUX_PRIMARY);
-	gpio_request_mux(MX27_PIN_USBOTG_DATA6, GPIO_MUX_PRIMARY);
-	gpio_request_mux(MX27_PIN_USBOTG_DATA0, GPIO_MUX_PRIMARY);
-	gpio_request_mux(MX27_PIN_USBOTG_DATA2, GPIO_MUX_PRIMARY);
-	gpio_request_mux(MX27_PIN_USBOTG_DATA1, GPIO_MUX_PRIMARY);
-	gpio_request_mux(MX27_PIN_USBOTG_DATA3, GPIO_MUX_PRIMARY);
-	gpio_request_mux(MX27_PIN_USBOTG_DATA4, GPIO_MUX_PRIMARY);
-
-	gpio_request_mux(MX27_PIN_USBOTG_DIR, GPIO_MUX_PRIMARY);
-	gpio_request_mux(MX27_PIN_USBOTG_STP, GPIO_MUX_PRIMARY);
-	gpio_request_mux(MX27_PIN_USBOTG_NXT, GPIO_MUX_PRIMARY);
-	gpio_request_mux(MX27_PIN_USBOTG_CLK, GPIO_MUX_PRIMARY);
-	gpio_request_mux(MX27_PIN_USBOTG_DATA7, GPIO_MUX_PRIMARY);
-
-	gpio_request_mux(MX27_PIN_USB_OC_B, GPIO_MUX_PRIMARY);
-	gpio_request_mux(MX27_PIN_USB_PWR, GPIO_MUX_PRIMARY);
+       if (gpio_request_mux(MX27_PIN_USBOTG_DATA5, GPIO_MUX_PRIMARY) ||
+           gpio_request_mux(MX27_PIN_USBOTG_DATA6, GPIO_MUX_PRIMARY) ||
+           gpio_request_mux(MX27_PIN_USBOTG_DATA0, GPIO_MUX_PRIMARY) ||
+           gpio_request_mux(MX27_PIN_USBOTG_DATA2, GPIO_MUX_PRIMARY) ||
+           gpio_request_mux(MX27_PIN_USBOTG_DATA1, GPIO_MUX_PRIMARY) ||
+           gpio_request_mux(MX27_PIN_USBOTG_DATA3, GPIO_MUX_PRIMARY) ||
+           gpio_request_mux(MX27_PIN_USBOTG_DATA4, GPIO_MUX_PRIMARY) ||
+
+           gpio_request_mux(MX27_PIN_USBOTG_DIR, GPIO_MUX_PRIMARY) ||
+           gpio_request_mux(MX27_PIN_USBOTG_STP, GPIO_MUX_PRIMARY) ||
+           gpio_request_mux(MX27_PIN_USBOTG_NXT, GPIO_MUX_PRIMARY) ||
+           gpio_request_mux(MX27_PIN_USBOTG_CLK, GPIO_MUX_PRIMARY) ||
+           gpio_request_mux(MX27_PIN_USBOTG_DATA7, GPIO_MUX_PRIMARY) ||
+
+           gpio_request_mux(MX27_PIN_USB_OC_B, GPIO_MUX_PRIMARY) ||
+           gpio_request_mux(MX27_PIN_USB_PWR, GPIO_MUX_PRIMARY))
+               return -EINVAL;
+
+       __raw_writew(PBC_BCTRL3_OTG_HS_EN, PBC_BCTRL3_CLEAR_REG);
+       __raw_writew(PBC_BCTRL3_OTG_VBUS_EN, PBC_BCTRL3_CLEAR_REG);
+       return 0;
 }
 EXPORT_SYMBOL(gpio_usbotg_hs_active);
 
@@ -318,10 +331,11 @@ void gpio_usbotg_hs_inactive(void)
 
 	gpio_free_mux(MX27_PIN_USB_OC_B);
 	gpio_free_mux(MX27_PIN_USB_PWR);
+	__raw_writew(PBC_BCTRL3_OTG_HS_EN, PBC_BCTRL3_SET_REG);
 }
 EXPORT_SYMBOL(gpio_usbotg_hs_inactive);
 
-void gpio_usbotg_fs_active(void)
+int gpio_usbotg_fs_active(void)
 {
 	return gpio_usbotg_hs_active();
 }
@@ -329,7 +343,7 @@ EXPORT_SYMBOL(gpio_usbotg_fs_active);
 
 void gpio_usbotg_fs_inactive(void)
 {
-	return gpio_usbotg_hs_inactive();
+	gpio_usbotg_hs_inactive();
 }
 EXPORT_SYMBOL(gpio_usbotg_fs_inactive);
 
@@ -477,9 +491,9 @@ EXPORT_SYMBOL(gpio_spi_inactive);
 void gpio_nand_active(void)
 {
 	unsigned long reg;
-	reg = __raw_readl(SYS_FMCR);
-	reg &= ~SYS_FMCR_NF_16BIT_SEL_MASK;
-	__raw_writel(reg, SYS_FMCR);
+	reg = __raw_readl(IO_ADDRESS(SYSCTRL_BASE_ADDR) + SYS_FMCR);
+	reg &= ~(1 << 4);
+	__raw_writel(reg, IO_ADDRESS(SYSCTRL_BASE_ADDR) + SYS_FMCR);
 
 	gpio_request_mux(MX27_PIN_NFRB, GPIO_MUX_PRIMARY);
 	gpio_request_mux(MX27_PIN_NFCE_B, GPIO_MUX_PRIMARY);
@@ -746,6 +760,10 @@ void gpio_ata_active(void)
 	gpio_request_mux(MX27_PIN_IOIS16, GPIO_MUX_ALT);
 	gpio_request_mux(MX27_PIN_PC_RW_B, GPIO_MUX_ALT);
 	gpio_request_mux(MX27_PIN_PC_POE, GPIO_MUX_ALT);
+
+	__raw_writew(PBC_BCTRL2_ATAFEC_EN | PBC_BCTRL2_ATAFEC_SEL |
+	             PBC_BCTRL2_ATA_EN, PBC_BCTRL2_CLEAR_REG);
+
 }
 EXPORT_SYMBOL(gpio_ata_active);
 
@@ -755,6 +773,9 @@ EXPORT_SYMBOL(gpio_ata_active);
  */
 void gpio_ata_inactive(void)
 {
+	__raw_writew(PBC_BCTRL2_ATAFEC_EN | PBC_BCTRL2_ATAFEC_SEL |
+	             PBC_BCTRL2_ATA_EN, PBC_BCTRL2_SET_REG);
+
 	gpio_free_mux(MX27_PIN_ATA_DATA0);
 	gpio_free_mux(MX27_PIN_ATA_DATA1);
 	gpio_free_mux(MX27_PIN_ATA_DATA2);
Index: linux-2.6.18/mvl_patches/pro50-0977.c
===================================================================
--- /dev/null
+++ linux-2.6.18/mvl_patches/pro50-0977.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2008 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(977);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

