#! /usr/bin/env bash
# Patch: -pro_powerpc_MPC831x_mtdnand
# Date: Wed Sep 26 11:20:00 2007
# Source: MontaVista Software, Inc.
# MR: 24281
# Type: Enhancement
# Disposition: needs submitting to linuxppc_dev
# Signed-off-by: Gennadiy Kurtsman <gkurtsman@ru.mvista.com>
# Description:
#     MPC831x mtd for nand type flash memory support
# 

PATCHNUM=417
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Source: MontaVista Software, Inc.
MR: 24281
Type: Enhancement
Disposition: needs submitting to linuxppc_dev
Signed-off-by: Gennadiy Kurtsman <gkurtsman@ru.mvista.com>
Description:
    MPC831x mtd for nand type flash memory support

Index: linux-2.6.18/arch/powerpc/boot/dts/mpc8313erdb.dts
===================================================================
--- linux-2.6.18.orig/arch/powerpc/boot/dts/mpc8313erdb.dts
+++ linux-2.6.18/arch/powerpc/boot/dts/mpc8313erdb.dts
@@ -38,6 +38,12 @@
 		reg = <00000000 08000000>;	// 128MB at 0
 	};
 
+	flash_nand {
+		device_type = "rom";
+		compatible = "fsl-nand";
+		reg = <e2800000 2000>;
+	};
+
 	soc8313@e0000000 {
 		#address-cells = <1>;
 		#size-cells = <1>;
@@ -204,5 +210,13 @@
 			built-in;
 			device_type = "ipic";
 		};
+
+		elbc-fcm@5000 {
+			device_type = "elbc-fcm";
+			compatible = "fsl-fcm";
+			reg = <5000 1000>;
+			interrupts = <4d 8>;
+			interrupt-parent = < &ipic >;
+		};
 	};
 };
Index: linux-2.6.18/arch/powerpc/sysdev/fsl_soc.c
===================================================================
--- linux-2.6.18.orig/arch/powerpc/sysdev/fsl_soc.c
+++ linux-2.6.18/arch/powerpc/sysdev/fsl_soc.c
@@ -6,6 +6,10 @@
  * 2006 (c) MontaVista Software, Inc.
  * Vitaly Bordug <vbordug@ru.mvista.com>
  *
+ * Copyright (C) Freescale Semiconductor, Inc. 2006. All rights reserved.
+ * 2006: Lo Wilson (r43300@freescale.com)
+ *	     Added support for Enhanced Local Bus Controller
+ *
  * This program is free software; you can redistribute  it and/or modify it
  * under  the terms of  the GNU General  Public License as published by the
  * Free Software Foundation;  either version 2 of the  License, or (at your
@@ -26,6 +30,8 @@
 #include <linux/fsl_devices.h>
 #include <linux/fs_enet_pd.h>
 #include <linux/fs_uart_pd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/fsl_elbc.h>
 
 #include <asm/system.h>
 #include <asm/atomic.h>
@@ -586,6 +592,79 @@ err:
 
 arch_initcall(fsl_usb_of_init);
 
+static int __init fsl_elbc_of_init(void)
+{
+	struct device_node *np;
+	unsigned int i;
+	struct platform_device *elbc_dev = NULL;
+	struct platform_device *nand_dev = NULL;
+	int ret;
+
+	/* find and register the enhanced local bus controller */
+	for (np = NULL, i = 0;
+	     (np = of_find_compatible_node(np, "elbc-fcm", "fsl-fcm")) != NULL;
+	     i++) {
+		struct resource r[2];
+
+		memset(&r, 0, sizeof(r));
+
+		ret = of_address_to_resource(np, 0, &r[0]);
+		if (ret)
+			goto err;
+
+		r[1].start = r[1].end = irq_of_parse_and_map(np, 0);
+		r[1].flags = IORESOURCE_IRQ;
+
+		elbc_dev =
+		    platform_device_register_simple("fsl-fcm", i, r, 2);
+		if (IS_ERR(elbc_dev)) {
+			ret = PTR_ERR(elbc_dev);
+			goto err;
+		}
+	}
+
+	/* find and register NAND memories if the eLBC was found */
+	for (np = NULL, i = 0;
+	     elbc_dev &&
+	     (np = of_find_compatible_node(np, "rom", "fsl-nand")) != NULL;
+	     i++) {
+		struct resource r;
+		struct platform_fsl_nand_chip chip_data;
+
+		memset(&r, 0, sizeof(r));
+		memset(&chip_data, 0, sizeof(chip_data));
+
+		ret = of_address_to_resource(np, 0, &r);
+		if (ret)
+			goto unreg_elbc;
+
+		nand_dev =
+		    platform_device_register_simple("fsl-nand", i, &r, 1);
+		if (IS_ERR(nand_dev)) {
+			ret = PTR_ERR(nand_dev);
+			goto unreg_elbc;
+		}
+
+		chip_data.name = of_get_property(np, "name", NULL);
+		chip_data.partitions_str = of_get_property(np, "partitions", NULL);
+
+		ret = platform_device_add_data(nand_dev, &chip_data,
+					sizeof(struct platform_fsl_nand_chip));
+		if (ret)
+			goto unreg_nand;
+	}
+	return 0;
+
+unreg_nand:
+	platform_device_unregister(elbc_dev);
+unreg_elbc:
+	platform_device_unregister(nand_dev);
+err:
+	return ret;
+}
+
+arch_initcall(fsl_elbc_of_init);
+ 
 #ifdef CONFIG_CPM2
 
 static const char fcc_regs[] = "fcc_regs";
Index: linux-2.6.18/drivers/mtd/nand/Kconfig
===================================================================
--- linux-2.6.18.orig/drivers/mtd/nand/Kconfig
+++ linux-2.6.18/drivers/mtd/nand/Kconfig
@@ -245,6 +245,14 @@ config MTD_NAND_CS553X
 
 	  If you say "m", the module will be called "cs553x_nand.ko".
 
+config MTD_NAND_FSL_FCM
+	tristate "NAND support for MPC831x"
+	depends on MTD_NAND && PPC_MPC831x
+	help
+	  The MPC831x includes a NAND FLASH Controller Module with built-in
+	  hardware ECC capabilities. This option will enable you to use these to
+	  control external NAND device.
+
 config MTD_NAND_NANDSIM
 	tristate "Support for NAND Flash Simulator"
 	depends on MTD_NAND && MTD_PARTITIONS
Index: linux-2.6.18/drivers/mtd/nand/Makefile
===================================================================
--- linux-2.6.18.orig/drivers/mtd/nand/Makefile
+++ linux-2.6.18/drivers/mtd/nand/Makefile
@@ -25,5 +25,6 @@ obj-$(CONFIG_MTD_NAND_NDFC)		+= ndfc.o
 obj-$(CONFIG_MTD_NAND_OMAP) 		+= omap-nand-flash.o
 obj-$(CONFIG_MTD_NAND_OMAP_HW)		+= omap-hw.o
 obj-$(CONFIG_MTD_NAND_PLATFORM)		+= plat_nand.o
+obj-$(CONFIG_MTD_NAND_FSL_FCM)		+= fsl_fcm.o
 
 nand-objs = nand_base.o nand_bbt.o
Index: linux-2.6.18/drivers/mtd/nand/fsl_fcm.c
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/mtd/nand/fsl_fcm.c
@@ -0,0 +1,1254 @@
+/* linux/drivers/mtd/nand/fsl_fcm.c
+ *
+ * Copyright (c) 2006 Freescale Semiconductor
+ *
+ * Freescale Enhanced Local Bus Controller NAND driver
+ *
+ * Author: Nick Spence <Nick.Spence@freescale.com>
+ * Maintainer: Tony Li <Tony.Li@freescale.com>
+ *
+ * Changelog:
+ *      2006-12 Tony Li <Tony.Li@freescale.com>
+ *              Adopt to MPC8313ERDB board
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/fsl_devices.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/nand_ecc.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+#include <linux/mtd/fsl_elbc.h>
+
+#define MIN(x, y)		((x < y) ? x : y)
+
+#define PARAM_VERIFY(x) if (!(x)) {			\
+	pr_debug ("ERROR %s: " ""#x"" "\n", __func__);	\
+	return -EINVAL;					\
+}
+
+#define PARAM_VERIFY_VOID(x) if (!(x)) {			\
+	pr_debug ("ERROR %s: " ""#x"" "\n", __func__);	\
+	return;					\
+}
+
+struct fsl_elbc_ctrl fcm_ctrl;
+
+/* These map to the positions used by the FCM hardware ECC generator */
+
+/* Small Page FLASH with FMR[ECCM] = 0 */
+static struct nand_ecclayout fsl_fcm_oob_sp_eccm0 = {
+	.eccbytes = 3,
+	.eccpos = {6, 7, 8},
+	.oobfree = {{0, 5}, {9, 7}}
+};
+
+/* Small Page FLASH with FMR[ECCM] = 1 */
+static struct nand_ecclayout fsl_fcm_oob_sp_eccm1 = {
+	.eccbytes = 3,
+	.eccpos = {8, 9, 10},
+	.oobfree = {{0, 5}, {6, 2}, {11, 5}}
+};
+
+/* Large Page FLASH with FMR[ECCM] = 0 */
+static struct nand_ecclayout fsl_fcm_oob_lp_eccm0 = {
+	.eccbytes = 12,
+	.eccpos = {6, 7, 8, 22, 23, 24, 38, 39, 40, 54, 55, 56},
+	.oobfree = {{1, 5}, {9, 13}, {25, 13}, {41, 13}, {57, 7}}
+};
+
+/* Large Page FLASH with FMR[ECCM] = 1 */
+static struct nand_ecclayout fsl_fcm_oob_lp_eccm1 = {
+	.eccbytes = 12,
+	.eccpos = {8, 9, 10, 24, 25, 26, 40, 41, 42, 56, 57, 58},
+	.oobfree = {{1, 7}, {11, 13}, {27, 13}, {43, 13}, {59, 5}}
+};
+
+/*=================================*/
+
+/*
+ * Set up the FCM hardware block and page address fields, and the fcm
+ * structure addr field to point to the correct FCM buffer in memory
+ */
+static void set_addr(struct mtd_info *mtd, int column, int page_addr, int oob)
+{
+	struct nand_chip *chip;
+	struct fsl_elbc_mtd *nmtd;
+	struct fsl_elbc_ctrl *ctrl;
+	volatile lbus83xx_t *lbc;
+	int buf_num;
+
+	PARAM_VERIFY_VOID(mtd);
+	chip = mtd->priv;
+	PARAM_VERIFY_VOID(chip);
+	nmtd = chip->priv;
+	PARAM_VERIFY_VOID(nmtd);
+	ctrl = nmtd->ctrl;
+	PARAM_VERIFY_VOID(ctrl);
+	lbc = ctrl->regs;
+	PARAM_VERIFY_VOID(lbc);
+
+	ctrl->page = page_addr;
+
+	out_be32(&lbc->fbar, page_addr >> (chip->phys_erase_shift - chip->page_shift));
+	if (nmtd->pgs) {
+		out_be32(&lbc->fpar, ((page_addr << FPAR_LP_PI_SHIFT) & FPAR_LP_PI) |
+			(oob ? FPAR_LP_MS : 0) | column);
+		buf_num = (page_addr & 1) << 2;
+	} else {
+		out_be32(&lbc->fpar, ((page_addr << FPAR_SP_PI_SHIFT) & FPAR_SP_PI) |
+			(oob ? FPAR_SP_MS : 0) | column);
+		buf_num = page_addr & 7;
+	}
+	ctrl->addr = (unsigned char *)(nmtd->vbase + (buf_num * 1024));
+
+	/* for OOB data point to the second half of the buffer */
+	if (oob) {
+		ctrl->addr += (nmtd->pgs ? 2048 : 512);
+	}
+	pr_debug("set_addr: bank=%d, ctrl->addr=0x%p (0x%08x)\n",
+		buf_num, ctrl->addr, nmtd->vbase);
+}
+
+/* fsl_fcm_cmd_ctrl
+ *
+ * Issue command and address cycles to the chip
+*/
+
+static void fsl_fcm_cmd_ctrl(struct mtd_info *mtd, int dat,
+				    unsigned int ctrl)
+{
+}
+
+/*
+ * execute FCM command and wait for it to complete
+ */
+static int fsl_fcm_run_command(struct mtd_info *mtd)
+{
+	struct nand_chip *chip;
+	struct fsl_elbc_mtd *nmtd;
+	struct fsl_elbc_ctrl *ctrl;
+	volatile lbus83xx_t *lbc;
+
+	PARAM_VERIFY(mtd);
+	chip = mtd->priv;
+	PARAM_VERIFY(chip);
+	nmtd = chip->priv;
+	PARAM_VERIFY(nmtd);
+	ctrl = nmtd->ctrl;
+	PARAM_VERIFY(ctrl);
+	lbc = ctrl->regs;
+	PARAM_VERIFY(lbc);
+
+	/* Setup the FMR[OP] to execute without write protection */
+	out_be32(&lbc->fmr, nmtd->fmr | 3);
+	if (ctrl->use_mdr)
+		out_be32(&lbc->mdr, ctrl->mdr);
+
+	pr_debug("fsl_fcm_run_command: fmr= %08X fir= %08X fcr= %08X\n",
+		  in_be32(&lbc->fmr), in_be32(&lbc->fir), in_be32(&lbc->fcr));
+	pr_debug("fsl_fcm_run_command: fbar=%08X fpar=%08X fbcr=%08X bank=%d\n",
+		  in_be32(&lbc->fbar), in_be32(&lbc->fpar), in_be32(&lbc->fbcr),
+			nmtd->bank);
+
+	/* clear event registers */
+	out_be32(&lbc->lteatr, 0);
+	out_be32(&lbc->ltesr, (LTESR_FCT | LTESR_PAR | LTESR_CC));
+
+	/* execute special operation */
+	out_be32(&lbc->lsor, nmtd->bank);
+
+	/* wait for FCM complete flag or timeout */
+	might_sleep();
+	ctrl->status = ctrl->irq_status = 0;
+	wait_event_timeout(ctrl->irq_wait, ctrl->irq_status,
+			   FCM_TIMEOUT_MSECS * HZ / 1000);
+	ctrl->status = ctrl->irq_status;
+
+	/* store mdr value in case it was needed */
+	if (ctrl->use_mdr)
+		ctrl->mdr = in_be32(&lbc->mdr);
+
+	ctrl->use_mdr = 0;
+
+	pr_debug("fsl_fcm_run_command: stat=%08X mdr= %08X fmr= %08X\n",
+		  ctrl->status, ctrl->mdr, in_be32(&lbc->fmr));
+
+	/* returns 0 on success otherwise non-zero) */
+	return (ctrl->status == LTESR_CC ? 0 : EFAULT);
+}
+
+/* cmdfunc send commands to the FCM */
+static void fsl_fcm_cmdfunc(struct mtd_info *mtd, unsigned command,
+			     int column, int page_addr)
+{
+	struct nand_chip *chip;
+	struct fsl_elbc_mtd *nmtd;
+	struct fsl_elbc_ctrl *ctrl;
+	volatile lbus83xx_t *lbc;
+
+	PARAM_VERIFY_VOID(mtd);
+	chip = mtd->priv;
+	PARAM_VERIFY_VOID(chip);
+	nmtd = chip->priv;
+	PARAM_VERIFY_VOID(nmtd);
+	ctrl = nmtd->ctrl;
+	PARAM_VERIFY_VOID(ctrl);
+	lbc = ctrl->regs;
+	PARAM_VERIFY_VOID(lbc);
+
+	ctrl->use_mdr = 0;
+
+	/* clear the read buffer */
+	ctrl->read_bytes = 0;
+	if (command != NAND_CMD_PAGEPROG) {
+		ctrl->index = 0;
+		ctrl->oobbuf = -1;
+	}
+
+	switch (command) {
+		/* READ0 and READ1 read the entire buffer to use hardware ECC */
+	case NAND_CMD_READ1:
+		pr_debug("fsl_fcm_cmdfunc: NAND_CMD_READ1, page_addr:"
+			  " 0x%x, column: 0x%x.\n", page_addr, column);
+		ctrl->index = column + 256;
+		goto read0;
+	case NAND_CMD_READ0:
+		pr_debug("fsl_fcm_cmdfunc: NAND_CMD_READ0, page_addr:"
+			  " 0x%x, column: 0x%x.\n", page_addr, column);
+		ctrl->index = column;
+	      read0:
+		if (nmtd->pgs) {
+			out_be32(&lbc->fir, (FIR_OP_CW0 << FIR_OP0_SHIFT) |
+				(FIR_OP_CA << FIR_OP1_SHIFT) |
+				(FIR_OP_PA << FIR_OP2_SHIFT) |
+				(FIR_OP_CW1 << FIR_OP3_SHIFT) |
+				(FIR_OP_RBW << FIR_OP4_SHIFT));
+		} else {
+			out_be32(&lbc->fir, (FIR_OP_CW0 << FIR_OP0_SHIFT) |
+				(FIR_OP_CA << FIR_OP1_SHIFT) |
+				(FIR_OP_PA << FIR_OP2_SHIFT) |
+				(FIR_OP_RBW << FIR_OP3_SHIFT));
+		}
+		out_be32(&lbc->fcr, (NAND_CMD_READ0 << FCR_CMD0_SHIFT) |
+			(NAND_CMD_READSTART << FCR_CMD1_SHIFT));
+		out_be32(&lbc->fbcr, 0);	/* read entire page to enable ECC */
+		set_addr(mtd, 0, page_addr, 0);
+		ctrl->read_bytes = mtd->writesize + mtd->oobsize;
+		goto write_cmd2;
+		/* READOOB read only the OOB becasue no ECC is performed */
+	case NAND_CMD_READOOB:
+		pr_debug("fsl_fcm_cmdfunc: NAND_CMD_READOOB, page_addr:"
+			  " 0x%x, column: 0x%x.\n", page_addr, column);
+		if (nmtd->pgs) {
+			out_be32(&lbc->fir, (FIR_OP_CW0 << FIR_OP0_SHIFT) |
+			    (FIR_OP_CA << FIR_OP1_SHIFT) |
+			    (FIR_OP_PA << FIR_OP2_SHIFT) |
+			    (FIR_OP_CW1 << FIR_OP3_SHIFT) |
+			    (FIR_OP_RBW << FIR_OP4_SHIFT));
+			out_be32(&lbc->fcr, (NAND_CMD_READ0 << FCR_CMD0_SHIFT) |
+			    (NAND_CMD_READSTART << FCR_CMD1_SHIFT));
+		} else {
+			out_be32(&lbc->fir, (FIR_OP_CW0 << FIR_OP0_SHIFT) |
+			    (FIR_OP_CA << FIR_OP1_SHIFT) |
+			    (FIR_OP_PA << FIR_OP2_SHIFT) |
+			    (FIR_OP_RBW << FIR_OP3_SHIFT));
+			out_be32(&lbc->fcr, (NAND_CMD_READOOB << FCR_CMD0_SHIFT));
+		}
+		out_be32(&lbc->fbcr, mtd->oobsize - column);
+		set_addr(mtd, column, page_addr, 1);
+		ctrl->read_bytes = mtd->oobsize;
+		ctrl->index = column;
+		goto write_cmd2;
+		/* READID must read all 5 possible bytes while CEB is active */
+	case NAND_CMD_READID:
+		pr_debug("fsl_fcm_cmdfunc: NAND_CMD_READID.\n");
+		out_be32(&lbc->fir, (FIR_OP_CW0 << FIR_OP0_SHIFT) |
+		    (FIR_OP_UA << FIR_OP1_SHIFT) |
+		    (FIR_OP_RBW << FIR_OP2_SHIFT));
+		 out_be32(&lbc->fcr, (NAND_CMD_READID << FCR_CMD0_SHIFT));
+		out_be32(&lbc->fbcr, 5);
+		ctrl->use_mdr = 1;
+		ctrl->mdr = 0;
+		goto write_cmd0;
+		/* ERASE1 stores the block and page address */
+	case NAND_CMD_ERASE1:
+		pr_debug("fsl_fcm_cmdfunc: NAND_CMD_ERASE1, page_addr:"
+			  " 0x%x.\n", page_addr);
+		set_addr(mtd, 0, page_addr, 0);
+		goto end;
+		/* ERASE2 uses the block and page address from ERASE1 */
+	case NAND_CMD_ERASE2:
+		pr_debug("fsl_fcm_cmdfunc: NAND_CMD_ERASE2.\n");
+		out_be32(&lbc->fir, (FIR_OP_CW0 << FIR_OP0_SHIFT) |
+		    (FIR_OP_PA << FIR_OP1_SHIFT) |
+		    (FIR_OP_CM1 << FIR_OP2_SHIFT));
+		out_be32(&lbc->fcr, (NAND_CMD_ERASE1 << FCR_CMD0_SHIFT) |
+		    (NAND_CMD_ERASE2 << FCR_CMD1_SHIFT));
+		out_be32(&lbc->fbcr, 0);
+		goto write_cmd1;
+		/* SEQIN sets up the addr buffer and all registers except the length */
+	case NAND_CMD_SEQIN:
+		pr_debug("fsl_fcm_cmdfunc: NAND_CMD_SEQIN/PAGE_PROG, page_addr:"
+			  " 0x%x, column: 0x%x.\n", page_addr, column);
+		if (column == 0)
+			out_be32(&lbc->fbcr, 0);
+		else
+			out_be32(&lbc->fbcr, 1);
+		if (nmtd->pgs) {
+			/* always use READ0 for large page devices */
+			out_be32(&lbc->fir, (FIR_OP_CW0 << FIR_OP0_SHIFT) |
+			    (FIR_OP_CA << FIR_OP1_SHIFT) |
+			    (FIR_OP_PA << FIR_OP2_SHIFT) |
+			    (FIR_OP_WB << FIR_OP3_SHIFT) |
+			    (FIR_OP_CW1 << FIR_OP4_SHIFT));
+			out_be32(&lbc->fcr, (NAND_CMD_SEQIN << FCR_CMD0_SHIFT) |
+			    (NAND_CMD_PAGEPROG << FCR_CMD1_SHIFT));
+			set_addr(mtd, column, page_addr, 0);
+		} else {
+			 out_be32(&lbc->fir, (FIR_OP_CW0 << FIR_OP0_SHIFT) |
+			    (FIR_OP_CM2 << FIR_OP1_SHIFT) |
+			    (FIR_OP_CA << FIR_OP2_SHIFT) |
+			    (FIR_OP_PA << FIR_OP3_SHIFT) |
+			    (FIR_OP_WB << FIR_OP4_SHIFT) |
+			    (FIR_OP_CW1 << FIR_OP5_SHIFT));
+			if (column >= mtd->writesize) {
+				/* OOB area --> READOOB */
+				column -= mtd->writesize;
+				out_be32(&lbc->fcr, (NAND_CMD_READOOB << FCR_CMD0_SHIFT)
+				    | (NAND_CMD_PAGEPROG << FCR_CMD1_SHIFT)
+				    | (NAND_CMD_SEQIN << FCR_CMD2_SHIFT));
+				set_addr(mtd, column, page_addr, 1);
+			} else if (column < 256) {
+				/* First 256 bytes --> READ0 */
+				out_be32(&lbc->fcr, (NAND_CMD_READ0 << FCR_CMD0_SHIFT)
+				    | (NAND_CMD_PAGEPROG << FCR_CMD1_SHIFT)
+				    | (NAND_CMD_SEQIN << FCR_CMD2_SHIFT));
+				set_addr(mtd, column, page_addr, 0);
+			} else {
+				/* Second 256 bytes --> READ1 */
+				column -= 256;
+				out_be32(&lbc->fcr, (NAND_CMD_READ1 << FCR_CMD0_SHIFT)
+				    | (NAND_CMD_PAGEPROG << FCR_CMD1_SHIFT)
+				    | (NAND_CMD_SEQIN << FCR_CMD2_SHIFT));
+				set_addr(mtd, column, page_addr, 0);
+			}
+		}
+		goto end;
+		/* PAGEPROG reuses all of the setup from SEQIN and adds the length */
+	case NAND_CMD_PAGEPROG:
+		pr_debug("fsl_fcm_cmdfunc: NAND_CMD_PAGEPROG"
+			  " writing %d bytes.\n", ctrl->index);
+		/* if the write did not start at 0 or is not a full page */
+		/* then set the exact length, otherwise use a full page  */
+		/* write so the HW generates the ECC. */
+		if (in_be32(&lbc->fbcr) ||
+		    (ctrl->index != (mtd->writesize + mtd->oobsize)))
+			out_be32(&lbc->fbcr, ctrl->index);
+		goto write_cmd2;
+		/* CMD_STATUS must read the status byte while CEB is active */
+		/* Note - it does not wait for the ready line */
+	case NAND_CMD_STATUS:
+		pr_debug("fsl_fcm_cmdfunc: NAND_CMD_STATUS.\n");
+		out_be32(&lbc->fir, (FIR_OP_CM0 << FIR_OP0_SHIFT) |
+		    (FIR_OP_RBW << FIR_OP1_SHIFT));
+		out_be32(&lbc->fcr, (NAND_CMD_STATUS << FCR_CMD0_SHIFT));
+		out_be32(&lbc->fbcr, 1);
+		goto write_cmd0;
+		/* RESET without waiting for the ready line */
+	case NAND_CMD_RESET:
+		pr_debug("fsl_fcm_cmdfunc: NAND_CMD_RESET.\n");
+		out_be32(&lbc->fir, (FIR_OP_CM0 << FIR_OP0_SHIFT));
+		out_be32(&lbc->fcr, (NAND_CMD_RESET << FCR_CMD0_SHIFT));
+		out_be32(&lbc->fbcr, 0);
+		goto write_cmd0;
+	default:
+		printk("fsl_fcm_cmdfunc: error, unsupported command.\n");
+		goto end;
+	}
+
+	/* Short cuts fall through to save code */
+      write_cmd0:
+	set_addr(mtd, 0, 0, 0);
+      write_cmd1:
+	ctrl->read_bytes = in_be32(&lbc->fbcr);
+      write_cmd2:
+	fsl_fcm_run_command(mtd);
+
+#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
+	/* if we wrote a page then read back the oob to get the ECC */
+	if ((command == NAND_CMD_PAGEPROG) &&
+	    (chip->ecc.mode > NAND_ECC_SOFT) &&
+	    (in_be32(&lbc->fbcr) == 0) && (ctrl->oobbuf != 0) && (ctrl->oobbuf != -1)) {
+		int i;
+		uint *oob_config;
+		unsigned char *oob_buf;
+
+		i = ctrl->page;
+		oob_buf = (unsigned char *)ctrl->oobbuf;
+		oob_config = chip->ecc.layout->eccpos;
+
+		/* wait for the write to complete and check it passed */
+		if (!(chip->waitfunc(mtd, chip) & 0x01)) {
+			/* read back the OOB */
+			fsl_fcm_cmdfunc(mtd, NAND_CMD_READOOB, 0, i);
+			/* if it succeeded then copy the ECC bytes */
+			if (ctrl->status == LTESR_CC) {
+				for (i = 0; i < chip->ecc.layout->eccbytes; i++) {
+					oob_buf[oob_config[i]] =
+					    ctrl->addr[oob_config[i]];
+				}
+			}
+		}
+	}
+#endif
+
+      end:
+	return;
+}
+
+/*
+ * FCM does not support 16 bit data busses
+ */
+static u16 fsl_fcm_read_word(struct mtd_info *mtd)
+{
+	struct nand_chip *chip;
+	struct fsl_elbc_ctrl *ctrl;
+
+	PARAM_VERIFY(mtd);
+	chip = mtd->priv;
+	PARAM_VERIFY(chip);
+	ctrl = (struct fsl_elbc_ctrl *)chip->controller;
+	PARAM_VERIFY(ctrl);
+
+	dev_err(ctrl->device, "fsl_fcm_read_word: UNIMPLEMENTED.\n");
+	return 0;
+}
+
+/*
+ * Write buf to the FCM Controller Data Buffer
+ */
+static void fsl_fcm_write_buf(struct mtd_info *mtd, const u_char * buf,
+			       int len)
+{
+	struct nand_chip *chip;
+	struct fsl_elbc_mtd *nmtd;
+	struct fsl_elbc_ctrl *ctrl;
+
+	PARAM_VERIFY_VOID(mtd);
+	PARAM_VERIFY_VOID(buf);
+	chip = mtd->priv;
+	PARAM_VERIFY_VOID(chip);
+	nmtd = chip->priv;
+	PARAM_VERIFY_VOID(nmtd);
+	ctrl = nmtd->ctrl;
+	PARAM_VERIFY_VOID(ctrl);
+
+	pr_debug("fsl_fcm_write_buf: writing %d bytes starting with 0x%lx"
+		  " at %d.\n", len, *((unsigned long *)buf), ctrl->index);
+
+	/* If armed catch the address of the OOB buffer so that it can be */
+	/* updated with the real signature after the program comletes */
+	if (!ctrl->oobbuf)
+		ctrl->oobbuf = (int)buf;
+
+	/* copy the data into the FCM hardware buffer and update the index */
+	memcpy(&(ctrl->addr[ctrl->index]), buf, len);
+	ctrl->index += len;
+	return;
+}
+
+/*
+ * read a byte from either the FCM hardware buffer if it has any data left
+ * otherwise issue a command to read a single byte.
+ */
+static u_char fsl_fcm_read_byte(struct mtd_info *mtd)
+{
+	struct nand_chip *chip;
+	struct fsl_elbc_mtd *nmtd;
+	struct fsl_elbc_ctrl *ctrl;
+	volatile lbus83xx_t *lbc;
+	unsigned char byte;
+
+	PARAM_VERIFY(mtd);
+	chip = mtd->priv;
+	PARAM_VERIFY(chip);
+	nmtd = chip->priv;
+	PARAM_VERIFY(nmtd);
+	ctrl = nmtd->ctrl;
+	PARAM_VERIFY(ctrl);
+	lbc = ctrl->regs;
+	PARAM_VERIFY(lbc);
+
+	/* If there are still bytes in the FCM then use the next byte */
+	if (ctrl->index < ctrl->read_bytes) {
+		byte = ctrl->addr[(ctrl->index)++];
+		pr_debug("fsl_fcm_read_byte: byte %u (%02X): %d of %d.\n",
+			  byte, byte, ctrl->index - 1, ctrl->read_bytes);
+	} else {
+		/* otherwise issue a command to read 1 byte */
+		out_be32(&lbc->fir, (FIR_OP_RSW << FIR_OP0_SHIFT));
+		ctrl->use_mdr = 1;
+		ctrl->read_bytes = 0;
+		ctrl->index = 0;
+		ctrl->read_bytes = 0;
+		ctrl->index = 0;
+		byte = fsl_fcm_run_command(mtd) ? ERR_BYTE : ctrl->mdr & 0xff;
+		pr_debug("fsl_fcm_read_byte: byte %u (%02X) from bus.\n",
+			  byte, byte);
+	}
+
+	return byte;
+}
+
+/*
+ * Read from the FCM Controller Data Buffer
+ */
+static void fsl_fcm_read_buf(struct mtd_info *mtd, u_char * buf, int len)
+{
+	struct nand_chip *chip;
+	struct fsl_elbc_mtd *nmtd;
+	struct fsl_elbc_ctrl *ctrl;
+	int i;
+	int rest;
+	unsigned long old_status;
+
+	PARAM_VERIFY_VOID(mtd);
+	chip = mtd->priv;
+	PARAM_VERIFY_VOID(chip);
+	nmtd = chip->priv;
+	PARAM_VERIFY_VOID(nmtd);
+	ctrl = nmtd->ctrl;
+	PARAM_VERIFY_VOID(ctrl);
+
+	pr_debug("fsl_fcm_read_buf: reading %d bytes.\n", len);
+
+	/* see how much is still in the FCM buffer */
+	i = min((unsigned int)len, (ctrl->read_bytes - ctrl->index));
+	rest = len - i;
+	len = i;
+
+	/* copying bytes even if there was an error so that the oob works */
+	memcpy(buf, &(ctrl->addr[(ctrl->index)]), len);
+	ctrl->index += len;
+
+	/* If more data is needed then issue another block read */
+	if (rest) {
+		pr_debug("fsl_fcm_read_buf: getting %d more bytes.\n",
+			  rest);
+
+		buf += len;
+
+		/* keep last status in case it was an error */
+		old_status = ctrl->status;
+
+		/* read full next page to use HW ECC if enabled */
+		fsl_fcm_cmdfunc(mtd, NAND_CMD_READ0, 0, ctrl->page + 1);
+
+		/* preserve the worst status code */
+		if (ctrl->status == LTESR_CC)
+			ctrl->status = old_status;
+
+		fsl_fcm_read_buf(mtd, buf, rest);
+	}
+	return;
+}
+
+/*
+ * Verify buffer against the FCM Controller Data Buffer
+ */
+static int fsl_fcm_verify_buf(struct mtd_info *mtd, const u_char * buf,
+			       int len)
+{
+	struct nand_chip *chip;
+	struct fsl_elbc_mtd *nmtd;
+	struct fsl_elbc_ctrl *ctrl;
+	int i;
+	int rest;
+
+	PARAM_VERIFY(mtd);
+	chip = mtd->priv;
+	PARAM_VERIFY(chip);
+	nmtd = chip->priv;
+	PARAM_VERIFY(nmtd);
+	ctrl = nmtd->ctrl;
+	PARAM_VERIFY(ctrl);
+
+	pr_debug("fsl_fcm_verify_buf: checking %d bytes starting with 0x%02lx.\n",
+		  len, *((unsigned long *)buf));
+
+	/* If last read failed then return error bytes */
+	if (ctrl->status != LTESR_CC) {
+		return EFAULT;
+	}
+
+	/* see how much is still in the FCM buffer */
+	i = min((unsigned int)len, (ctrl->read_bytes - ctrl->index));
+	rest = len - i;
+	len = i;
+
+	if (memcmp(buf, &(ctrl->addr[(ctrl->index)]), len)) {
+		return EFAULT;
+	}
+
+	ctrl->index += len;
+	if (rest) {
+		pr_debug("fsl_fcm_verify_buf: getting %d more bytes.\n",
+			  rest);
+		buf += len;
+
+		/* read full next page to use HW ECC if enabled */
+		fsl_fcm_cmdfunc(mtd, NAND_CMD_READ0, 0, ctrl->page + 1);
+
+		return fsl_fcm_verify_buf(mtd, buf, rest);
+	}
+	return 0;
+}
+
+/* this function is called after Program and Erase Operations to
+ * check for success or failure */
+static int fsl_fcm_wait(struct mtd_info *mtd, struct nand_chip *this)
+{
+	struct nand_chip *chip;
+	struct fsl_elbc_mtd *nmtd;
+	struct fsl_elbc_ctrl *ctrl;
+	lbus83xx_t *lbc;
+
+	PARAM_VERIFY(mtd);
+	chip = mtd->priv;
+	PARAM_VERIFY(chip);
+	nmtd = chip->priv;
+	PARAM_VERIFY(nmtd);
+	ctrl = nmtd->ctrl;
+	PARAM_VERIFY(ctrl);
+	lbc = ctrl->regs;
+	PARAM_VERIFY(lbc);
+
+  	if (ctrl->status != LTESR_CC) {
+		return (0x1);	/* Status Read error */
+	}
+
+	/* Use READ_STATUS command, but wait for the device to be ready */
+	ctrl->use_mdr = 0;
+	ctrl->oobbuf = -1;
+	out_be32(&lbc->fir, (FIR_OP_CW0 << FIR_OP0_SHIFT) |
+	    (FIR_OP_RBW << FIR_OP1_SHIFT));
+	out_be32(&lbc->fcr, (NAND_CMD_STATUS << FCR_CMD0_SHIFT));
+	set_addr(mtd, 0, 0, 0);
+	out_be32(&lbc->fbcr, 1);
+	ctrl->index = 0;
+	ctrl->read_bytes = lbc->fbcr;
+	fsl_fcm_run_command(mtd);
+	if (ctrl->status != LTESR_CC) {
+		return (0x1);	/* Status Read error */
+	}
+	return chip->read_byte(mtd);
+}
+
+/* ECC handling functions */
+
+/*
+ * fsl_fcm_enable_hwecc - start ECC generation
+ */
+static void fsl_fcm_enable_hwecc(struct mtd_info *mtd, int mode)
+{
+	return;
+}
+
+/*
+ * fsl_fcm_calculate_ecc - Calculate the ECC bytes
+ * This is done by hardware during the write process, so we use this
+ * to arm the oob buf capture on the next write_buf() call. The ECC bytes
+ * only need to be captured if CONFIG_MTD_NAND_VERIFY_WRITE is defined which
+ * reads back the pages and checks they match the data and oob buffers.
+ */
+static int fsl_fcm_calculate_ecc(struct mtd_info *mtd, const u_char * dat,
+				  u_char * ecc_code)
+{
+#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
+	struct nand_chip *chip;
+	struct fsl_elbc_mtd *nmtd;
+	struct fsl_elbc_ctrl *ctrl;
+
+	PARAM_VERIFY(mtd);
+	chip = mtd->priv;
+	PARAM_VERIFY(chip);
+	nmtd = chip->priv;
+	PARAM_VERIFY(nmtd);
+	ctrl = nmtd->ctrl;
+	PARAM_VERIFY(ctrl);
+	/* arm capture of oob buf ptr on next write_buf */
+	ctrl->oobbuf = 0;
+#endif
+	return 0;
+}
+
+/*
+ * fsl_fcm_correct_data - Detect and correct bit error(s)
+ * The detection and correction is done automatically by the hardware,
+ * if the complete page was read. If the status code is okay then there
+ * was no error, otherwise we return an error code indicating an uncorrectable
+ * error.
+ */
+static int fsl_fcm_correct_data(struct mtd_info *mtd, u_char * dat,
+				 u_char * read_ecc, u_char * calc_ecc)
+{
+	struct nand_chip *chip;
+	struct fsl_elbc_mtd *nmtd;
+	struct fsl_elbc_ctrl *ctrl;
+
+	PARAM_VERIFY(mtd);
+	chip = mtd->priv;
+	PARAM_VERIFY(chip);
+	nmtd = chip->priv;
+	PARAM_VERIFY(nmtd);
+	ctrl = nmtd->ctrl;
+	PARAM_VERIFY(ctrl);
+	/* No errors */
+	if (ctrl->status == LTESR_CC)
+		return 0;
+
+	return -1;		/* uncorrectable error */
+}
+
+/*************************************************************************/
+/*                     Chip setup and control functions                  */
+/*************************************************************************/
+
+/*
+ * Dummy scan_bbt to complete setup of the FMR based on NAND size
+ */
+static int fsl_fcm_chip_init_tail(struct mtd_info *mtd)
+{
+	struct nand_chip *chip;
+	struct fsl_elbc_mtd *nmtd;
+	struct fsl_elbc_ctrl *ctrl;
+	volatile lbus83xx_t *lbc;
+	unsigned int i;
+	unsigned int al;
+
+	PARAM_VERIFY(mtd);
+	chip = mtd->priv;
+	PARAM_VERIFY(chip);
+	nmtd = chip->priv;
+	PARAM_VERIFY(nmtd);
+	ctrl = nmtd->ctrl;
+	PARAM_VERIFY(ctrl);
+	lbc = ctrl->regs;
+	PARAM_VERIFY(lbc);
+
+	/* calculate FMR Address Length field */
+	al = 0;
+	for (i = chip->pagemask >> 16; i; i >>= 8) {
+		al++;
+	}
+
+	/* add to ECCM mode set in fsl_fcm_init */
+	nmtd->fmr |= 12 << FMR_CWTO_SHIFT |	/* Timeout > 12 mSecs */
+	    al << FMR_AL_SHIFT;
+
+	pr_debug("fsl_fcm_init: nand->options  =   %08X\n", chip->options);
+	pr_debug("fsl_fcm_init: nand->numchips = %10d\n", chip->numchips);
+	pr_debug("fsl_fcm_init: nand->chipsize = %10ld\n", chip->chipsize);
+	pr_debug("fsl_fcm_init: nand->pagemask = %10X\n", chip->pagemask);
+	pr_debug("fsl_fcm_init: nand->chip_delay = %8d\n",
+		  chip->chip_delay);
+	pr_debug("fsl_fcm_init: nand->badblockpos = %7d\n",
+		  chip->badblockpos);
+	pr_debug("fsl_fcm_init: nand->chip_shift = %8d\n",
+		  chip->chip_shift);
+	pr_debug("fsl_fcm_init: nand->page_shift = %8d\n",
+		  chip->page_shift);
+	pr_debug("fsl_fcm_init: nand->phys_erase_shift = %2d\n",
+		  chip->phys_erase_shift);
+	pr_debug("fsl_fcm_init: nand->ecclayout= %10p\n", chip->ecclayout);
+	pr_debug("fsl_fcm_init: nand->eccmode  = %10d\n", chip->ecc.mode);
+	pr_debug("fsl_fcm_init: nand->eccsteps = %10d\n", chip->ecc.steps);
+	pr_debug("fsl_fcm_init: nand->eccsize  = %10d\n", chip->ecc.size);
+	pr_debug("fsl_fcm_init: nand->eccbytes = %10d\n", chip->ecc.bytes);
+	pr_debug("fsl_fcm_init: nand->ecctotal = %10d\n", chip->ecc.total);
+	pr_debug("fsl_fcm_init: nand->ecclayout= %10p\n",
+		  chip->ecc.layout);
+	pr_debug("fsl_fcm_init: mtd->flags     =   %08X\n", mtd->flags);
+	pr_debug("fsl_fcm_init: mtd->size      = %10d\n", mtd->size);
+	pr_debug("fsl_fcm_init: mtd->erasesize = %10d\n", mtd->erasesize);
+	pr_debug("fsl_fcm_init: mtd->writesize = %10d\n", mtd->writesize);
+	pr_debug("fsl_fcm_init: mtd->oobsize   = %10d\n", mtd->oobsize);
+
+	/* adjust Option Register and ECC to match Flash page size */
+	if (mtd->writesize == 512) {
+		u32 tmp;
+		tmp = in_be32(&lbc->bank[nmtd->bank].or);
+		tmp &= ~(OR_FCM_PGS);
+		out_be32(&lbc->bank[nmtd->bank].or, tmp);
+	} else if (mtd->writesize == 2048) {
+		lbc->bank[nmtd->bank].or |= OR_FCM_PGS;
+		/* adjust ecc setup if needed */
+		if ((in_be32(&lbc->bank[nmtd->bank].br) & BR_DECC) == BR_DECC_CHK_GEN) {
+			chip->ecc.size = 2048;
+			chip->ecc.steps = 1;
+			chip->ecc.layout = (nmtd->fmr & FMR_ECCM) ?
+			    &fsl_fcm_oob_lp_eccm1 : &fsl_fcm_oob_lp_eccm0;
+			mtd->ecclayout = chip->ecc.layout;
+		}
+	} else {
+		printk("fsl_fcm_init: page size %d is not supported\n",
+		       mtd->writesize);
+		return -1;
+	}
+	nmtd->pgs = (in_be32(&lbc->bank[nmtd->bank].or) >> OR_FCM_PGS_SHIFT) & 1;
+
+	/* fix up the oobavail size in case the layout was changed */
+	chip->ecc.layout->oobavail = 0;
+	for (i = 0; chip->ecc.layout->oobfree[i].length; i++)
+		chip->ecc.layout->oobavail +=
+		    chip->ecc.layout->oobfree[i].length;
+
+	/* return to the default bbt_scan_routine */
+	chip->scan_bbt = nand_default_bbt;
+
+	/* restore complete options including the real SKIP_BBTSCAN setting */
+	chip->options = nmtd->options;
+
+	/* Check, if we should skip the bad block table scan */
+	if (chip->options & NAND_SKIP_BBTSCAN)
+		return 0;
+
+	return chip->scan_bbt(mtd);
+}
+
+/* fsl_fcm_chip_init
+ *
+ * init a single instance of an chip
+*/
+
+static int fsl_fcm_chip_init(struct fsl_elbc_mtd *nmtd)
+{
+	struct fsl_elbc_ctrl *ctrl;
+	volatile lbus83xx_t *lbc;
+	struct nand_chip *chip;
+
+	PARAM_VERIFY(nmtd);
+	ctrl = nmtd->ctrl;
+	PARAM_VERIFY(ctrl);
+	lbc = ctrl->regs;
+	PARAM_VERIFY(lbc);
+	chip = &nmtd->chip;
+	PARAM_VERIFY(chip);
+	pr_debug("eLBC Set Information for bank %d\n", nmtd->bank);
+	pr_debug("  name          = %s\n",
+		  nmtd->pl_chip.name ? nmtd->pl_chip.name : "(NULL)");
+	pr_debug("  nr_chips      = %d\n", nmtd->pl_chip.nr_chips);
+	pr_debug("  partitions    = %s\n",
+		  nmtd->pl_chip.partitions_str ?
+		  nmtd->pl_chip.partitions_str : "(NULL)");
+	dev_dbg(nmtd->device, "eLBC Set Information for bank %d\n", nmtd->bank);
+	dev_dbg(nmtd->device, "  name          = %s\n",
+		nmtd->name ? nmtd->name : "(NULL)");
+	dev_dbg(nmtd->device, "  nr_chips      = %d\n", nmtd->pl_chip.nr_chips);
+	dev_dbg(nmtd->device, "  partitions    = %s\n",
+		nmtd->pl_chip.partitions_str ?
+		nmtd->pl_chip.partitions_str : "(NULL)");
+
+	/* Fill in fsl_elbc_mtd structure */
+	nmtd->name = (char *)nmtd->pl_chip.name;
+	nmtd->mtd.name = nmtd->name;
+	nmtd->mtd.priv = chip;
+	nmtd->mtd.owner = THIS_MODULE;
+	nmtd->pgs = (in_be32(&lbc->bank[nmtd->bank].or) >> OR_FCM_PGS_SHIFT) & 1;
+	nmtd->fmr = 0;		/* rest filled in later */
+
+	/* fill in nand_chip structure */
+	/* set physical base address from the Base Register */
+	chip->IO_ADDR_W = (void __iomem *)(nmtd->pbase);
+	chip->IO_ADDR_R = chip->IO_ADDR_W;
+
+	/* set up function call table */
+	chip->read_byte = fsl_fcm_read_byte;
+	chip->read_word = fsl_fcm_read_word;
+	chip->write_buf = fsl_fcm_write_buf;
+	chip->read_buf = fsl_fcm_read_buf;
+	chip->verify_buf = fsl_fcm_verify_buf;
+	chip->cmd_ctrl  = fsl_fcm_cmd_ctrl;
+	chip->cmdfunc = fsl_fcm_cmdfunc;
+	chip->waitfunc = fsl_fcm_wait;
+	chip->scan_bbt = fsl_fcm_chip_init_tail;
+
+	/* set up nand options */
+	chip->options = NAND_NO_READRDY;
+	chip->chip_delay = 1;
+
+	chip->controller = &ctrl->controller;
+	chip->priv = nmtd;
+
+	/* If CS Base Register selects full hardware ECC then use it */
+	if ((in_be32(&lbc->bank[nmtd->bank].br) & BR_DECC) == BR_DECC_CHK_GEN) {
+		chip->ecc.mode = NAND_ECC_HW;
+		chip->ecc.calculate = fsl_fcm_calculate_ecc;
+		chip->ecc.correct = fsl_fcm_correct_data;
+		chip->ecc.hwctl = fsl_fcm_enable_hwecc;
+		/* put in small page settings and adjust later if needed */
+		chip->ecc.layout = (nmtd->fmr & FMR_ECCM) ?
+		    &fsl_fcm_oob_sp_eccm1 : &fsl_fcm_oob_sp_eccm0;
+		chip->ecc.size = 512;
+		chip->ecc.bytes = 3;
+	} else {
+		/* otherwise fall back to default software ECC */
+		chip->ecc.mode = NAND_ECC_SOFT;
+	}
+
+	/* force BBT scan to get to custom scan_bbt for final settings */
+	nmtd->options = chip->options;
+	chip->options &= ~(NAND_SKIP_BBTSCAN);
+
+	return 0;
+}
+
+static int fsl_fcm_chip_remove(struct platform_device *pdev)
+{
+	struct fsl_elbc_mtd *nmtd = platform_get_drvdata(pdev);
+	struct fsl_elbc_ctrl *ctrl;
+
+	PARAM_VERIFY(nmtd);
+	ctrl = nmtd->ctrl;
+	PARAM_VERIFY(ctrl);
+
+	nand_release(&nmtd->mtd);
+
+	if (nmtd->vbase != 0) {
+		iounmap((void __iomem *)nmtd->vbase);
+		nmtd->vbase = 0;
+	}
+
+	platform_set_drvdata(pdev, NULL);
+
+	ctrl->nmtd[nmtd->bank] = NULL;
+	atomic_dec(&ctrl->childs_active);
+
+	kfree(nmtd);
+
+	return 0;
+}
+
+static int fsl_fcm_chip_probe(struct platform_device *pdev)
+{
+	struct platform_fsl_nand_chip *pnc;
+	struct fsl_elbc_ctrl *ctrl = &fcm_ctrl;
+	volatile lbus83xx_t *lbc = ctrl->regs;
+	struct fsl_elbc_mtd *nmtd;
+	struct resource *res;
+	int err = 0;
+	int size;
+	int bank;
+
+	dev_dbg(&pdev->dev, "fsl_fcm_chip_probe(%p)\n", pdev);
+	PARAM_VERIFY(pdev);
+	PARAM_VERIFY(lbc);
+
+	pnc = pdev->dev.platform_data;
+	/* check that the platform data structure was supplied */
+	if (pnc == NULL) {
+		dev_err(&pdev->dev, "Device needs a platform data structure\n");
+		err = -ENOENT;
+		goto exit_error;
+	}
+
+	/* check that the device has a name */
+	if (pnc->name == NULL) {
+		dev_err(&pdev->dev, "Device requires a name\n");
+		err = -ENOENT;
+		goto exit_error;
+	}
+	/* get, allocate and map the memory resource */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "failed to get memory region resource\n");
+		err = -ENOENT;
+		goto exit_error;
+	}
+	/* find which chip select it is connected to */
+	for (bank = 0; bank < MAX_BANKS; bank++)
+		if ((in_be32(&lbc->bank[bank].br) & BR_V) &&
+		    ((in_be32(&lbc->bank[bank].br) & BR_MSEL) == BR_MS_FCM) &&
+		    ((in_be32(&lbc->bank[bank].br) & in_be32(&lbc->bank[bank].or) & BR_BA) ==
+		     res->start))
+			break;
+
+	if (bank >= MAX_BANKS) {
+		dev_err(&pdev->dev, "address did not match any chip selects\n");
+		err = -ENOENT;
+		goto exit_error;
+	}
+
+	nmtd = kmalloc(sizeof(*nmtd), GFP_KERNEL);
+	if (!nmtd) {
+		dev_err(ctrl->device, "no memory for nand chip structure\n");
+		err = -ENOMEM;
+		goto exit_error;
+	}
+	memset(nmtd, 0, sizeof(*nmtd));
+
+	platform_set_drvdata(pdev, nmtd);
+
+	atomic_inc(&ctrl->childs_active);
+	if (pnc)
+		memcpy(&(nmtd->pl_chip), pnc, sizeof(*pnc));
+	ctrl->nmtd[bank] = nmtd;
+	nmtd->bank = bank;
+	nmtd->ctrl = ctrl;
+	nmtd->device = &pdev->dev;
+
+	size = (res->end - res->start) + 1;
+	nmtd->pbase = res->start;
+	nmtd->vbase = (unsigned int)ioremap(nmtd->pbase, FCM_SIZE);
+	if (nmtd->vbase == 0) {
+		dev_err(ctrl->device, "failed to ioremap() memory region\n");
+		err = -EIO;
+		goto free_error;
+	}
+
+	err = fsl_fcm_chip_init(nmtd);
+	if (err != 0)
+		goto unmap_error;
+
+	err = nand_scan(&nmtd->mtd,
+			nmtd->pl_chip.nr_chips ? nmtd->pl_chip.nr_chips : 1);
+	if (err != 0)
+		goto unmap_error;
+
+	err = add_mtd_device(&nmtd->mtd);
+
+	if (err == 0)
+		return 0;
+
+unmap_error:
+	iounmap((volatile void __iomem *)nmtd->vbase);
+free_error:
+	kfree(nmtd);
+exit_error:
+	return err;
+}
+
+/**************************************************************************/
+/*                  Controller setup and control functions                */
+/**************************************************************************/
+
+static int fsl_fcm_ctrl_init(struct fsl_elbc_ctrl *ctrl,
+			      struct platform_device *pdev)
+{
+	lbus83xx_t *lbc;
+	u32 tmp;
+
+	PARAM_VERIFY(ctrl);
+	lbc = (lbus83xx_t *) ctrl->regs;
+	PARAM_VERIFY(lbc);
+	/* Enable only FCM detection of timeouts, ECC errors and completion */
+	out_be32(&lbc->ltedr, ~(LTESR_FCT | LTESR_PAR | LTESR_CC));
+
+	/* clear event registers */
+	out_be32(&lbc->lteatr, 0);
+	tmp = in_be32(&lbc->ltesr);
+	out_be32(&lbc->ltesr, tmp | (LTESR_FCT | LTESR_PAR | LTESR_CC));
+
+	/* Enable interrupts for any detected events */
+	out_be32(&lbc->lteir, 0xffffffff);
+	ctrl->read_bytes = 0;
+	ctrl->index = 0;
+	ctrl->addr = (unsigned char *)(NULL);
+	ctrl->oobbuf = -1;
+
+	return 0;
+}
+
+static int fsl_fcm_ctrl_remove(struct platform_device *pdev)
+{
+	struct fsl_elbc_ctrl *ctrl;
+
+	PARAM_VERIFY(pdev);
+	ctrl = platform_get_drvdata(pdev);
+	PARAM_VERIFY(ctrl);
+
+	if (atomic_read(&ctrl->childs_active))
+		return -EBUSY;
+
+	free_irq(ctrl->irq, pdev);
+	iounmap(ctrl->regs);
+
+	platform_set_drvdata(pdev, NULL);
+	memset(ctrl, 0, sizeof(*ctrl));
+
+	return 0;
+}
+
+/* interrupt handler code */
+
+static irqreturn_t fsl_fcm_ctrl_irq(int irqno, void *param, struct pt_regs *ptrg)
+{
+	struct fsl_elbc_ctrl *ctrl =
+	    platform_get_drvdata((struct platform_device *)param);
+	lbus83xx_t *lbc = (lbus83xx_t *) ctrl->regs;
+	u32 tmp;
+
+	ctrl->irq_status = in_be32(&lbc->ltesr) & (LTESR_FCT | LTESR_PAR | LTESR_CC);
+	if (ctrl->irq_status)
+		wake_up(&ctrl->irq_wait);
+
+	/* clear event registers */
+	out_be32(&lbc->lteatr, 0);
+	tmp = in_be32(&lbc->ltesr);
+	out_be32(&lbc->ltesr, tmp | ctrl->irq_status);
+	return IRQ_HANDLED;
+}
+
+/* fsl_fcm_ctrl_probe
+ *
+ * called by device layer when it finds a device matching
+ * one our driver can handled. This code allocates all of
+ * the resources needed for the controller only.  The
+ * resources for the NAND banks themselves are allocated
+ * in the chip probe function.
+*/
+
+static int fsl_fcm_ctrl_probe(struct platform_device *pdev)
+{
+	struct fsl_elbc_ctrl *ctrl;
+	struct resource *res;
+	int err = 0;
+	int size;
+	int ret;
+
+	dev_dbg(&pdev->dev, "fsl_fcm_ctrl_probe(%p)\n", pdev);
+	ctrl = &fcm_ctrl;
+
+	memset(ctrl, 0, sizeof(*ctrl));
+
+	spin_lock_init(&ctrl->controller.lock);
+	init_waitqueue_head(&ctrl->controller.wq);
+	init_waitqueue_head(&ctrl->irq_wait);
+
+	/* get, allocate and map the memory resource */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "failed to get memory region resouce\n");
+		err = -ENOENT;
+		goto exit_error;
+	}
+
+	size = (res->end - res->start) + 1;
+	ctrl->regs = ioremap(res->start, size);
+	if (ctrl->regs == 0) {
+		dev_err(&pdev->dev, "failed to ioremap() region\n");
+		err = -EIO;
+		goto exit_error;
+	}
+
+	/* get and allocate the irq resource */
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "failed to get irq resource\n");
+		err = -ENOENT;
+		goto unmap;
+	}
+
+	ret = request_irq(res->start, fsl_fcm_ctrl_irq, IRQF_DISABLED, pdev->name, pdev);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "failed to install irq (%d)\n", ret);
+		err = -EIO;
+		goto unmap;
+	}
+
+	ctrl->irq = res->start;
+	ctrl->device = &pdev->dev;
+	dev_dbg(&pdev->dev, "mapped registers at %p\n", ctrl->regs);
+
+	/* initialise the hardware */
+
+	err = fsl_fcm_ctrl_init(ctrl, pdev);
+	if (err)
+		goto free_irq;
+	platform_set_drvdata(pdev, ctrl);
+	return 0;
+
+free_irq:
+	free_irq(ctrl->irq, pdev);
+unmap:
+	iounmap(ctrl->regs);
+exit_error:
+	return err;
+}
+
+/*************************************************************************/
+/*                        device driver registration                     */
+/*************************************************************************/
+
+static struct platform_driver fsl_fcm_ctrl_driver = {
+	.probe = fsl_fcm_ctrl_probe,
+	.remove = fsl_fcm_ctrl_remove,
+	.driver = {
+		   .name = "fsl-fcm",
+		   .owner = THIS_MODULE,
+		   },
+};
+
+static struct platform_driver fsl_fcm_chip_driver = {
+	.probe = fsl_fcm_chip_probe,
+	.remove = fsl_fcm_chip_remove,
+	.driver = {
+		   .name = "fsl-nand",
+		   .owner = THIS_MODULE,
+		   },
+};
+
+static int __init fsl_fcm_init(void)
+{
+	int ret;
+
+	printk(KERN_INFO "Freescale eLBC FCM NAND Driver (C) 2006 Freescale\n");
+
+	ret = platform_driver_register(&fsl_fcm_ctrl_driver);
+	if (!ret)
+		ret = platform_driver_register(&fsl_fcm_chip_driver);
+
+	return ret;
+}
+
+static void __exit fsl_fcm_exit(void)
+{
+	platform_driver_unregister(&fsl_fcm_chip_driver);
+	platform_driver_unregister(&fsl_fcm_ctrl_driver);
+}
+
+module_init(fsl_fcm_init);
+module_exit(fsl_fcm_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Freescale");
+MODULE_DESCRIPTION("Freescale Enhanced Local Bus Controller MTD NAND driver");
Index: linux-2.6.18/include/linux/mtd/fsl_elbc.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/linux/mtd/fsl_elbc.h
@@ -0,0 +1,365 @@
+/*
+ * (C) Copyright 2004-2006 Freescale Semiconductor, Inc.
+ *
+ * Freescale Enhanced Local Bus Controller Internal Memory Map
+ *
+ * History :
+ * 20061010 : Extracted fomr immap_83xx.h
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+#ifndef __FSL_ELBC__
+#define __FSL_ELBC__
+
+#ifdef __KERNEL__
+
+#define PFX "fsl-elbc: "
+
+#define FCM_SIZE (8 * 1024)
+
+#define MAX_BANKS (8)
+
+#define ERR_BYTE 0xFF		/* Value returned for read bytes when read failed */
+
+#define FCM_TIMEOUT_MSECS 100	/* Maximum number of mSecs to wait for FCM */
+
+/*
+ * Local Bus Controller Registers
+ */
+typedef struct lbus_bank{
+	u32 br;             /**< Base Register  */
+#define BR0 0x5000
+#define BR1 0x5008
+#define BR2 0x5010
+#define BR3 0x5018
+#define BR4 0x5020
+#define BR5 0x5028
+#define BR6 0x5030
+#define BR7 0x5038
+
+#define BR_BA           0xFFFF8000
+#define BR_BA_SHIFT             15
+#define BR_PS           0x00001800
+#define BR_PS_SHIFT             11
+#define BR_PS_8         0x00000800  /* Port Size 8 bit */
+#define BR_PS_16        0x00001000  /* Port Size 16 bit */
+#define BR_PS_32        0x00001800  /* Port Size 32 bit */
+#define BR_DECC         0x00000600
+#define BR_DECC_SHIFT            9
+#define BR_DECC_OFF     0x00000000  /* HW ECC checking and generation off */
+#define BR_DECC_CHK     0x00000200  /* HW ECC checking on, generation off */
+#define BR_DECC_CHK_GEN 0x00000400  /* HW ECC checking and generation on */
+#define BR_WP           0x00000100
+#define BR_WP_SHIFT              8
+#define BR_MSEL         0x000000E0
+#define BR_MSEL_SHIFT            5
+#define BR_MS_GPCM      0x00000000  /* GPCM */
+#define BR_MS_FCM       0x00000020  /* FCM */
+#define BR_MS_SDRAM     0x00000060  /* SDRAM */
+#define BR_MS_UPMA      0x00000080  /* UPMA */
+#define BR_MS_UPMB      0x000000A0  /* UPMB */
+#define BR_MS_UPMC      0x000000C0  /* UPMC */
+#define BR_V            0x00000001
+#define BR_V_SHIFT               0
+#define BR_RES          ~(BR_BA|BR_PS|BR_DECC|BR_WP|BR_MSEL|BR_V)
+
+	u32 or;             /**< Base Register  */
+#define OR0 0x5004
+#define OR1 0x500C
+#define OR2 0x5014
+#define OR3 0x501C
+#define OR4 0x5024
+#define OR5 0x502C
+#define OR6 0x5034
+#define OR7 0x503C
+
+#define OR_GPCM_AM              0xFFFF8000
+#define OR_GPCM_AM_SHIFT                15
+#define OR_GPCM_BCTLD           0x00001000
+#define OR_GPCM_BCTLD_SHIFT             12
+#define OR_GPCM_CSNT            0x00000800
+#define OR_GPCM_CSNT_SHIFT              11
+#define OR_GPCM_ACS             0x00000600
+#define OR_GPCM_ACS_SHIFT                9
+#define OR_GPCM_ACS_0b10        0x00000400
+#define OR_GPCM_ACS_0b11        0x00000600
+#define OR_GPCM_XACS            0x00000100
+#define OR_GPCM_XACS_SHIFT               8
+#define OR_GPCM_SCY             0x000000F0
+#define OR_GPCM_SCY_SHIFT                4
+#define OR_GPCM_SCY_1           0x00000010
+#define OR_GPCM_SCY_2           0x00000020
+#define OR_GPCM_SCY_3           0x00000030
+#define OR_GPCM_SCY_4           0x00000040
+#define OR_GPCM_SCY_5           0x00000050
+#define OR_GPCM_SCY_6           0x00000060
+#define OR_GPCM_SCY_7           0x00000070
+#define OR_GPCM_SCY_8           0x00000080
+#define OR_GPCM_SCY_9           0x00000090
+#define OR_GPCM_SCY_10          0x000000a0
+#define OR_GPCM_SCY_11          0x000000b0
+#define OR_GPCM_SCY_12          0x000000c0
+#define OR_GPCM_SCY_13          0x000000d0
+#define OR_GPCM_SCY_14          0x000000e0
+#define OR_GPCM_SCY_15          0x000000f0
+#define OR_GPCM_SETA            0x00000008
+#define OR_GPCM_SETA_SHIFT               3
+#define OR_GPCM_TRLX            0x00000004
+#define OR_GPCM_TRLX_SHIFT               2
+#define OR_GPCM_EHTR            0x00000002
+#define OR_GPCM_EHTR_SHIFT               1
+#define OR_GPCM_EAD             0x00000001
+#define OR_GPCM_EAD_SHIFT                0
+
+#define OR_UPM_AM    0xFFFF8000
+#define OR_UPM_AM_SHIFT      15
+#define OR_UPM_XAM   0x00006000
+#define OR_UPM_XAM_SHIFT     13
+#define OR_UPM_BCTLD 0x00001000
+#define OR_UPM_BCTLD_SHIFT   12
+#define OR_UPM_BI    0x00000100
+#define OR_UPM_BI_SHIFT       8
+#define OR_UPM_TRLX  0x00000004
+#define OR_UPM_TRLX_SHIFT     2
+#define OR_UPM_EHTR  0x00000002
+#define OR_UPM_EHTR_SHIFT     1
+#define OR_UPM_EAD   0x00000001
+#define OR_UPM_EAD_SHIFT      0
+
+#define OR_SDRAM_AM    0xFFFF8000
+#define OR_SDRAM_AM_SHIFT      15
+#define OR_SDRAM_XAM   0x00006000
+#define OR_SDRAM_XAM_SHIFT     13
+#define OR_SDRAM_COLS  0x00001C00
+#define OR_SDRAM_COLS_SHIFT    10
+#define OR_SDRAM_ROWS  0x000001C0
+#define OR_SDRAM_ROWS_SHIFT     6
+#define OR_SDRAM_PMSEL 0x00000020
+#define OR_SDRAM_PMSEL_SHIFT    5
+#define OR_SDRAM_EAD   0x00000001
+#define OR_SDRAM_EAD_SHIFT      0
+
+#define OR_FCM_AM               0xFFFF8000
+#define OR_FCM_AM_SHIFT                 15
+#define OR_FCM_BCTLD            0x00001000
+#define OR_FCM_BCTLD_SHIFT              12
+#define OR_FCM_PGS              0x00000400
+#define OR_FCM_PGS_SHIFT                10
+#define OR_FCM_CSCT             0x00000200
+#define OR_FCM_CSCT_SHIFT                9
+#define OR_FCM_CST              0x00000100
+#define OR_FCM_CST_SHIFT                 8
+#define OR_FCM_CHT              0x00000080
+#define OR_FCM_CHT_SHIFT                 7
+#define OR_FCM_SCY              0x00000070
+#define OR_FCM_SCY_SHIFT                 4
+#define OR_FCM_SCY_1            0x00000010
+#define OR_FCM_SCY_2            0x00000020
+#define OR_FCM_SCY_3            0x00000030
+#define OR_FCM_SCY_4            0x00000040
+#define OR_FCM_SCY_5            0x00000050
+#define OR_FCM_SCY_6            0x00000060
+#define OR_FCM_SCY_7            0x00000070
+#define OR_FCM_RST              0x00000008
+#define OR_FCM_RST_SHIFT                 3
+#define OR_FCM_TRLX             0x00000004
+#define OR_FCM_TRLX_SHIFT                2
+#define OR_FCM_EHTR             0x00000002
+#define OR_FCM_EHTR_SHIFT                1
+} lbus_bank_t;
+
+typedef struct lbus83xx {
+	lbus_bank_t bank[8];
+	u8 res0[0x28];
+	u32 mar;                /**< UPM Address Register */
+	u8 res1[0x4];
+	u32 mamr;               /**< UPMA Mode Register */
+	u32 mbmr;               /**< UPMB Mode Register */
+	u32 mcmr;               /**< UPMC Mode Register */
+	u8 res2[0x8];
+	u32 mrtpr;              /**< Memory Refresh Timer Prescaler Register */
+	u32 mdr;                /**< UPM Data Register */
+	u8 res3[0x4];
+	u32 lsor;               /**< Special Operation Initiation Register */
+	u32 lsdmr;              /**< SDRAM Mode Register */
+	u8 res4[0x8];
+	u32 lurt;               /**< UPM Refresh Timer */
+	u32 lsrt;               /**< SDRAM Refresh Timer */
+	u8 res5[0x8];
+	u32 ltesr;              /**< Transfer Error Status Register */
+#define LTESR_BM   0x80000000
+#define LTESR_FCT  0x40000000
+#define LTESR_PAR  0x20000000
+#define LTESR_WP   0x04000000
+#define LTESR_ATMW 0x00800000
+#define LTESR_ATMR 0x00400000
+#define LTESR_CS   0x00080000
+#define LTESR_CC   0x00000001
+	u32 ltedr;              /**< Transfer Error Disable Register */
+	u32 lteir;              /**< Transfer Error Interrupt Register */
+	u32 lteatr;             /**< Transfer Error Attributes Register */
+	u32 ltear;              /**< Transfer Error Address Register */
+	u8 res6[0xC];
+	u32 lbcr;               /**< Configuration Register */
+#define LBCR_LDIS  0x80000000
+#define LBCR_LDIS_SHIFT    31
+#define LBCR_BCTLC 0x00C00000
+#define LBCR_BCTLC_SHIFT   22
+#define LBCR_AHD   0x00200000
+#define LBCR_LPBSE 0x00020000
+#define LBCR_LPBSE_SHIFT   17
+#define LBCR_EPAR  0x00010000
+#define LBCR_EPAR_SHIFT    16
+#define LBCR_BMT   0x0000FF00
+#define LBCR_BMT_SHIFT      8
+#define LBCR_INIT  0x00040000
+	u32 lcrr;               /**< Clock Ratio Register */
+#define LCRR_DBYP    0x80000000
+#define LCRR_DBYP_SHIFT      31
+#define LCRR_BUFCMDC 0x30000000
+#define LCRR_BUFCMDC_SHIFT   28
+#define LCRR_ECL     0x03000000
+#define LCRR_ECL_SHIFT       24
+#define LCRR_EADC    0x00030000
+#define LCRR_EADC_SHIFT      16
+#define LCRR_CLKDIV  0x0000000F
+#define LCRR_CLKDIV_SHIFT     0
+	u8 res7[0x8];
+	u32 fmr;               /**< Flash Mode Register */
+#define FMR_CWTO     0x0000F000
+#define FMR_CWTO_SHIFT       12
+#define FMR_BOOT     0x00000800
+#define FMR_ECCM     0x00000100
+#define FMR_AL       0x00000030
+#define FMR_AL_SHIFT          4
+#define FMR_OP       0x00000003
+#define FMR_OP_SHIFT          0
+	u32 fir;               /**< Flash Instruction Register */
+#define FIR_OP0      0xF0000000
+#define FIR_OP0_SHIFT        28
+#define FIR_OP1      0x0F000000
+#define FIR_OP1_SHIFT        24
+#define FIR_OP2      0x00F00000
+#define FIR_OP2_SHIFT        20
+#define FIR_OP3      0x000F0000
+#define FIR_OP3_SHIFT        16
+#define FIR_OP4      0x0000F000
+#define FIR_OP4_SHIFT        12
+#define FIR_OP5      0x00000F00
+#define FIR_OP5_SHIFT         8
+#define FIR_OP6      0x000000F0
+#define FIR_OP6_SHIFT         4
+#define FIR_OP7      0x0000000F
+#define FIR_OP7_SHIFT         0
+#define FIR_OP_NOP   0x0	/* No operation and end of sequence */
+#define FIR_OP_CA    0x1        /* Issue current column address */
+#define FIR_OP_PA    0x2        /* Issue current block+page address */
+#define FIR_OP_UA    0x3        /* Issue user defined address */
+#define FIR_OP_CM0   0x4        /* Issue command from FCR[CMD0] */
+#define FIR_OP_CM1   0x5        /* Issue command from FCR[CMD1] */
+#define FIR_OP_CM2   0x6        /* Issue command from FCR[CMD2] */
+#define FIR_OP_CM3   0x7        /* Issue command from FCR[CMD3] */
+#define FIR_OP_WB    0x8        /* Write FBCR bytes from FCM buffer */
+#define FIR_OP_WS    0x9        /* Write 1 or 2 bytes from MDR[AS] */
+#define FIR_OP_RB    0xA        /* Read FBCR bytes to FCM buffer */
+#define FIR_OP_RS    0xB        /* Read 1 or 2 bytes to MDR[AS] */
+#define FIR_OP_CW0   0xC        /* Wait then issue FCR[CMD0] */
+#define FIR_OP_CW1   0xD        /* Wait then issue FCR[CMD1] */
+#define FIR_OP_RBW   0xE        /* Wait then read FBCR bytes */
+#define FIR_OP_RSW   0xE        /* Wait then read 1 or 2 bytes */
+	u32 fcr;               /**< Flash Command Register */
+#define FCR_CMD0     0xFF000000
+#define FCR_CMD0_SHIFT       24
+#define FCR_CMD1     0x00FF0000
+#define FCR_CMD1_SHIFT       16
+#define FCR_CMD2     0x0000FF00
+#define FCR_CMD2_SHIFT        8
+#define FCR_CMD3     0x000000FF
+#define FCR_CMD3_SHIFT        0
+	u32 fbar;              /**< Flash Block Address Register */
+#define FBAR_BLK     0x00FFFFFF
+	u32 fpar;              /**< Flash Page Address Register */
+#define FPAR_SP_PI   0x00007C00
+#define FPAR_SP_PI_SHIFT     10
+#define FPAR_SP_MS   0x00000200
+#define FPAR_SP_CI   0x000001FF
+#define FPAR_SP_CI_SHIFT      0
+#define FPAR_LP_PI   0x0003F000
+#define FPAR_LP_PI_SHIFT     12
+#define FPAR_LP_MS   0x00000800
+#define FPAR_LP_CI   0x000007FF
+#define FPAR_LP_CI_SHIFT      0
+	u32 fbcr;              /**< Flash Byte Count Register */
+#define FBCR_BC      0x00000FFF
+	u8 res11[0x8];
+	u8 res8[0xF00];
+} lbus83xx_t;
+
+struct platform_fsl_nand_chip {
+	const char	*name;
+	int		nr_chips;
+	const char 	*partitions_str;
+};
+
+/* mtd information per set */
+
+struct fsl_elbc_mtd {
+	struct mtd_info mtd;
+	struct nand_chip chip;
+	struct platform_fsl_nand_chip pl_chip;
+	struct fsl_elbc_ctrl *ctrl;
+
+	struct device *device;
+	char *name;		/* Name of set (optional)    */
+	int *nr_map;		/* Physical chip num (option) */
+	unsigned int options;
+	int bank;		/* Chip select bank number           */
+	unsigned int pbase;	/* Chip select base physical address */
+	unsigned int vbase;	/* Chip select base virtual address  */
+	int pgs;		/* NAND page size (0=512, 1=2048)    */
+	unsigned int fmr;	/* FCM Flash Mode Register value     */
+};
+
+/* overview of the fsl elbc controller */
+
+struct fsl_elbc_ctrl {
+	struct nand_hw_control controller;
+	struct fsl_elbc_mtd *nmtd[MAX_BANKS];
+
+	/* device info */
+	atomic_t childs_active;
+	struct device *device;
+	lbus83xx_t *regs;
+	int irq;
+	wait_queue_head_t irq_wait;
+	unsigned int irq_status;	/* status read from LTESR by irq handler */
+	u_char *addr;		/* Address of assigned FCM buffer        */
+	unsigned int page;	/* Last page written to / read from      */
+	unsigned int read_bytes;	/* Number of bytes read during command   */
+	unsigned int index;	/* Pointer to next byte to 'read'        */
+	unsigned int status;	/* status read from LTESR after last op  */
+	int oobbuf;		/* Pointer to OOB block                  */
+	unsigned int mdr;	/* UPM/FCM Data Register value           */
+	unsigned int use_mdr;	/* Non zero if the MDR is to be set      */
+};
+
+/* Setting this option prevents the command line from being parsed
+ * for MTD partitions. */
+#define FSL_ELBC_NO_CMDLINE_PARTITIONS	0x10000000
+
+#endif /* __KERNEL__ */
+#endif /* __FSL_ELBC__ */
Index: linux-2.6.18/mvl_patches/pro50-0417.c
===================================================================
--- /dev/null
+++ linux-2.6.18/mvl_patches/pro50-0417.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(417);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

