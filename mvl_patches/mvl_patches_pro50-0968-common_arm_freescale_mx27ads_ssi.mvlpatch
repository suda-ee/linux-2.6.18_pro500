#! /usr/bin/env bash
# Patch: -common_arm_freescale_mx27ads_ssi
# Date: Tue Mar 11 17:33:20 2008
# Source:  http://opensource.freescale.com/pub/scm/linux-2.6-mx.git 
# MR: 26156
# Type: Integration 
# Disposition:  merged from bsp-imx27ads-rel2 branch of opensource.freescale.com/pub/scm/linux-2.6-mx.git 
# Signed-off-by:  Aleksey Makarov <amakarov@ru.mvista.com> 
# Description: 
#     Synchronous Serial Interface support for i.mx27ads board.
# 

PATCHNUM=968
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Source:  http://opensource.freescale.com/pub/scm/linux-2.6-mx.git 
MR: 26156
Type: Integration 
Disposition:  merged from bsp-imx27ads-rel2 branch of opensource.freescale.com/pub/scm/linux-2.6-mx.git 
Signed-off-by:  Aleksey Makarov <amakarov@ru.mvista.com> 
Description: 
    Synchronous Serial Interface support for i.mx27ads board.

Index: linux-2.6.18/drivers/Makefile
===================================================================
--- linux-2.6.18.orig/drivers/Makefile
+++ linux-2.6.18/drivers/Makefile
@@ -72,6 +72,7 @@ obj-$(CONFIG_MCA)		+= mca/
 obj-$(CONFIG_EISA)		+= eisa/
 obj-$(CONFIG_CPU_FREQ)		+= cpufreq/
 obj-$(CONFIG_MMC)		+= mmc/
+obj-$(CONFIG_ARCH_MXC)          += mxc/
 obj-$(CONFIG_NEW_LEDS)		+= leds/
 obj-$(CONFIG_INFINIBAND)	+= infiniband/
 obj-$(CONFIG_IPATH_CORE)	+= infiniband/
Index: linux-2.6.18/drivers/mxc/Kconfig
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/mxc/Kconfig
@@ -0,0 +1,11 @@
+# drivers/video/mxc/Kconfig
+
+if ARCH_MXC
+
+menu "MXC support drivers"
+
+source "drivers/mxc/ssi/Kconfig"
+
+endmenu
+
+endif
Index: linux-2.6.18/drivers/mxc/Makefile
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/mxc/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_MXC_SSI)               	+= ssi/
Index: linux-2.6.18/drivers/mxc/ssi/Kconfig
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/mxc/ssi/Kconfig
@@ -0,0 +1,13 @@
+#
+# SPI device configuration
+#
+
+menu "MXC SSI support"
+
+config MXC_SSI
+	tristate "SSI support"
+	---help---
+	  Say Y to get the SSI services API available on MXC platform.
+
+endmenu
+
Index: linux-2.6.18/drivers/mxc/ssi/Makefile
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/mxc/ssi/Makefile
@@ -0,0 +1,9 @@
+#
+# Makefile for the kernel SSI device drivers.
+#
+
+obj-$(CONFIG_MXC_SSI) 		+= ssimod.o
+
+ssimod-objs := ssi.o
+
+
Index: linux-2.6.18/drivers/mxc/ssi/registers.h
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/mxc/ssi/registers.h
@@ -0,0 +1,191 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+ /*!
+  * @file ../ssi/registers.h
+  * @brief This header file contains SSI driver low level definition to access module registers.
+  *
+  * @ingroup SSI
+  */
+
+#ifndef __MXC_SSI_REGISTERS_H__
+#define __MXC_SSI_REGISTERS_H__
+
+/*!
+ * This include to define bool type, false and true definitions.
+ */
+#include <asm/hardware.h>
+
+#define SPBA_CPU_SSI            0x07
+
+#define    MXC_SSISTX0		0x00
+#define    MXC_SSISTX1		0x04
+#define    MXC_SSISRX0		0x08
+#define    MXC_SSISRX1   	0x0C
+#define    MXC_SSISCR           0x10
+#define    MXC_SSISISR          0x14
+#define    MXC_SSISIER   	0x18
+#define    MXC_SSISTCR   	0x1C
+#define    MXC_SSISRCR   	0x20
+#define    MXC_SSISTCCR  	0x24
+#define    MXC_SSISRCCR  	0x28
+#define    MXC_SSISFCSR  	0x2C
+#define    MXC_SSISTR           0x30
+#define    MXC_SSISOR           0x34
+#define    MXC_SSISACNT  	0x38
+#define    MXC_SSISACADD 	0x3C
+#define    MXC_SSISACDAT 	0x40
+#define    MXC_SSISATAG  	0x44
+#define    MXC_SSISTMSK  	0x48
+#define    MXC_SSISRMSK  	0x4C
+
+/*! SSI1 registers offset*/
+#define    MXC_SSI1STX0		0x00
+#define    MXC_SSI1STX1		0x04
+#define    MXC_SSI1SRX0		0x08
+#define    MXC_SSI1SRX1   	0x0C
+#define    MXC_SSI1SCR          0x10
+#define    MXC_SSI1SISR         0x14
+#define    MXC_SSI1SIER   	0x18
+#define    MXC_SSI1STCR   	0x1C
+#define    MXC_SSI1SRCR   	0x20
+#define    MXC_SSI1STCCR  	0x24
+#define    MXC_SSI1SRCCR  	0x28
+#define    MXC_SSI1SFCSR  	0x2C
+#define    MXC_SSI1STR          0x30
+#define    MXC_SSI1SOR          0x34
+#define    MXC_SSI1SACNT  	0x38
+#define    MXC_SSI1SACADD 	0x3C
+#define    MXC_SSI1SACDAT 	0x40
+#define    MXC_SSI1SATAG  	0x44
+#define    MXC_SSI1STMSK  	0x48
+#define    MXC_SSI1SRMSK  	0x4C
+
+/*! SSI2 registers offset*/
+#define    MXC_SSI2STX0   	0x00
+#define    MXC_SSI2STX1         0x04
+#define    MXC_SSI2SRX0    	0x08
+#define    MXC_SSI2SRX1         0x0C
+#define    MXC_SSI2SCR          0x10
+#define    MXC_SSI2SISR         0x14
+#define    MXC_SSI2SIER         0x18
+#define    MXC_SSI2STCR         0x1C
+#define    MXC_SSI2SRCR         0x20
+#define    MXC_SSI2STCCR  	0x24
+#define    MXC_SSI2SRCCR   	0x28
+#define    MXC_SSI2SFCSR        0x2C
+#define    MXC_SSI2STR    	0x30
+#define    MXC_SSI2SOR    	0x34
+#define    MXC_SSI2SACNT  	0x38
+#define    MXC_SSI2SACADD 	0x3C
+#define    MXC_SSI2SACDAT 	0x40
+#define    MXC_SSI2SATAG  	0x44
+#define    MXC_SSI2STMSK  	0x48
+#define    MXC_SSI2SRMSK  	0x4C
+
+/*!
+ * SCR Register bit shift definitions
+ */
+#define SSI_ENABLE_SHIFT            0
+#define SSI_TRANSMIT_ENABLE_SHIFT   1
+#define SSI_RECEIVE_ENABLE_SHIFT    2
+#define SSI_NETWORK_MODE_SHIFT      3
+#define SSI_SYNCHRONOUS_MODE_SHIFT  4
+#define SSI_I2S_MODE_SHIFT          5
+#define SSI_SYSTEM_CLOCK_SHIFT      7
+#define SSI_TWO_CHANNEL_SHIFT       8
+#define SSI_CLOCK_IDLE_SHIFT        9
+
+/*!
+ * STCR & SRCR Registers bit shift definitions
+ */
+#define SSI_EARLY_FRAME_SYNC_SHIFT    0
+#define SSI_FRAME_SYNC_LENGTH_SHIFT   1
+#define SSI_FRAME_SYNC_INVERT_SHIFT   2
+#define SSI_CLOCK_POLARITY_SHIFT      3
+#define SSI_SHIFT_DIRECTION_SHIFT     4
+#define SSI_CLOCK_DIRECTION_SHIFT     5
+#define SSI_FRAME_DIRECTION_SHIFT     6
+#define SSI_FIFO_ENABLE_0_SHIFT       7
+#define SSI_FIFO_ENABLE_1_SHIFT       8
+#define SSI_BIT_0_SHIFT               9
+
+/*!
+ * STCCR & SRCCR Registers bit shift definitions
+ */
+#define SSI_PRESCALER_MODULUS_SHIFT          0
+#define SSI_FRAME_RATE_DIVIDER_SHIFT         8
+#define SSI_WORD_LENGTH_SHIFT               13
+#define SSI_PRESCALER_RANGE_SHIFT           17
+#define SSI_DIVIDE_BY_TWO_SHIFT             18
+#define SSI_FRAME_DIVIDER_MASK              31
+#define SSI_MIN_FRAME_DIVIDER_RATIO          1
+#define SSI_MAX_FRAME_DIVIDER_RATIO         32
+#define SSI_PRESCALER_MODULUS_MASK         255
+#define SSI_MIN_PRESCALER_MODULUS_RATIO      1
+#define SSI_MAX_PRESCALER_MODULUS_RATIO    256
+#define SSI_WORD_LENGTH_MASK                15
+/*!
+ * SISR Register definition
+ */
+#define SSI_IRQ_STATUS_NUMBER        19
+
+/*!
+ * SFCSR Register bit shift definitions
+ */
+#define SSI_RX_FIFO_1_COUNT_SHIFT       28
+#define SSI_TX_FIFO_1_COUNT_SHIFT       24
+#define SSI_RX_FIFO_1_WATERMARK_SHIFT   20
+#define SSI_TX_FIFO_1_WATERMARK_SHIFT   16
+#define SSI_RX_FIFO_0_COUNT_SHIFT       12
+#define SSI_TX_FIFO_0_COUNT_SHIFT        8
+#define SSI_RX_FIFO_0_WATERMARK_SHIFT    4
+#define SSI_TX_FIFO_0_WATERMARK_SHIFT    0
+#define SSI_MIN_FIFO_WATERMARK           0
+#define SSI_MAX_FIFO_WATERMARK           8
+
+/*!
+ * SSI Option Register (SOR) bit shift definitions
+ */
+#define SSI_FRAME_SYN_RESET_SHIFT        0
+#define SSI_WAIT_SHIFT                   1
+#define SSI_INIT_SHIFT                   3
+#define SSI_TRANSMITTER_CLEAR_SHIFT      4
+#define SSI_RECEIVER_CLEAR_SHIFT         5
+#define SSI_CLOCK_OFF_SHIFT              6
+#define SSI_WAIT_STATE_MASK            0x3
+
+/*!
+ * SSI AC97 Control Register (SACNT) bit shift definitions
+ */
+#define AC97_MODE_ENABLE_SHIFT           0
+#define AC97_VARIABLE_OPERATION_SHIFT    1
+#define AC97_TAG_IN_FIFO_SHIFT           2
+#define AC97_READ_COMMAND_SHIFT          3
+#define AC97_WRITE_COMMAND_SHIFT         4
+#define AC97_FRAME_RATE_DIVIDER_SHIFT    5
+#define AC97_FRAME_RATE_MASK          0x3F
+
+/*!
+ * SSI Test Register (STR) bit shift definitions
+ */
+#define SSI_TEST_MODE_SHIFT               15
+#define SSI_RCK2TCK_SHIFT                 14
+#define SSI_RFS2TFS_SHIFT                 13
+#define SSI_RXSTATE_SHIFT                 8
+#define SSI_TXD2RXD_SHIFT                 7
+#define SSI_TCK2RCK_SHIFT                 6
+#define SSI_TFS2RFS_SHIFT                 5
+#define SSI_TXSTATE_SHIFT                 0
+
+#endif				/* __MXC_SSI_REGISTERS_H__ */
Index: linux-2.6.18/drivers/mxc/ssi/ssi.c
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/mxc/ssi/ssi.c
@@ -0,0 +1,1156 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file ssi.c
+ * @brief This file contains the implementation of the SSI driver main services
+ *
+ *
+ * @ingroup SSI
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <asm/uaccess.h>
+#include <asm/arch/clock.h>
+#include <asm/io.h>
+
+#include "registers.h"
+#include "ssi.h"
+
+static spinlock_t ssi_lock;
+
+EXPORT_SYMBOL(ssi_ac97_frame_rate_divider);
+EXPORT_SYMBOL(ssi_ac97_get_command_address_register);
+EXPORT_SYMBOL(ssi_ac97_get_command_data_register);
+EXPORT_SYMBOL(ssi_ac97_get_tag_register);
+EXPORT_SYMBOL(ssi_ac97_mode_enable);
+EXPORT_SYMBOL(ssi_ac97_tag_in_fifo);
+EXPORT_SYMBOL(ssi_ac97_read_command);
+EXPORT_SYMBOL(ssi_ac97_set_command_address_register);
+EXPORT_SYMBOL(ssi_ac97_set_command_data_register);
+EXPORT_SYMBOL(ssi_ac97_set_tag_register);
+EXPORT_SYMBOL(ssi_ac97_variable_mode);
+EXPORT_SYMBOL(ssi_ac97_write_command);
+EXPORT_SYMBOL(ssi_clock_idle_state);
+EXPORT_SYMBOL(ssi_clock_off);
+EXPORT_SYMBOL(ssi_enable);
+EXPORT_SYMBOL(ssi_get_data);
+EXPORT_SYMBOL(ssi_get_status);
+EXPORT_SYMBOL(ssi_i2s_mode);
+EXPORT_SYMBOL(ssi_interrupt_disable);
+EXPORT_SYMBOL(ssi_interrupt_enable);
+EXPORT_SYMBOL(ssi_network_mode);
+EXPORT_SYMBOL(ssi_receive_enable);
+EXPORT_SYMBOL(ssi_rx_bit0);
+EXPORT_SYMBOL(ssi_rx_clock_direction);
+EXPORT_SYMBOL(ssi_rx_clock_divide_by_two);
+EXPORT_SYMBOL(ssi_rx_clock_polarity);
+EXPORT_SYMBOL(ssi_rx_clock_prescaler);
+EXPORT_SYMBOL(ssi_rx_early_frame_sync);
+EXPORT_SYMBOL(ssi_rx_fifo_counter);
+EXPORT_SYMBOL(ssi_rx_fifo_enable);
+EXPORT_SYMBOL(ssi_rx_fifo_full_watermark);
+EXPORT_SYMBOL(ssi_rx_flush_fifo);
+EXPORT_SYMBOL(ssi_rx_frame_direction);
+EXPORT_SYMBOL(ssi_rx_frame_rate);
+EXPORT_SYMBOL(ssi_rx_frame_sync_active);
+EXPORT_SYMBOL(ssi_rx_frame_sync_length);
+EXPORT_SYMBOL(ssi_rx_mask_time_slot);
+EXPORT_SYMBOL(ssi_rx_prescaler_modulus);
+EXPORT_SYMBOL(ssi_rx_shift_direction);
+EXPORT_SYMBOL(ssi_rx_word_length);
+EXPORT_SYMBOL(ssi_set_data);
+EXPORT_SYMBOL(ssi_set_wait_states);
+EXPORT_SYMBOL(ssi_synchronous_mode);
+EXPORT_SYMBOL(ssi_system_clock);
+EXPORT_SYMBOL(ssi_transmit_enable);
+EXPORT_SYMBOL(ssi_two_channel_mode);
+EXPORT_SYMBOL(ssi_tx_bit0);
+EXPORT_SYMBOL(ssi_tx_clock_direction);
+EXPORT_SYMBOL(ssi_tx_clock_divide_by_two);
+EXPORT_SYMBOL(ssi_tx_clock_polarity);
+EXPORT_SYMBOL(ssi_tx_clock_prescaler);
+EXPORT_SYMBOL(ssi_tx_early_frame_sync);
+EXPORT_SYMBOL(ssi_tx_fifo_counter);
+EXPORT_SYMBOL(ssi_tx_fifo_empty_watermark);
+EXPORT_SYMBOL(ssi_tx_fifo_enable);
+EXPORT_SYMBOL(ssi_tx_flush_fifo);
+EXPORT_SYMBOL(ssi_tx_frame_direction);
+EXPORT_SYMBOL(ssi_tx_frame_rate);
+EXPORT_SYMBOL(ssi_tx_frame_sync_active);
+EXPORT_SYMBOL(ssi_tx_frame_sync_length);
+EXPORT_SYMBOL(ssi_tx_mask_time_slot);
+EXPORT_SYMBOL(ssi_tx_prescaler_modulus);
+EXPORT_SYMBOL(ssi_tx_shift_direction);
+EXPORT_SYMBOL(ssi_tx_word_length);
+
+unsigned int get_ssi_base_addr(unsigned int ssi)
+{
+	unsigned int base_addr;
+	base_addr = (ssi == SSI1) ? IO_ADDRESS(SSI1_BASE_ADDR) :
+	    IO_ADDRESS(SSI2_BASE_ADDR);
+	return base_addr;
+}
+
+void set_register_bits(unsigned int mask, unsigned int data,
+		       unsigned int offset, unsigned int ssi)
+{
+	volatile unsigned long reg = 0;
+	unsigned int base_addr = 0;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&ssi_lock, flags);
+	base_addr = get_ssi_base_addr(ssi);
+	reg = __raw_readl(base_addr + offset);
+	reg = (reg & (~mask)) | data;
+	__raw_writel(reg, base_addr + offset);
+	spin_unlock_irqrestore(&ssi_lock, flags);
+}
+
+unsigned long getreg_value(unsigned int offset, unsigned int ssi)
+{
+	volatile unsigned long reg = 0;
+	unsigned int base_addr = 0;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&ssi_lock, flags);
+	base_addr = get_ssi_base_addr(ssi);
+	reg = __raw_readl(base_addr + offset);
+	spin_unlock_irqrestore(&ssi_lock, flags);
+
+	return reg;
+}
+
+void set_register(unsigned int data, unsigned int offset, unsigned int ssi)
+{
+	unsigned int base_addr = 0;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&ssi_lock, flags);
+	base_addr = get_ssi_base_addr(ssi);
+	__raw_writel(data, base_addr + offset);
+	spin_unlock_irqrestore(&ssi_lock, flags);
+
+}
+
+/*!
+ * This function controls the AC97 frame rate divider.
+ *
+ * @param        module               the module number
+ * @param        frame_rate_divider   the AC97 frame rate divider
+ */
+void ssi_ac97_frame_rate_divider(ssi_mod module,
+				 unsigned char frame_rate_divider)
+{
+	unsigned int reg = 0;
+
+	reg = getreg_value(MXC_SSISACNT, module);
+	reg |= ((frame_rate_divider & AC97_FRAME_RATE_MASK)
+		<< AC97_FRAME_RATE_DIVIDER_SHIFT);
+	set_register(reg, MXC_SSISACNT, module);
+}
+
+/*!
+ * This function gets the AC97 command address register.
+ *
+ * @param        module        the module number
+ * @return       This function returns the command address slot information.
+ */
+unsigned int ssi_ac97_get_command_address_register(ssi_mod module)
+{
+	return getreg_value(MXC_SSISACADD, module);
+}
+
+/*!
+ * This function gets the AC97 command data register.
+ *
+ * @param        module        the module number
+ * @return       This function returns the command data slot information.
+ */
+unsigned int ssi_ac97_get_command_data_register(ssi_mod module)
+{
+	return getreg_value(MXC_SSISACDAT, module);
+}
+
+/*!
+ * This function gets the AC97 tag register.
+ *
+ * @param        module        the module number
+ * @return       This function returns the tag information.
+ */
+unsigned int ssi_ac97_get_tag_register(ssi_mod module)
+{
+	return getreg_value(MXC_SSISATAG, module);
+}
+
+/*!
+ * This function controls the AC97 mode.
+ *
+ * @param        module        the module number
+ * @param        state         the AC97 mode state (enabled or disabled)
+ */
+void ssi_ac97_mode_enable(ssi_mod module, bool state)
+{
+	unsigned int reg = 0;
+
+	reg = getreg_value(MXC_SSISACNT, module);
+	if (state == true) {
+		reg |= (1 << AC97_MODE_ENABLE_SHIFT);
+	} else {
+		reg &= ~(1 << AC97_MODE_ENABLE_SHIFT);
+	}
+
+	set_register(reg, MXC_SSISACNT, module);
+}
+
+/*!
+ * This function controls the AC97 tag in FIFO behavior.
+ *
+ * @param        module        the module number
+ * @param        state         the tag in fifo behavior (Tag info stored in Rx FIFO 0 if true,
+ * Tag info stored in SATAG register otherwise)
+ */
+void ssi_ac97_tag_in_fifo(ssi_mod module, bool state)
+{
+	unsigned int reg = 0;
+
+	reg = getreg_value(MXC_SSISACNT, module);
+	if (state == true) {
+		reg |= (1 << AC97_TAG_IN_FIFO_SHIFT);
+	} else {
+		reg &= ~(1 << AC97_TAG_IN_FIFO_SHIFT);
+	}
+
+	set_register(reg, MXC_SSISACNT, module);
+}
+
+/*!
+ * This function controls the AC97 read command.
+ *
+ * @param        module        the module number
+ * @param        state         the next AC97 command is a read command or not
+ */
+void ssi_ac97_read_command(ssi_mod module, bool state)
+{
+	unsigned int reg = 0;
+
+	reg = getreg_value(MXC_SSISACNT, module);
+	if (state == true) {
+		reg |= (1 << AC97_READ_COMMAND_SHIFT);
+	} else {
+		reg &= ~(1 << AC97_READ_COMMAND_SHIFT);
+	}
+
+	set_register(reg, MXC_SSISACNT, module);
+}
+
+/*!
+ * This function sets the AC97 command address register.
+ *
+ * @param        module        the module number
+ * @param        address       the command address slot information
+ */
+void ssi_ac97_set_command_address_register(ssi_mod module, unsigned int address)
+{
+	set_register(address, MXC_SSISACADD, module);
+}
+
+/*!
+ * This function sets the AC97 command data register.
+ *
+ * @param        module        the module number
+ * @param        data          the command data slot information
+ */
+void ssi_ac97_set_command_data_register(ssi_mod module, unsigned int data)
+{
+	set_register(data, MXC_SSISACDAT, module);
+}
+
+/*!
+ * This function sets the AC97 tag register.
+ *
+ * @param        module        the module number
+ * @param        tag           the tag information
+ */
+void ssi_ac97_set_tag_register(ssi_mod module, unsigned int tag)
+{
+	set_register(tag, MXC_SSISATAG, module);
+}
+
+/*!
+ * This function controls the AC97 variable mode.
+ *
+ * @param        module        the module number
+ * @param        state         the AC97 variable mode state (enabled or disabled)
+ */ void ssi_ac97_variable_mode(ssi_mod module, bool state)
+{
+	unsigned int reg = 0;
+
+	reg = getreg_value(MXC_SSISACNT, module);
+	if (state == true) {
+		reg |= (1 << AC97_VARIABLE_OPERATION_SHIFT);
+	} else {
+		reg &= ~(1 << AC97_VARIABLE_OPERATION_SHIFT);
+	}
+
+	set_register(reg, MXC_SSISACNT, module);
+}
+
+/*!
+ * This function controls the AC97 write command.
+ *
+ * @param        module        the module number
+ * @param        state         the next AC97 command is a write command or not
+ */
+void ssi_ac97_write_command(ssi_mod module, bool state)
+{
+	unsigned int reg = 0;
+
+	reg = getreg_value(MXC_SSISACNT, module);
+	if (state == true) {
+		reg |= (1 << AC97_WRITE_COMMAND_SHIFT);
+	} else {
+		reg &= ~(1 << AC97_WRITE_COMMAND_SHIFT);
+	}
+
+	set_register(reg, MXC_SSISACNT, module);
+}
+
+/*!
+ * This function controls the idle state of the transmit clock port during SSI internal gated mode.
+ *
+ * @param        module        the module number
+ * @param        state         the clock idle state
+ */
+void ssi_clock_idle_state(ssi_mod module, idle_state state)
+{
+	set_register_bits(1 << SSI_CLOCK_IDLE_SHIFT,
+			  state << SSI_CLOCK_IDLE_SHIFT, MXC_SSISCR, module);
+}
+
+/*!
+ * This function turns off/on the ccm_ssi_clk to reduce power consumption.
+ *
+ * @param        module        the module number
+ * @param        state         the state for ccm_ssi_clk (true: turn off, else:turn on)
+ */
+void ssi_clock_off(ssi_mod module, bool state)
+{
+	set_register_bits(1 << SSI_CLOCK_OFF_SHIFT,
+			  state << SSI_CLOCK_OFF_SHIFT, MXC_SSISOR, module);
+}
+
+/*!
+ * This function enables/disables the SSI module.
+ *
+ * @param        module        the module number
+ * @param        state         the state for SSI module
+ */
+void ssi_enable(ssi_mod module, bool state)
+{
+	set_register_bits(1 << SSI_ENABLE_SHIFT, state << SSI_ENABLE_SHIFT,
+			  MXC_SSISCR, module);
+}
+
+/*!
+ * This function gets the data word in the Receive FIFO of the SSI module.
+ *
+ * @param        module        the module number
+ * @param        fifo          the Receive FIFO to read
+ * @return       This function returns the read data.
+ */
+unsigned int ssi_get_data(ssi_mod module, fifo_nb fifo)
+{
+	unsigned int result = 0;
+
+	if (ssi_fifo_0 == fifo) {
+		result = getreg_value(MXC_SSISRX0, module);
+	} else {
+		result = getreg_value(MXC_SSISRX1, module);
+	}
+
+	return result;
+}
+
+/*!
+ * This function returns the status of the SSI module (SISR register) as a combination of status.
+ *
+ * @param        module        the module number
+ * @return       This function returns the status of the SSI module
+ */
+ssi_status_enable_mask ssi_get_status(ssi_mod module)
+{
+	unsigned int result;
+
+	result = getreg_value(MXC_SSISISR, module);
+	result &= ((1 << SSI_IRQ_STATUS_NUMBER) - 1);
+
+	return (ssi_status_enable_mask) result;
+}
+
+/*!
+ * This function selects the I2S mode of the SSI module.
+ *
+ * @param        module        the module number
+ * @param        mode          the I2S mode
+ */
+void ssi_i2s_mode(ssi_mod module, mode_i2s mode)
+{
+	set_register_bits(3 << SSI_I2S_MODE_SHIFT, mode << SSI_I2S_MODE_SHIFT,
+			  MXC_SSISCR, module);
+}
+
+/*!
+ * This function disables the interrupts of the SSI module.
+ *
+ * @param        module        the module number
+ * @param        mask          the mask of the interrupts to disable
+ */
+void ssi_interrupt_disable(ssi_mod module, ssi_status_enable_mask mask)
+{
+	set_register_bits(mask, 0, MXC_SSISIER, module);
+}
+
+/*!
+ * This function enables the interrupts of the SSI module.
+ *
+ * @param        module        the module number
+ * @param        mask          the mask of the interrupts to enable
+ */
+void ssi_interrupt_enable(ssi_mod module, ssi_status_enable_mask mask)
+{
+	set_register_bits(0, mask, MXC_SSISIER, module);
+}
+
+/*!
+ * This function enables/disables the network mode of the SSI module.
+ *
+ * @param        module        the module number
+ * @param        state         the network mode state
+ */
+void ssi_network_mode(ssi_mod module, bool state)
+{
+	set_register_bits(1 << SSI_NETWORK_MODE_SHIFT,
+			  state << SSI_NETWORK_MODE_SHIFT, MXC_SSISCR, module);
+}
+
+/*!
+ * This function enables/disables the receive section of the SSI module.
+ *
+ * @param        module        the module number
+ * @param        state         the receive section state
+ */
+void ssi_receive_enable(ssi_mod module, bool state)
+{
+	set_register_bits(1 << SSI_RECEIVE_ENABLE_SHIFT,
+			  state << SSI_RECEIVE_ENABLE_SHIFT, MXC_SSISCR,
+			  module);
+}
+
+/*!
+ * This function configures the SSI module to receive data word at bit position 0 or 23 in the Receive shift register.
+ *
+ * @param        module        the module number
+ * @param        state         the state to receive at bit 0
+ */
+void ssi_rx_bit0(ssi_mod module, bool state)
+{
+	set_register_bits(1 << SSI_BIT_0_SHIFT, state << SSI_BIT_0_SHIFT,
+			  MXC_SSISRCR, module);
+}
+
+/*!
+ * This function controls the source of the clock signal used to clock the Receive shift register.
+ *
+ * @param        module        the module number
+ * @param        direction     the clock signal direction
+ */
+void ssi_rx_clock_direction(ssi_mod module, ssi_tx_rx_direction direction)
+{
+	set_register_bits(1 << SSI_CLOCK_DIRECTION_SHIFT,
+			  direction << SSI_CLOCK_DIRECTION_SHIFT, MXC_SSISRCR,
+			  module);
+}
+
+/*!
+ * This function configures the divide-by-two divider of the SSI module for the receive section.
+ *
+ * @param        module        the module number
+ * @param        state         the divider state
+ */
+void ssi_rx_clock_divide_by_two(ssi_mod module, bool state)
+{
+	set_register_bits(1 << SSI_DIVIDE_BY_TWO_SHIFT,
+			  state << SSI_DIVIDE_BY_TWO_SHIFT, MXC_SSISRCCR,
+			  module);
+}
+
+/*!
+ * This function controls which bit clock edge is used to clock in data.
+ *
+ * @param        module        the module number
+ * @param        polarity      the clock polarity
+ */
+void ssi_rx_clock_polarity(ssi_mod module, ssi_tx_rx_clock_polarity polarity)
+{
+	set_register_bits(1 << SSI_CLOCK_POLARITY_SHIFT,
+			  polarity << SSI_CLOCK_POLARITY_SHIFT, MXC_SSISRCR,
+			  module);
+}
+
+/*!
+ * This function configures a fixed divide-by-eight clock prescaler divider of the SSI module in series with the variable prescaler for the receive section.
+ *
+ * @param        module        the module number
+ * @param        state         the prescaler state
+ */
+void ssi_rx_clock_prescaler(ssi_mod module, bool state)
+{
+	set_register_bits(1 << SSI_PRESCALER_RANGE_SHIFT,
+			  state << SSI_PRESCALER_RANGE_SHIFT,
+			  MXC_SSISRCCR, module);
+}
+
+/*!
+ * This function controls the early frame sync configuration.
+ *
+ * @param        module        the module number
+ * @param        early         the early frame sync configuration
+ */
+void ssi_rx_early_frame_sync(ssi_mod module, ssi_tx_rx_early_frame_sync early)
+{
+	set_register_bits(1 << SSI_EARLY_FRAME_SYNC_SHIFT,
+			  early << SSI_EARLY_FRAME_SYNC_SHIFT,
+			  MXC_SSISRCR, module);
+}
+
+/*!
+ * This function gets the number of data words in the Receive FIFO.
+ *
+ * @param        module        the module number
+ * @param        fifo          the fifo
+ * @return       This function returns the number of words in the Rx FIFO.
+ */
+unsigned char ssi_rx_fifo_counter(ssi_mod module, fifo_nb fifo)
+{
+	unsigned long result;
+	result = 0;
+
+	if (ssi_fifo_0 == fifo) {
+		result = getreg_value(MXC_SSISFCSR, module);
+		result &= (0xF << SSI_RX_FIFO_0_COUNT_SHIFT);
+		result = result >> SSI_RX_FIFO_0_COUNT_SHIFT;
+	} else {
+		result = getreg_value(MXC_SSISFCSR, module);
+		result &= (0xF << SSI_RX_FIFO_1_COUNT_SHIFT);
+		result = result >> SSI_RX_FIFO_1_COUNT_SHIFT;
+	}
+
+	return result;
+}
+
+/*!
+ * This function enables the Receive FIFO.
+ *
+ * @param        module        the module number
+ * @param        fifo          the fifo to enable
+ * @param        enable        the state of the fifo, enabled or disabled
+ */
+
+void ssi_rx_fifo_enable(ssi_mod module, fifo_nb fifo, bool enable)
+{
+	volatile unsigned int reg;
+
+	reg = getreg_value(MXC_SSISRCR, module);
+	if (enable == true) {
+		reg |= ((1 + fifo) << SSI_FIFO_ENABLE_0_SHIFT);
+	} else {
+		reg &= ~((1 + fifo) << SSI_FIFO_ENABLE_0_SHIFT);
+	}
+
+	set_register(reg, MXC_SSISRCR, module);
+}
+
+/*!
+ * This function controls the threshold at which the RFFx flag will be set.
+ *
+ * @param        module        the module number
+ * @param        fifo          the fifo to enable
+ * @param        watermark     the watermark
+ * @return       This function returns the result of the operation (0 if successful, -1 otherwise).
+ */
+int ssi_rx_fifo_full_watermark(ssi_mod module,
+			       fifo_nb fifo, unsigned char watermark)
+{
+	int result = -1;
+	result = -1;
+
+	if ((watermark > SSI_MIN_FIFO_WATERMARK) &&
+	    (watermark <= SSI_MAX_FIFO_WATERMARK)) {
+		if (ssi_fifo_0 == fifo) {
+			set_register_bits(0xf << SSI_RX_FIFO_0_WATERMARK_SHIFT,
+					  watermark <<
+					  SSI_RX_FIFO_0_WATERMARK_SHIFT,
+					  MXC_SSISFCSR, module);
+		} else {
+			set_register_bits(0xf << SSI_RX_FIFO_1_WATERMARK_SHIFT,
+					  watermark <<
+					  SSI_RX_FIFO_1_WATERMARK_SHIFT,
+					  MXC_SSISFCSR, module);
+		}
+
+		result = 0;
+	}
+
+	return result;
+}
+
+/*!
+ * This function flushes the Receive FIFOs.
+ *
+ * @param        module        the module number
+ */
+void ssi_rx_flush_fifo(ssi_mod module)
+{
+	set_register_bits(0, 1 << SSI_RECEIVER_CLEAR_SHIFT, MXC_SSISOR, module);
+}
+
+/*!
+ * This function controls the direction of the Frame Sync signal for the receive section.
+ *
+ * @param        module        the module number
+ * @param        direction     the Frame Sync signal direction
+ */
+void ssi_rx_frame_direction(ssi_mod module, ssi_tx_rx_direction direction)
+{
+	set_register_bits(1 << SSI_FRAME_DIRECTION_SHIFT,
+			  direction << SSI_FRAME_DIRECTION_SHIFT,
+			  MXC_SSISRCR, module);
+}
+
+/*!
+ * This function configures the Receive frame rate divider for the receive section.
+ *
+ * @param        module        the module number
+ * @param        ratio         the divide ratio from 1 to 32
+ * @return       This function returns the result of the operation (0 if successful, -1 otherwise).
+ */
+int ssi_rx_frame_rate(ssi_mod module, unsigned char ratio)
+{
+	int result = -1;
+
+	if ((ratio >= SSI_MIN_FRAME_DIVIDER_RATIO) &&
+	    (ratio <= SSI_MAX_FRAME_DIVIDER_RATIO)) {
+		set_register_bits(SSI_FRAME_DIVIDER_MASK <<
+				  SSI_FRAME_RATE_DIVIDER_SHIFT,
+				  (ratio - 1) << SSI_FRAME_RATE_DIVIDER_SHIFT,
+				  MXC_SSISRCCR, module);
+		result = 0;
+	}
+
+	return result;
+}
+
+/*!
+ * This function controls the Frame Sync active polarity for the receive section.
+ *
+ * @param        module        the module number
+ * @param        active        the Frame Sync active polarity
+ */
+void ssi_rx_frame_sync_active(ssi_mod module,
+			      ssi_tx_rx_frame_sync_active active)
+{
+	set_register_bits(1 << SSI_FRAME_SYNC_INVERT_SHIFT,
+			  active << SSI_FRAME_SYNC_INVERT_SHIFT,
+			  MXC_SSISRCR, module);
+}
+
+/*!
+ * This function controls the Frame Sync length (one word or one bit long) for the receive section.
+ *
+ * @param        module        the module number
+ * @param        length        the Frame Sync length
+ */
+void ssi_rx_frame_sync_length(ssi_mod module,
+			      ssi_tx_rx_frame_sync_length length)
+{
+	set_register_bits(1 << SSI_FRAME_SYNC_LENGTH_SHIFT,
+			  length << SSI_FRAME_SYNC_LENGTH_SHIFT,
+			  MXC_SSISRCR, module);
+}
+
+/*!
+ * This function configures the time slot(s) to mask for the receive section.
+ *
+ * @param        module        the module number
+ * @param        mask          the mask to indicate the time slot(s) masked
+ */
+void ssi_rx_mask_time_slot(ssi_mod module, unsigned int mask)
+{
+	set_register_bits(0xFFFFFFFF, mask, MXC_SSISRMSK, module);
+}
+
+/*!
+ * This function configures the Prescale divider for the receive section.
+ *
+ * @param        module        the module number
+ * @param        divider       the divide ratio from 1 to  256
+ * @return       This function returns the result of the operation (0 if successful, -1 otherwise).
+ */
+int ssi_rx_prescaler_modulus(ssi_mod module, unsigned int divider)
+{
+	int result = -1;
+
+	if ((divider >= SSI_MIN_PRESCALER_MODULUS_RATIO) &&
+	    (divider <= SSI_MAX_PRESCALER_MODULUS_RATIO)) {
+
+		set_register_bits(SSI_PRESCALER_MODULUS_MASK <<
+				  SSI_PRESCALER_MODULUS_SHIFT,
+				  (divider - 1) << SSI_PRESCALER_MODULUS_SHIFT,
+				  MXC_SSISRCCR, module);
+		result = 0;
+	}
+
+	return result;
+}
+
+/*!
+ * This function controls whether the MSB or LSB will be received first in a sample.
+ *
+ * @param        module        the module number
+ * @param        direction     the shift direction
+ */
+void ssi_rx_shift_direction(ssi_mod module, ssi_tx_rx_shift_direction direction)
+{
+	set_register_bits(1 << SSI_SHIFT_DIRECTION_SHIFT,
+			  direction << SSI_SHIFT_DIRECTION_SHIFT,
+			  MXC_SSISRCR, module);
+}
+
+/*!
+ * This function configures the Receive word length.
+ *
+ * @param        module        the module number
+ * @param        length        the word length
+ */
+void ssi_rx_word_length(ssi_mod module, ssi_word_length length)
+{
+	set_register_bits(SSI_WORD_LENGTH_MASK << SSI_WORD_LENGTH_SHIFT,
+			  length << SSI_WORD_LENGTH_SHIFT,
+			  MXC_SSISRCCR, module);
+}
+
+/*!
+ * This function sets the data word in the Transmit FIFO of the SSI module.
+ *
+ * @param        module        the module number
+ * @param        fifo          the FIFO number
+ * @param        data          the data to load in the FIFO
+ */
+
+void ssi_set_data(ssi_mod module, fifo_nb fifo, unsigned int data)
+{
+	if (ssi_fifo_0 == fifo) {
+		set_register(data, MXC_SSISTX0, module);
+	} else {
+		set_register(data, MXC_SSISTX1, module);
+	}
+}
+
+/*!
+ * This function controls the number of wait states between the core and SSI.
+ *
+ * @param        module        the module number
+ * @param        wait          the number of wait state(s)
+ */
+void ssi_set_wait_states(ssi_mod module, ssi_wait_states wait)
+{
+	set_register_bits(SSI_WAIT_STATE_MASK << SSI_WAIT_SHIFT,
+			  wait << SSI_WAIT_SHIFT, MXC_SSISOR, module);
+}
+
+/*!
+ * This function enables/disables the synchronous mode of the SSI module.
+ *
+ * @param        module        the module number
+ * @param        state         the synchronous mode state
+ */
+void ssi_synchronous_mode(ssi_mod module, bool state)
+{
+	set_register_bits(1 << SSI_SYNCHRONOUS_MODE_SHIFT,
+			  state << SSI_SYNCHRONOUS_MODE_SHIFT,
+			  MXC_SSISCR, module);
+}
+
+/*!
+ * This function allows the SSI module to output the SYS_CLK at the SRCK port.
+ *
+ * @param        module        the module number
+ * @param        state         the system clock state
+ */
+void ssi_system_clock(ssi_mod module, bool state)
+{
+	set_register_bits(1 << SSI_SYSTEM_CLOCK_SHIFT,
+			  state << SSI_SYSTEM_CLOCK_SHIFT, MXC_SSISCR, module);
+}
+
+/*!
+ * This function enables/disables the transmit section of the SSI module.
+ *
+ * @param        module        the module number
+ * @param        state         the transmit section state
+ */
+void ssi_transmit_enable(ssi_mod module, bool state)
+{
+	set_register_bits(1 << SSI_TRANSMIT_ENABLE_SHIFT,
+			  state << SSI_TRANSMIT_ENABLE_SHIFT,
+			  MXC_SSISCR, module);
+}
+
+/*!
+ * This function allows the SSI module to operate in the two channel mode.
+ *
+ * @param        module        the module number
+ * @param        state         the two channel mode state
+ */
+void ssi_two_channel_mode(ssi_mod module, bool state)
+{
+	set_register_bits(1 << SSI_TWO_CHANNEL_SHIFT,
+			  state << SSI_TWO_CHANNEL_SHIFT, MXC_SSISCR, module);
+}
+
+/*!
+ * This function configures the SSI module to transmit data word from bit position 0 or 23 in the Transmit shift register.
+ *
+ * @param        module        the module number
+ * @param        state         the transmit from bit 0 state
+ */
+void ssi_tx_bit0(ssi_mod module, bool state)
+{
+	set_register_bits(1 << SSI_BIT_0_SHIFT,
+			  state << SSI_BIT_0_SHIFT, MXC_SSISTCR, module);
+}
+
+/*!
+ * This function controls the direction of the clock signal used to clock the Transmit shift register.
+ *
+ * @param        module        the module number
+ * @param        direction     the clock signal direction
+ */
+void ssi_tx_clock_direction(ssi_mod module, ssi_tx_rx_direction direction)
+{
+	set_register_bits(1 << SSI_CLOCK_DIRECTION_SHIFT,
+			  direction << SSI_CLOCK_DIRECTION_SHIFT,
+			  MXC_SSISTCR, module);
+}
+
+/*!
+ * This function configures the divide-by-two divider of the SSI module for the transmit section.
+ *
+ * @param        module        the module number
+ * @param        state         the divider state
+ */
+void ssi_tx_clock_divide_by_two(ssi_mod module, bool state)
+{
+	set_register_bits(1 << SSI_DIVIDE_BY_TWO_SHIFT,
+			  state << SSI_DIVIDE_BY_TWO_SHIFT,
+			  MXC_SSISTCCR, module);
+}
+
+/*!
+ * This function controls which bit clock edge is used to clock out data.
+ *
+ * @param        module        the module number
+ * @param        polarity      the clock polarity
+ */
+void ssi_tx_clock_polarity(ssi_mod module, ssi_tx_rx_clock_polarity polarity)
+{
+	set_register_bits(1 << SSI_CLOCK_POLARITY_SHIFT,
+			  polarity << SSI_CLOCK_POLARITY_SHIFT,
+			  MXC_SSISTCR, module);
+}
+
+/*!
+ * This function configures a fixed divide-by-eight clock prescaler divider of the SSI module in series with the variable prescaler for the transmit section.
+ *
+ * @param        module        the module number
+ * @param        state         the prescaler state
+ */
+void ssi_tx_clock_prescaler(ssi_mod module, bool state)
+{
+	set_register_bits(1 << SSI_PRESCALER_RANGE_SHIFT,
+			  state << SSI_PRESCALER_RANGE_SHIFT,
+			  MXC_SSISTCCR, module);
+}
+
+/*!
+ * This function controls the early frame sync configuration for the transmit section.
+ *
+ * @param        module        the module number
+ * @param        early         the early frame sync configuration
+ */
+void ssi_tx_early_frame_sync(ssi_mod module, ssi_tx_rx_early_frame_sync early)
+{
+	set_register_bits(1 << SSI_EARLY_FRAME_SYNC_SHIFT,
+			  early << SSI_EARLY_FRAME_SYNC_SHIFT,
+			  MXC_SSISTCR, module);
+}
+
+/*!
+ * This function gets the number of data words in the Transmit FIFO.
+ *
+ * @param        module        the module number
+ * @param        fifo          the fifo
+ * @return       This function returns the number of words in the Tx FIFO.
+ */
+unsigned char ssi_tx_fifo_counter(ssi_mod module, fifo_nb fifo)
+{
+	unsigned long result = 0;
+
+	if (ssi_fifo_0 == fifo) {
+		result = getreg_value(MXC_SSISFCSR, module);
+		result &= (0xF << SSI_TX_FIFO_0_COUNT_SHIFT);
+		result >>= SSI_TX_FIFO_0_COUNT_SHIFT;
+	} else {
+		result = getreg_value(MXC_SSISFCSR, module);
+		result &= (0xF << SSI_TX_FIFO_1_COUNT_SHIFT);
+		result >>= SSI_TX_FIFO_1_COUNT_SHIFT;
+	}
+
+	return result;
+}
+
+/*!
+ * This function controls the threshold at which the TFEx flag will be set.
+ *
+ * @param        module        the module number
+ * @param        fifo          the fifo to enable
+ * @param        watermark     the watermark
+ * @return       This function returns the result of the operation (0 if successful, -1 otherwise).
+ */
+int ssi_tx_fifo_empty_watermark(ssi_mod module,
+				fifo_nb fifo, unsigned char watermark)
+{
+	int result = -1;
+
+	if ((watermark > SSI_MIN_FIFO_WATERMARK) &&
+	    (watermark <= SSI_MAX_FIFO_WATERMARK)) {
+		if (ssi_fifo_0 == fifo) {
+			set_register_bits(0xf << SSI_TX_FIFO_0_WATERMARK_SHIFT,
+					  watermark <<
+					  SSI_TX_FIFO_0_WATERMARK_SHIFT,
+					  MXC_SSISFCSR, module);
+		} else {
+			set_register_bits(0xf << SSI_TX_FIFO_1_WATERMARK_SHIFT,
+					  watermark <<
+					  SSI_TX_FIFO_1_WATERMARK_SHIFT,
+					  MXC_SSISFCSR, module);
+		}
+
+		result = 0;
+	}
+
+	return result;
+}
+
+/*!
+ * This function enables the Transmit FIFO.
+ *
+ * @param        module        the module number
+ * @param        fifo          the fifo to enable
+ * @param        enable        the state of the fifo, enabled or disabled
+ */
+
+void ssi_tx_fifo_enable(ssi_mod module, fifo_nb fifo, bool enable)
+{
+	unsigned int reg;
+
+	reg = getreg_value(MXC_SSISTCR, module);
+	if (enable == true) {
+		reg |= ((1 + fifo) << SSI_FIFO_ENABLE_0_SHIFT);
+	} else {
+		reg &= ~((1 + fifo) << SSI_FIFO_ENABLE_0_SHIFT);
+	}
+
+	set_register(reg, MXC_SSISTCR, module);
+}
+
+/*!
+ * This function flushes the Transmit FIFOs.
+ *
+ * @param        module        the module number
+ */
+void ssi_tx_flush_fifo(ssi_mod module)
+{
+	set_register_bits(0, 1 << SSI_TRANSMITTER_CLEAR_SHIFT,
+			  MXC_SSISOR, module);
+}
+
+/*!
+ * This function controls the direction of the Frame Sync signal for the transmit section.
+ *
+ * @param        module        the module number
+ * @param        direction     the Frame Sync signal direction
+ */
+void ssi_tx_frame_direction(ssi_mod module, ssi_tx_rx_direction direction)
+{
+	set_register_bits(1 << SSI_FRAME_DIRECTION_SHIFT,
+			  direction << SSI_FRAME_DIRECTION_SHIFT,
+			  MXC_SSISTCR, module);
+}
+
+/*!
+ * This function configures the Transmit frame rate divider.
+ *
+ * @param        module        the module number
+ * @param        ratio         the divide ratio from 1 to 32
+ * @return       This function returns the result of the operation (0 if successful, -1 otherwise).
+ */
+int ssi_tx_frame_rate(ssi_mod module, unsigned char ratio)
+{
+	int result = -1;
+
+	if ((ratio >= SSI_MIN_FRAME_DIVIDER_RATIO) &&
+	    (ratio <= SSI_MAX_FRAME_DIVIDER_RATIO)) {
+
+		set_register_bits(SSI_FRAME_DIVIDER_MASK <<
+				  SSI_FRAME_RATE_DIVIDER_SHIFT,
+				  (ratio - 1) << SSI_FRAME_RATE_DIVIDER_SHIFT,
+				  MXC_SSISTCCR, module);
+		result = 0;
+	}
+
+	return result;
+}
+
+/*!
+ * This function controls the Frame Sync active polarity for the transmit section.
+ *
+ * @param        module        the module number
+ * @param        active        the Frame Sync active polarity
+ */
+void ssi_tx_frame_sync_active(ssi_mod module,
+			      ssi_tx_rx_frame_sync_active active)
+{
+	set_register_bits(1 << SSI_FRAME_SYNC_INVERT_SHIFT,
+			  active << SSI_FRAME_SYNC_INVERT_SHIFT,
+			  MXC_SSISTCR, module);
+}
+
+/*!
+ * This function controls the Frame Sync length (one word or one bit long) for the transmit section.
+ *
+ * @param        module        the module number
+ * @param        length        the Frame Sync length
+ */
+void ssi_tx_frame_sync_length(ssi_mod module,
+			      ssi_tx_rx_frame_sync_length length)
+{
+	set_register_bits(1 << SSI_FRAME_SYNC_LENGTH_SHIFT,
+			  length << SSI_FRAME_SYNC_LENGTH_SHIFT,
+			  MXC_SSISTCR, module);
+}
+
+/*!
+ * This function configures the time slot(s) to mask for the transmit section.
+ *
+ * @param        module        the module number
+ * @param        mask          the mask to indicate the time slot(s) masked
+ */
+void ssi_tx_mask_time_slot(ssi_mod module, unsigned int mask)
+{
+	set_register_bits(0xFFFFFFFF, mask, MXC_SSISTMSK, module);
+}
+
+/*!
+ * This function configures the Prescale divider for the transmit section.
+ *
+ * @param        module        the module number
+ * @param        divider       the divide ratio from 1 to  256
+ * @return       This function returns the result of the operation (0 if successful, -1 otherwise).
+ */
+int ssi_tx_prescaler_modulus(ssi_mod module, unsigned int divider)
+{
+	int result = -1;
+
+	if ((divider >= SSI_MIN_PRESCALER_MODULUS_RATIO) &&
+	    (divider <= SSI_MAX_PRESCALER_MODULUS_RATIO)) {
+
+		set_register_bits(SSI_PRESCALER_MODULUS_MASK <<
+				  SSI_PRESCALER_MODULUS_SHIFT,
+				  (divider - 1) << SSI_PRESCALER_MODULUS_SHIFT,
+				  MXC_SSISTCCR, module);
+		result = 0;
+	}
+
+	return result;
+}
+
+/*!
+ * This function controls whether the MSB or LSB will be transmitted first in a sample.
+ *
+ * @param        module        the module number
+ * @param        direction     the shift direction
+ */
+void ssi_tx_shift_direction(ssi_mod module, ssi_tx_rx_shift_direction direction)
+{
+	set_register_bits(1 << SSI_SHIFT_DIRECTION_SHIFT,
+			  direction << SSI_SHIFT_DIRECTION_SHIFT,
+			  MXC_SSISTCR, module);
+}
+
+/*!
+ * This function configures the Transmit word length.
+ *
+ * @param        module        the module number
+ * @param        length        the word length
+ */
+void ssi_tx_word_length(ssi_mod module, ssi_word_length length)
+{
+	set_register_bits(SSI_WORD_LENGTH_MASK << SSI_WORD_LENGTH_SHIFT,
+			  length << SSI_WORD_LENGTH_SHIFT,
+			  MXC_SSISTCCR, module);
+}
+
+/*!
+ * This function implements the init function of the SSI device.
+ * This function is called when the module is loaded.
+ *
+ * @return       This function returns 0.
+ */
+static int __init ssi_init(void)
+{
+	spin_lock_init(&ssi_lock);
+	printk(KERN_INFO "SSI module loaded successfully\n");
+	return 0;
+}
+
+/*!
+ * This function implements the exit function of the SPI device.
+ * This function is called when the module is unloaded.
+ *
+ */
+static void __exit ssi_exit(void)
+{
+	printk(KERN_INFO "SSI module unloaded successfully\n");
+}
+
+module_init(ssi_init);
+module_exit(ssi_exit);
+
+MODULE_DESCRIPTION("SSI char device driver");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
Index: linux-2.6.18/drivers/mxc/ssi/ssi.h
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/mxc/ssi/ssi.h
@@ -0,0 +1,565 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+ /*!
+  * @defgroup SSI Synchronous Serial Interface (SSI) Driver
+  */
+
+ /*!
+  * @file ssi.h
+  * @brief This header file contains SSI driver functions prototypes.
+  *
+  * @ingroup SSI
+  */
+
+#ifndef __MXC_SSI_H__
+#define __MXC_SSI_H__
+
+#include "ssi_types.h"
+
+/*!
+ * This function controls the AC97 frame rate divider.
+ *
+ * @param        module               the module number
+ * @param        frame_rate_divider   the AC97 frame rate divider
+ */
+void ssi_ac97_frame_rate_divider(ssi_mod module,
+				 unsigned char frame_rate_divider);
+
+/*!
+ * This function gets the AC97 command address register.
+ *
+ * @param        module        the module number
+ * @return       This function returns the command address slot information.
+ */
+unsigned int ssi_ac97_get_command_address_register(ssi_mod module);
+
+/*!
+ * This function gets the AC97 command data register.
+ *
+ * @param        module        the module number
+ * @return       This function returns the command data slot information.
+ */
+unsigned int ssi_ac97_get_command_data_register(ssi_mod module);
+
+/*!
+ * This function gets the AC97 tag register.
+ *
+ * @param        module        the module number
+ * @return       This function returns the tag information.
+ */
+unsigned int ssi_ac97_get_tag_register(ssi_mod module);
+
+/*!
+ * This function controls the AC97 mode.
+ *
+ * @param        module        the module number
+ * @param        state         the AC97 mode state (enabled or disabled)
+ */
+void ssi_ac97_mode_enable(ssi_mod module, bool state);
+
+/*!
+ * This function controls the AC97 tag in FIFO behavior.
+ *
+ * @param        module        the module number
+ * @param        state         the tag in fifo behavior (Tag info stored in Rx FIFO 0 if TRUE,
+ * Tag info stored in SATAG register otherwise)
+ */
+void ssi_ac97_tag_in_fifo(ssi_mod module, bool state);
+
+/*!
+ * This function controls the AC97 read command.
+ *
+ * @param        module        the module number
+ * @param        state         the next AC97 command is a read command or not
+ */
+void ssi_ac97_read_command(ssi_mod module, bool state);
+
+/*!
+ * This function sets the AC97 command address register.
+ *
+ * @param        module        the module number
+ * @param        address       the command address slot information
+ */
+void ssi_ac97_set_command_address_register(ssi_mod module,
+					   unsigned int address);
+
+/*!
+ * This function sets the AC97 command data register.
+ *
+ * @param        module        the module number
+ * @param        data          the command data slot information
+ */
+void ssi_ac97_set_command_data_register(ssi_mod module, unsigned int data);
+
+/*!
+ * This function sets the AC97 tag register.
+ *
+ * @param        module        the module number
+ * @param        tag           the tag information
+ */
+void ssi_ac97_set_tag_register(ssi_mod module, unsigned int tag);
+
+/*!
+ * This function controls the AC97 variable mode.
+ *
+ * @param        module        the module number
+ * @param        state         the AC97 variable mode state (enabled or disabled)
+ */
+void ssi_ac97_variable_mode(ssi_mod module, bool state);
+
+/*!
+ * This function controls the AC97 write command.
+ *
+ * @param        module        the module number
+ * @param        state         the next AC97 command is a write command or not
+ */
+void ssi_ac97_write_command(ssi_mod module, bool state);
+
+/*!
+ * This function controls the idle state of the transmit clock port during SSI internal gated mode.
+ *
+ * @param        module        the module number
+ * @param        state         the clock idle state
+ */
+void ssi_clock_idle_state(ssi_mod module, idle_state state);
+
+/*!
+ * This function turns off/on the ccm_ssi_clk to reduce power consumption.
+ *
+ * @param        module        the module number
+ * @param        state         the state for ccm_ssi_clk (true: turn off, else:turn on)
+ */
+void ssi_clock_off(ssi_mod module, bool state);
+
+/*!
+ * This function enables/disables the SSI module.
+ *
+ * @param        module        the module number
+ * @param        state         the state for SSI module
+ */
+void ssi_enable(ssi_mod module, bool state);
+
+/*!
+ * This function gets the data word in the Receive FIFO of the SSI module.
+ *
+ * @param        module        the module number
+ * @param        fifo          the Receive FIFO to read
+ * @return       This function returns the read data.
+ */
+unsigned int ssi_get_data(ssi_mod module, fifo_nb fifo);
+
+/*!
+ * This function returns the status of the SSI module (SISR register) as a combination of status.
+ *
+ * @param        module        the module number
+ * @return       This function returns the status of the SSI module.
+ */
+ssi_status_enable_mask ssi_get_status(ssi_mod module);
+
+/*!
+ * This function selects the I2S mode of the SSI module.
+ *
+ * @param        module        the module number
+ * @param        mode          the I2S mode
+ */
+void ssi_i2s_mode(ssi_mod module, mode_i2s mode);
+
+/*!
+ * This function disables the interrupts of the SSI module.
+ *
+ * @param        module        the module number
+ * @param        mask          the mask of the interrupts to disable
+ */
+void ssi_interrupt_disable(ssi_mod module, ssi_status_enable_mask mask);
+
+/*!
+ * This function enables the interrupts of the SSI module.
+ *
+ * @param        module        the module number
+ * @param        mask          the mask of the interrupts to enable
+ */
+void ssi_interrupt_enable(ssi_mod module, ssi_status_enable_mask mask);
+
+/*!
+ * This function enables/disables the network mode of the SSI module.
+ *
+ * @param        module        the module number
+ * @param        state         the network mode state
+ */
+void ssi_network_mode(ssi_mod module, bool state);
+
+/*!
+ * This function enables/disables the receive section of the SSI module.
+ *
+ * @param        module        the module number
+ * @param        state         the receive section state
+ */
+void ssi_receive_enable(ssi_mod module, bool state);
+
+/*!
+ * This function configures the SSI module to receive data word at bit position 0 or 23 in the Receive shift register.
+ *
+ * @param        module        the module number
+ * @param        state         the state to receive at bit 0
+ */
+void ssi_rx_bit0(ssi_mod module, bool state);
+
+/*!
+ * This function controls the source of the clock signal used to clock the Receive shift register.
+ *
+ * @param        module        the module number
+ * @param        direction     the clock signal direction
+ */
+void ssi_rx_clock_direction(ssi_mod module, ssi_tx_rx_direction direction);
+
+/*!
+ * This function configures the divide-by-two divider of the SSI module for the receive section.
+ *
+ * @param        module        the module number
+ * @param        state         the divider state
+ */
+void ssi_rx_clock_divide_by_two(ssi_mod module, bool state);
+
+/*!
+ * This function controls which bit clock edge is used to clock in data.
+ *
+ * @param        module        the module number
+ * @param        polarity      the clock polarity
+ */
+void ssi_rx_clock_polarity(ssi_mod module, ssi_tx_rx_clock_polarity polarity);
+
+/*!
+ * This function configures a fixed divide-by-eight clock prescaler divider of the SSI module in series with the variable prescaler for the receive section.
+ *
+ * @param        module        the module number
+ * @param        state         the prescaler state
+ */
+void ssi_rx_clock_prescaler(ssi_mod module, bool state);
+
+/*!
+ * This function controls the early frame sync configuration.
+ *
+ * @param        module        the module number
+ * @param        early         the early frame sync configuration
+ */
+void ssi_rx_early_frame_sync(ssi_mod module, ssi_tx_rx_early_frame_sync early);
+
+/*!
+ * This function gets the number of data words in the Receive FIFO.
+ *
+ * @param        module        the module number
+ * @param        fifo          the fifo
+ * @return       This function returns the number of words in the Rx FIFO.
+ */
+unsigned char ssi_rx_fifo_counter(ssi_mod module, fifo_nb fifo);
+
+/*!
+ * This function enables the Receive FIFO.
+ *
+ * @param        module        the module number
+ * @param        fifo          the fifo to enable
+ * @param        enabled       the state of the fifo, enabled or disabled
+ */
+void ssi_rx_fifo_enable(ssi_mod module, fifo_nb fifo, bool enabled);
+
+/*!
+ * This function controls the threshold at which the RFFx flag will be set.
+ *
+ * @param        module        the module number
+ * @param        fifo          the fifo to enable
+ * @param        watermark     the watermark
+ * @return       This function returns the result of the operation (0 if successful, -1 otherwise).
+ */
+int ssi_rx_fifo_full_watermark(ssi_mod module,
+			       fifo_nb fifo, unsigned char watermark);
+
+/*!
+ * This function flushes the Receive FIFOs.
+ *
+ * @param        module        the module number
+ */
+void ssi_rx_flush_fifo(ssi_mod module);
+
+/*!
+ * This function controls the direction of the Frame Sync signal for the receive section.
+ *
+ * @param        module        the module number
+ * @param        direction     the Frame Sync signal direction
+ */
+void ssi_rx_frame_direction(ssi_mod module, ssi_tx_rx_direction direction);
+
+/*!
+ * This function configures the Receive frame rate divider for the receive section.
+ *
+ * @param        module        the module number
+ * @param        ratio         the divide ratio from 1 to 32
+ * @return       This function returns the result of the operation (0 if successful, -1 otherwise).
+ */
+int ssi_rx_frame_rate(ssi_mod module, unsigned char ratio);
+
+/*!
+ * This function controls the Frame Sync active polarity for the receive section.
+ *
+ * @param        module        the module number
+ * @param        active        the Frame Sync active polarity
+ */
+void ssi_rx_frame_sync_active(ssi_mod module,
+			      ssi_tx_rx_frame_sync_active active);
+
+/*!
+ * This function controls the Frame Sync length (one word or one bit long) for the receive section.
+ *
+ * @param        module        the module number
+ * @param        length        the Frame Sync length
+ */
+void ssi_rx_frame_sync_length(ssi_mod module,
+			      ssi_tx_rx_frame_sync_length length);
+
+/*!
+ * This function configures the time slot(s) to mask for the receive section.
+ *
+ * @param        module        the module number
+ * @param        mask          the mask to indicate the time slot(s) masked
+ */
+void ssi_rx_mask_time_slot(ssi_mod module, unsigned int mask);
+
+/*!
+ * This function configures the Prescale divider for the receive section.
+ *
+ * @param        module        the module number
+ * @param        divider       the divide ratio from 1 to  256
+ * @return       This function returns the result of the operation (0 if successful, -1 otherwise).
+ */
+int ssi_rx_prescaler_modulus(ssi_mod module, unsigned int divider);
+
+/*!
+ * This function controls whether the MSB or LSB will be received first in a sample.
+ *
+ * @param        module        the module number
+ * @param        direction     the shift direction
+ */
+void ssi_rx_shift_direction(ssi_mod module,
+			    ssi_tx_rx_shift_direction direction);
+
+/*!
+ * This function configures the Receive word length.
+ *
+ * @param        module        the module number
+ * @param        length        the word length
+ */
+void ssi_rx_word_length(ssi_mod module, ssi_word_length length);
+
+/*!
+ * This function sets the data word in the Transmit FIFO of the SSI module.
+ *
+ * @param        module        the module number
+ * @param        fifo          the FIFO number
+ * @param        data          the data to load in the FIFO
+ */
+void ssi_set_data(ssi_mod module, fifo_nb fifo, unsigned int data);
+
+/*!
+ * This function controls the number of wait states between the core and SSI.
+ *
+ * @param        module        the module number
+ * @param        wait          the number of wait state(s)
+ */
+void ssi_set_wait_states(ssi_mod module, ssi_wait_states wait);
+
+/*!
+ * This function enables/disables the synchronous mode of the SSI module.
+ *
+ * @param        module        the module number
+ * @param        state         the synchronous mode state
+ */
+void ssi_synchronous_mode(ssi_mod module, bool state);
+
+/*!
+ * This function allows the SSI module to output the SYS_CLK at the SRCK port.
+ *
+ * @param        module        the module number
+ * @param        state         the system clock state
+ */
+void ssi_system_clock(ssi_mod module, bool state);
+
+/*!
+ * This function enables/disables the transmit section of the SSI module.
+ *
+ * @param        module        the module number
+ * @param        state         the transmit section state
+ */
+void ssi_transmit_enable(ssi_mod module, bool state);
+
+/*!
+ * This function allows the SSI module to operate in the two channel mode.
+ *
+ * @param        module        the module number
+ * @param        state         the two channel mode state
+ */
+void ssi_two_channel_mode(ssi_mod module, bool state);
+
+/*!
+ * This function configures the SSI module to transmit data word from bit position 0 or 23 in the Transmit shift register.
+ *
+ * @param        module        the module number
+ * @param        state         the transmit from bit 0 state
+ */
+void ssi_tx_bit0(ssi_mod module, bool state);
+
+/*!
+ * This function controls the direction of the clock signal used to clock the Transmit shift register.
+ *
+ * @param        module        the module number
+ * @param        direction     the clock signal direction
+ */
+void ssi_tx_clock_direction(ssi_mod module, ssi_tx_rx_direction direction);
+
+/*!
+ * This function configures the divide-by-two divider of the SSI module for the transmit section.
+ *
+ * @param        module        the module number
+ * @param        state         the divider state
+ */
+void ssi_tx_clock_divide_by_two(ssi_mod module, bool state);
+
+/*!
+ * This function controls which bit clock edge is used to clock out data.
+ *
+ * @param        module        the module number
+ * @param        polarity      the clock polarity
+ */
+void ssi_tx_clock_polarity(ssi_mod module, ssi_tx_rx_clock_polarity polarity);
+
+/*!
+ * This function configures a fixed divide-by-eight clock prescaler divider of the SSI module in series with the variable prescaler for the transmit section.
+ *
+ * @param        module        the module number
+ * @param        state         the prescaler state
+ */
+void ssi_tx_clock_prescaler(ssi_mod module, bool state);
+
+/*!
+ * This function controls the early frame sync configuration for the transmit section.
+ *
+ * @param        module        the module number
+ * @param        early         the early frame sync configuration
+ */
+void ssi_tx_early_frame_sync(ssi_mod module, ssi_tx_rx_early_frame_sync early);
+
+/*!
+ * This function gets the number of data words in the Transmit FIFO.
+ *
+ * @param        module        the module number
+ * @param        fifo          the fifo
+ * @return       This function returns the number of words in the Tx FIFO.
+ */
+unsigned char ssi_tx_fifo_counter(ssi_mod module, fifo_nb fifo);
+
+/*!
+ * This function controls the threshold at which the TFEx flag will be set.
+ *
+ * @param        module        the module number
+ * @param        fifo          the fifo to enable
+ * @param        watermark     the watermark
+ * @return       This function returns the result of the operation (0 if successful, -1 otherwise).
+ */
+int ssi_tx_fifo_empty_watermark(ssi_mod module, fifo_nb fifo,
+				unsigned char watermark);
+
+/*!
+ * This function enables the Transmit FIFO.
+ *
+ * @param        module        the module number
+ * @param        fifo          the fifo to enable
+ * @param        enable        the state of the FIFO, enabled or disabled
+ */
+void ssi_tx_fifo_enable(ssi_mod module, fifo_nb fifo, bool enable);
+
+/*!
+ * This function flushes the Transmit FIFOs.
+ *
+ * @param        module        the module number
+ */
+void ssi_tx_flush_fifo(ssi_mod module);
+
+/*!
+ * This function controls the direction of the Frame Sync signal for the transmit section.
+ *
+ * @param        module        the module number
+ * @param        direction     the Frame Sync signal direction
+ */
+void ssi_tx_frame_direction(ssi_mod module, ssi_tx_rx_direction direction);
+
+/*!
+ * This function configures the Transmit frame rate divider.
+ *
+ * @param        module        the module number
+ * @param        ratio         the divide ratio from 1 to 32
+ * @return       This function returns the result of the operation (0 if successful, -1 otherwise).
+ */
+int ssi_tx_frame_rate(ssi_mod module, unsigned char ratio);
+
+/*!
+ * This function controls the Frame Sync active polarity for the transmit section.
+ *
+ * @param        module        the module number
+ * @param        active        the Frame Sync active polarity
+ */
+void ssi_tx_frame_sync_active(ssi_mod module,
+			      ssi_tx_rx_frame_sync_active active);
+
+/*!
+ * This function controls the Frame Sync length (one word or one bit long) for the transmit section.
+ *
+ * @param        module        the module number
+ * @param        length        the Frame Sync length
+ */
+void ssi_tx_frame_sync_length(ssi_mod module,
+			      ssi_tx_rx_frame_sync_length length);
+
+/*!
+ * This function configures the time slot(s) to mask for the transmit section.
+ *
+ * @param        module        the module number
+ * @param        mask          the mask to indicate the time slot(s) masked
+ */
+void ssi_tx_mask_time_slot(ssi_mod module, unsigned int mask);
+
+/*!
+ * This function configures the Prescale divider for the transmit section.
+ *
+ * @param        module        the module number
+ * @param        divider       the divide ratio from 1 to  256
+ * @return       This function returns the result of the operation (0 if successful, -1 otherwise).
+ */
+int ssi_tx_prescaler_modulus(ssi_mod module, unsigned int divider);
+
+/*!
+ * This function controls whether the MSB or LSB will be transmited first in a sample.
+ *
+ * @param        module        the module number
+ * @param        direction     the shift direction
+ */
+void ssi_tx_shift_direction(ssi_mod module,
+			    ssi_tx_rx_shift_direction direction);
+
+/*!
+ * This function configures the Transmit word length.
+ *
+ * @param        module        the module number
+ * @param        length        the word length
+ */
+void ssi_tx_word_length(ssi_mod module, ssi_word_length length);
+
+#endif				/* __MXC_SSI_H__ */
Index: linux-2.6.18/drivers/mxc/ssi/ssi_types.h
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/mxc/ssi/ssi_types.h
@@ -0,0 +1,359 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+ /*!
+  * @file ssi_types.h
+  * @brief This header file contains SSI types.
+  *
+  * @ingroup SSI
+  */
+
+#ifndef __MXC_SSI_TYPES_H__
+#define __MXC_SSI_TYPES_H__
+
+/*!
+ * This enumeration describes the FIFO number.
+ */
+typedef enum {
+	/*!
+	 * FIFO 0
+	 */
+	ssi_fifo_0 = 0,
+	/*!
+	 * FIFO 1
+	 */
+	ssi_fifo_1 = 1
+} fifo_nb;
+
+/*!
+ * This enumeration describes the clock idle state.
+ */
+typedef enum {
+	/*!
+	 * Clock idle state is 1
+	 */
+	clock_idle_state_1 = 0,
+	/*!
+	 * Clock idle state is 0
+	 */
+	clock_idle_state_0 = 1
+} idle_state;
+
+/*!
+ * This enumeration describes I2S mode.
+ */
+typedef enum {
+	/*!
+	 * Normal mode
+	 */
+	i2s_normal = 0,
+	/*!
+	 * Master mode
+	 */
+	i2s_master = 1,
+	/*!
+	 * Slave mode
+	 */
+	i2s_slave = 2
+} mode_i2s;
+
+/*!
+ * This enumeration describes index for both SSI1 and SSI2 modules.
+ */
+typedef enum {
+	/*!
+	 * SSI1 index
+	 */
+	SSI1 = 0,
+	/*!
+	 * SSI2 index
+	 */
+	SSI2 = 1
+} ssi_mod;
+
+/*!
+ * This enumeration describes the status/enable bits for interrupt source of the SSI module.
+ */
+typedef enum {
+	/*!
+	 * SSI Transmit FIFO 0 empty bit
+	 */
+	ssi_tx_fifo_0_empty = 0x00000001,
+	/*!
+	 * SSI Transmit FIFO 1 empty bit
+	 */
+	ssi_tx_fifo_1_empty = 0x00000002,
+	/*!
+	 * SSI Receive FIFO 0 full bit
+	 */
+	ssi_rx_fifo_0_full = 0x00000004,
+	/*!
+	 * SSI Receive FIFO 1 full bit
+	 */
+	ssi_rx_fifo_1_full = 0x00000008,
+	/*!
+	 * SSI Receive Last Time Slot bit
+	 */
+	ssi_rls = 0x00000010,
+	/*!
+	 * SSI Transmit Last Time Slot bit
+	 */
+	ssi_tls = 0x00000020,
+	/*!
+	 * SSI Receive Frame Sync bit
+	 */
+	ssi_rfs = 0x00000040,
+	/*!
+	 * SSI Transmit Frame Sync bit
+	 */
+	ssi_tfs = 0x00000080,
+	/*!
+	 * SSI Transmitter underrun 0 bit
+	 */
+	ssi_transmitter_underrun_0 = 0x00000100,
+	/*!
+	 * SSI Transmitter underrun 1 bit
+	 */
+	ssi_transmitter_underrun_1 = 0x00000200,
+	/*!
+	 * SSI Receiver overrun 0 bit
+	 */
+	ssi_receiver_overrun_0 = 0x00000400,
+	/*!
+	 * SSI Receiver overrun 1 bit
+	 */
+	ssi_receiver_overrun_1 = 0x00000800,
+	/*!
+	 * SSI Transmit Data register empty 0 bit
+	 */
+	ssi_tx_data_reg_empty_0 = 0x00001000,
+	/*!
+	 * SSI Transmit Data register empty 1 bit
+	 */
+	ssi_tx_data_reg_empty_1 = 0x00002000,
+
+	/*!
+	 * SSI Receive Data Ready 0 bit
+	 */
+	ssi_rx_data_ready_0 = 0x00004000,
+	/*!
+	 * SSI Receive Data Ready 1 bit
+	 */
+	ssi_rx_data_ready_1 = 0x00008000,
+	/*!
+	 * SSI Receive tag updated bit
+	 */
+	ssi_rx_tag_updated = 0x00010000,
+	/*!
+	 * SSI Command data register updated bit
+	 */
+	ssi_cmd_data_reg_updated = 0x00020000,
+	/*!
+	 * SSI Command address register updated bit
+	 */
+	ssi_cmd_address_reg_updated = 0x00040000,
+	/*!
+	 * SSI Transmit interrupt enable bit
+	 */
+	ssi_tx_interrupt_enable = 0x00080000,
+	/*!
+	 * SSI Transmit DMA enable bit
+	 */
+	ssi_tx_dma_interrupt_enable = 0x00100000,
+	/*!
+	 * SSI Receive interrupt enable bit
+	 */
+	ssi_rx_interrupt_enable = 0x00200000,
+	/*!
+	 * SSI Receive DMA enable bit
+	 */
+	ssi_rx_dma_interrupt_enable = 0x00400000
+} ssi_status_enable_mask;
+
+/*!
+ * This enumeration describes the clock edge to clock in or clock out data.
+ */
+typedef enum {
+	/*!
+	 * Clock on rising edge
+	 */
+	ssi_clock_on_rising_edge = 0,
+	/*!
+	 * Clock on falling edge
+	 */
+	ssi_clock_on_falling_edge = 1
+} ssi_tx_rx_clock_polarity;
+
+/*!
+ * This enumeration describes the clock direction.
+ */
+typedef enum {
+	/*!
+	 * Clock is external
+	 */
+	ssi_tx_rx_externally = 0,
+	/*!
+	 * Clock is generated internally
+	 */
+	ssi_tx_rx_internally = 1
+} ssi_tx_rx_direction;
+
+/*!
+ * This enumeration describes the early frame sync behavior.
+ */
+typedef enum {
+	/*!
+	 * Frame Sync starts on the first data bit
+	 */
+	ssi_frame_sync_first_bit = 0,
+	/*!
+	 * Frame Sync starts one bit before the first data bit
+	 */
+	ssi_frame_sync_one_bit_before = 1
+} ssi_tx_rx_early_frame_sync;
+
+/*!
+ * This enumeration describes the Frame Sync active value.
+ */
+typedef enum {
+	/*!
+	 * Frame Sync is active when high
+	 */
+	ssi_frame_sync_active_high = 0,
+	/*!
+	 * Frame Sync is active when low
+	 */
+	ssi_frame_sync_active_low = 1
+} ssi_tx_rx_frame_sync_active;
+
+/*!
+ * This enumeration describes the Frame Sync active length.
+ */
+typedef enum {
+	/*!
+	 * Frame Sync is active when high
+	 */
+	ssi_frame_sync_one_word = 0,
+	/*!
+	 * Frame Sync is active when low
+	 */
+	ssi_frame_sync_one_bit = 1
+} ssi_tx_rx_frame_sync_length;
+
+/*!
+ * This enumeration describes the Tx/Rx frame shift direction.
+ */
+typedef enum {
+	/*!
+	 * MSB first
+	 */
+	ssi_msb_first = 0,
+	/*!
+	 * LSB first
+	 */
+	ssi_lsb_first = 1
+} ssi_tx_rx_shift_direction;
+
+/*!
+ * This enumeration describes the wait state number.
+ */
+typedef enum {
+	/*!
+	 * 0 wait state
+	 */
+	ssi_waitstates0 = 0x0,
+	/*!
+	 * 1 wait state
+	 */
+	ssi_waitstates1 = 0x1,
+	/*!
+	 * 2 wait states
+	 */
+	ssi_waitstates2 = 0x2,
+	/*!
+	 * 3 wait states
+	 */
+	ssi_waitstates3 = 0x3
+} ssi_wait_states;
+
+/*!
+ * This enumeration describes the word length.
+ */
+typedef enum {
+	/*!
+	 * 2 bits long
+	 */
+	ssi_2_bits = 0x0,
+	/*!
+	 * 4 bits long
+	 */
+	ssi_4_bits = 0x1,
+	/*!
+	 * 6 bits long
+	 */
+	ssi_6_bits = 0x2,
+	/*!
+	 * 8 bits long
+	 */
+	ssi_8_bits = 0x3,
+	/*!
+	 * 10 bits long
+	 */
+	ssi_10_bits = 0x4,
+	/*!
+	 * 12 bits long
+	 */
+	ssi_12_bits = 0x5,
+	/*!
+	 * 14 bits long
+	 */
+	ssi_14_bits = 0x6,
+	/*!
+	 * 16 bits long
+	 */
+	ssi_16_bits = 0x7,
+	/*!
+	 * 18 bits long
+	 */
+	ssi_18_bits = 0x8,
+	/*!
+	 * 20 bits long
+	 */
+	ssi_20_bits = 0x9,
+	/*!
+	 * 22 bits long
+	 */
+	ssi_22_bits = 0xA,
+	/*!
+	 * 24 bits long
+	 */
+	ssi_24_bits = 0xB,
+	/*!
+	 * 26 bits long
+	 */
+	ssi_26_bits = 0xC,
+	/*!
+	 * 28 bits long
+	 */
+	ssi_28_bits = 0xD,
+	/*!
+	 * 30 bits long
+	 */
+	ssi_30_bits = 0xE,
+	/*!
+	 * 32 bits long
+	 */
+	ssi_32_bits = 0xF
+} ssi_word_length;
+
+#endif				/* __MXC_SSI_TYPES_H__ */
Index: linux-2.6.18/arch/arm/Kconfig
===================================================================
--- linux-2.6.18.orig/arch/arm/Kconfig
+++ linux-2.6.18/arch/arm/Kconfig
@@ -972,6 +972,10 @@ if ARCH_OMAP
 source "drivers/cbus/Kconfig"
 endif
 
+if ARCH_MXC
+source "drivers/mxc/Kconfig"
+endif
+
 endmenu
 
 source "fs/Kconfig"
Index: linux-2.6.18/mvl_patches/pro50-0968.c
===================================================================
--- /dev/null
+++ linux-2.6.18/mvl_patches/pro50-0968.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2008 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(968);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

